---
title: Vue 源码设计和构建流程
date: 2021-04-12 15:45:35
permalink: /pages/sswewe31ef7
author: jeffery
categories: 
  - Vue 源码
tags: 
  - Vue 源码
---

# Vue 源码设计和构建流程

阅读源码的注释仓库[github](https://github.com/JefferyXZF/vue/tree/dev-doc)
## 介绍

本篇`Vue2.6.12`源码分析文章由观看[Vue.js源码全方位深入解析](https://coding.imooc.com/class/228.html)视频，阅读[深入浅出Vue.js](https://www.ituring.com.cn/book/2675)书籍以及参考其他`Vue`源码分析博客而来，阅读视频和书籍请支持正版。

### Vue版本变化

`Vue2.0`版本和`Vue1.0`版本相比引入了很多特性：

- `Virtual DOM`虚拟DOM。
- 支持`JSX`语法。
- 支持`TypeScript`。
- 支持服务端渲染`ssr`。
- 提供跨平台能力`weex`。

**正确理解虚拟DOM**：`Vue`中的虚拟DOM借鉴了开源库[snabbdom](https://github.com/snabbdom/snabbdom)的实现，并根据自身特色添加了许多特性。引入虚拟DOM的一个很重要的好处是：绝大部分情况下，组件渲染变得更快了，而少部分情况下反而变慢了。引入虚拟DOM这项技术通常都是在解决一些问题，然而解决一个问题的同时也可能会引入其它问题，这种情况更多的是如何做权衡、如何做取舍。因此，一味的强调虚拟DOM在任何时候都能提高性能这种说法需要正确对待和理解。



## Vue 源码目录结构

梳理 `Vue` 源码的目录结构，了解各个目录文件的作用，对 `Vue` 架构有一个整体的认识，方便我们快速定位代码片段；同时也可以学习`Vue` 优秀的设计思路。

`Vue.js`源码目录设计如下：

```sh
|——.circleci ------------ CI 工具
|——.github ------------ github 贡献指南，包括代码提交规范、issue规范、PR规范等
|—— benchmarks --------- 性能测试文件
|—— dist --------------- rollup 构建输出不同版本 vue 文件
|—— examples ----------- vue 使用的一些 demo
|—— flow --------------- JS静态类型检查工具 [Flow](https://flowtype.org/) 的类型声明
|—— packages ----------- 独立的 vue 相关 npm 包
|—— scripts ------------ 包含与构建相关的脚本和配置文件
├── test --------------- 测试文件
├── types -------------- TypeScript 类声明文件
├── src ---------------- 源码目录
│   ├── compiler ------- 编译器代码，用来将 template 编译为 render 函数
│   ├── core ----------- 存放通用的，平台无关的运行时代码
│   ├── server --------- 服务端渲染(server-side rendering)的相关代码
│   ├── platforms ------ 不同平台特有的相关代码
│   ├── sfc ------------ 包含单文件组件(.vue文件)的解析逻辑，用于vue-template-compiler包
│   ├── shared --------- 整个代码库通用的代码
```

对以上目录简要做如下介绍：

- `.circleci`：工程化 `CI` 工具，和发布部署相关
- `.github`： github 贡献指南，包括代码提交规范、issue规范、PR规范等

- `dist`：`rollup` 构建目录，里面存放了所有`Vue`构建后不同版本的文件。
- `flow`：它是Facebook出品的`JavaScript`静态类型检查工具，早期`Vue.js`选择了`flow`而不是现在的`TypeScript`来做静态类型检查，而在最新的`Vue3.0`版本则选择使用`TypeScript`来重写。
- `packages`：`Vue.js`衍生的其它`npm`包，它们在`Vue`构建时自动从源码中生成并且始终和`Vue.js`保持相同的版本，主要是`vue-server-renderer`和`vue-template-compiler`这两个包，其中最后一个包在我们使用脚手架生成项目，也就是使用`.vue`文件开发`Vue`项目时会使用到这个包(`vue-loader`)。
- `scripts`：`rollup`构建配置和构建脚本，`Vue.js`能够通过不同的环境构建不同的版本的秘密都在这个目录下。
- `test`：`Vue.js`测试目录，自动化测试对于一个开源库来说是至关重要的，测试覆盖率在一定程度上是衡量一个库质量的一个重要指标。测试用例无论对于开发还是阅读源码，都是有很大益处的，其中通过测试用例去阅读`Vue`源码是普遍认为可行的一种方式。

### compiler

`src/compiler`：此目录包含了`Vue.js` 编译器，编译过程分为三个过程：

- `parser` 解析器：通过正则匹配将  `template` 转化为 `AST`
-  `optimizer` 优化器：给 `AST` 打上静态或根静态节点标识，在进行 `diff` 对比直接当作静态`HTML`
- `codegen` 生成器：将 `AST` 转化可执行代码 `render` 函数

```sh
├── src ---------------- 源码目录
│   ├── compiler ------- 编译器代码，用来将 template 编译为 render 函数
│   │   ├── codegen ---- 存放从抽象语法树(AST)生成 render 函数的代码
│   │   ├── directives -- v-on, v-bind, v-cloak, v-model 指令
│   │   ├── parser ----- 存放将模板字符串转换成元素 AST 抽象语法树的代码
│   │   ├── create-compiler.js --- createCompilerCreator 方法 返回 compile，compileToFunctions
│   │   ├── optimizer.js ---- 分析静态树，优化 vdom 渲染
```



编译的工作可以在构建时用`runtime-only`版本，借助`webpack`和`vue-loader`等工具或插件来进行编译。也可以在运行时，使用包含构建功能的`runtime + compiler`版本。显然，编译是一项比较消耗性能的工作，所以我们日常的开发中，更推荐使用`runtime-only`的版本开发(体积也更小)，也就是通过`.vue`文件的形式开发。

```js
// 需要使用带编译的版本
new Vue({
  data: {
    msg: 'hello,world'
  }
  template: '<div>{{msg}}</div>'
})

// 不需要使用带编译的版本
new Vue({
  data: {
    msg: 'hello,world'
  },
  render (h) {
    return h('div', this.msg)
  }
})
```



### core

`src/core`：此目录包含了`Vue.js`的核心代码，包括：内置组件`keep-alive`、全局 API(`Vue.use`、`Vue.mixin`和`Vue.extend`等)、实例化、响应式相关、虚拟 DOM 和工具函数等。

```sh
|—— components ------- 内置组件的代码，即 keep-alive 代码
|—— global-api ------- 全局 API 代码, 
|—— instance ---------- vue 实例化相关代码
│   ├── event.js ----- initEvents, add 添加事件监听, remove 移除事件监听, eventsMixin
│   ├── index.js ----- 定义 Vue 构造函数，添加原型属性和方法
│   ├── init.js ------- 定义 initMixin
│   ├── inject.js ----- 定义 initInjections
│   ├── lifecycle.js -- 定义 lifecycleMixin
│   ├── proxy.js ------ 定义 initProxy
│   ├── render.js ----- 定义 renderMixin，initRender
│   ├── state.js ------ 定义 initState，initProps, initData, initComputed, initMethods, initWatch, stateMixin
|—— observer --------- 数据响应式
│   ├── array.js ----- 重写数组方法 'push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse'
│   ├── dep.js ------- 依赖收集 Dep 类，方法(addSub, removeSub, depend, notify, pushTarget, popTarget)
│   ├── index.js ------ 构建响应式系统 (Observer, observe, defineReactive, set, del)
│   ├── watch.js ------ 数据监听 Watcher（get, addDep, cleanupDeps, update, run , evaluate, depend, teardown)
|—— vdom ------- 虚拟 DOM 和组件创建，patch 更新真实 DOM
│   ├── create-component.js ------- 组件钩子函数(init, prepatch, insert, destroy ), createComponent 创建组件
│   ├── create-element.js --------- createElement 创建元素 (原生标签 - new Vnode, 组件 -> createComponent)
│   ├── create-functional.component.js ----- 创建函数式组件
│   ├── patch.js ------ createPatchFunction， createElm, createComponent diff算法，跟新真实DOM
│   ├── vnode.js ------ VNode 类

```

在 `new Vue` 实例化之前，`Vue` 会往自己的身上挂载 `API`，它的 `API` 分为全局 API 和 原型 API

`global-api` 目录挂载 `全局 API`

`instance` 目录挂载原型 `API` 和属性，主要是通过 `xxxMixin` 添加

- initMixin：添加 `_init` 方法
- stateMixin：添加 `$data`, `$props`, `$set`, `$delete`, `$watch`
- eventsMixin 添加 `$on`, `$once`, `$off`, `$emit` 方法
- lifecycleMixin 添加 `_update`, `$forceUpdate`, `$destroy` 方法
- renderMixin：添加 `$nextTick`, `_render` 方法

为什么通过函数调用的方式添加呢，我认为主要是方便代码的维护和扩展，通过查看目录文件 `initMxin` 方法对应 `init` 文件，`stateMixin` 对应 `state` 文件，虽然代码量很大，但还是很清晰的知道哪个文件做哪些事情，不得不说 `Vue` 源码目录设计的很巧妙



### platforms

`src/platforms` 下包含两个子目录，`web` 和 `weex`。

分别代表可以打包生成在 `web` 端使用的 `vue` 代码和在 `native` 端使用的 `weex` 代码。通过不同平台的入口就可以打包出运行在不同平台的版本的 `vue` 文件。

```sh
│   ├── platforms ------ 不同平台特有的相关代码
│   │   ├── weex ------- weex 平台支持
│   │   ├── web -------- web平台支持
│   │   │   ├── entry-runtime.js ---------------- 运行时构建的入口
│   │   │   ├── entry-runtime-with-compiler.js -- 运行时+编译器构建版本的入口
│   │   │   ├── entry-compiler.js --------------- vue-template-compiler 包的入口文件
│   │   │   ├── entry-server-renderer.js -------- vue-server-renderer 包的入口文件
```

### server

`src/server` 目录是 `SSR` 服务器渲染相关的代码。

`Vue.js` 是构建客户端应用程序的框架。除了可以在浏览器中输出 `Vue` 组件，也可以将同一个组件渲染为服务器端的 `HTML` 字符串，将它们直接发送到浏览器，最后将这些静态标记”激活”为客户端上完全可交互的应用程序。

### sfc

`src/sfc`：此目录的主要作用是如何把`.vue`文件解析成一个`JavaScript`对象。

### shared

`src/shared`：此目录下存放了一些在 Web 浏览器端和服务端都会用到的共享代码。



## 架构设计

我们通过以上目录结构可以很容易的发现，`Vue.js`整体分为三个部分：**核心代码**、**跨平台相关**和**公共工具函数**。

同时其架构是分层的，最底层是一个构造函数(普通的函数)，最上层是一个入口，也就是将一个完整的构造函数导出给用户使用。在中间层，我们需要逐渐添加一些方法和属性，主要是原型`prototype`相关和全局API相关。

![Vue架构设计](https://gitee.com/FIF/pic-beg/raw/master/images/vue/composition.ce78fa55.png)

## Vue 源码构建



`Vue.js`通过`rollup`构建工具进行构建，它是一个类似于`webpack`的打包工具，不过它更适合一个`Library`库的打包。在学习`Vue.js`源码之前，先学习 `rollup` 基础知识，了解它是如果构建不同版本的库。

### Rollup 核心概念

同`webpack`一样，`rollup`也有以下几大核心概念：

- `input`：入口文件，类比于`webpack`的`entry`，它指明了我们库文件入口位置。
- `output`：输出位置，它指明了打包后的输出信息，包括：输出目录，打包文件名等。
- `plugins`：插件，`rollup`在构建过程中，插件可提供一些辅助功能，例如：`alias`别名解析、转义`ES6`等。
- `external`：当我们的库依赖于其它第三方库时，我们不需要把这些第三方库一起打包，而是应该把依赖写在`external`里面。

同`webpack`一样，`rollup`同样适合使用配置文件的做法来配置打包的选项，例如：

```js
// rollup.config.js
export default {
  input: 'src/main.js',
  output: [
    { file: 'dist/vue.js', format: 'umd', name: 'Vue' },
    { file: 'dist/vue.common.js', format: 'cjs', name: 'Vue' },
    { file: 'dist/vue.esm.js', format: 'es', name: 'Vue' }
  ]
}
```



构建版本说明：

- `umd`：此选项构建出来的库文件主要适用于`Web`端，可以通过不同的方式去使用：`script`标签引入，`ES Module`规范引入和`CommonJs`规范引入等。
- `cjs`: 此选项构建出来的库文件主要为`CommonJs`规范，可在`Node`环境中使用。
- `es`：此版本构建出来的库文件主要为`ES Module`规范，可在支持`ES Module`也就是`import/export`的环境中使用。

有了以上配置文件，我们可以在`package.json`中进行如下修改：

```json
{
  "name": "Vue",
  "version": "2.0.0",
  "scripts": {
    "dev": "rollup -w -c scripts/rollup.config.dev.js",
    "build": "rollup -c scripts/rollup.config.prod.js"
  }
}
```

参数说明：

- `-c`：为`--config`的缩写，表示设置`rollup`打包的配置。
- `-w`：为`--watch`的缩写，在本地开发环境添加`-w`参数可以监控源文件的变化，自动重新打包。



### 常用插件

`rollup`并不像`webpack`那样强大，它需要和其它插件配合使用才能完成特定的功能，常用的插件有：

- `@rollup/plugin-json`： 支持从`.json`读取信息，配合`rollup`的`Tree Shaking`可只打包`.json`文件中我们用到的部分。
- `@rollup/plugin-commonjs`：将`CommonJs`规范的模块转换为`ES6`提供`rollup`使用。
- `@rollup/plugin-node-resolve`：与`@rollup/plugin-commonjs`插件一起使用，配合以后就可以使用`node_modules`下的第三方模块代码了。
- `@rollup/plugin-babel`：把`ES6`代码转义成`ES5`代码，需要同时安装`@babel/core`和`@babel/preset-env`插件。注意：如果使用了高于`ES6`标准的语法，例如`async/await`，则需要进行额外的配置。
- `rollup-plugin-terser`：代码压缩插件，另外一种方案是`rollup-plugin-uglify` + `uglify-es`进行代码压缩，不过更推荐第一种方案。

以上插件使用方式如下：

```js
// rollup.config.js
import commonjs from '@rollup/plugin-commonjs'
import json from '@rollup/plugin-json'
import resolve from '@rollup/plugin-node-resolve'
import babel from '@rollup/plugin-babel'
import { terser } from 'rollup-plugin-terser'

const config =  {
  input: 'src/index.js',
  output: [
    { file: 'dist/vue.js', format: 'umd', name: 'Vue' },
    { file: 'dist/vue.common.js', format: 'cjs', name: 'Vue', exports: 'auto' },
    { file: 'dist/vue.esm.js', format: 'es', name: 'Vue', exports: 'auto' }
  ],
  plugins: [
    json(),
    resolve(),
    babel(),
    commonjs(),
    terser()
  ]
}

export default config
```

###  区分生产环境和开发环境

正如在上面看到的那样，我们可以像`webpack`一样进行开发环境和生产环境的配置区分，我们把和`rollup`构建相关的文件都放在`scripts`目录下：

```sh
|-- scripts
|   |-- rollup.config.base.js      # 公共配置
|   |-- rollup.config.dev.js       # 开发环境配置
|   |-- rollup.config.prod.js      # 生产环境配置
```

根据我们的拆分逻辑，`rollup.config.base.js`代码如下：

```js
import commonjs from '@rollup/plugin-commonjs'
import json from '@rollup/plugin-json'
import resolve from '@rollup/plugin-node-resolve'
import babel from '@rollup/plugin-babel'

const config =  {
  input: 'src/index.js',
  plugins: [
    json(),
    resolve(),
    babel(),
    commonjs()
  ]
}

export default config
```

`rollup.config.dev.js`代码如下：

```js
import baseConfig from './rollup.config.base.js'
import serve from 'rollup-plugin-serve'
import { name } from '../package.json'

const config =  {
  ...baseConfig,
  output: [
    { file: 'dist/vue.js', format: 'umd', name },
    { file: 'dist/vue.common.js', format: 'cjs', name, exports: 'auto' },
    { file: 'dist/vue.esm.js', format: 'es', name, exports: 'default' }
  ],
  plugins: [
    ...baseConfig.plugins,
    serve({
      open: true,
      port: '4300',
      openPage: '/example/index.html',
      contentBase: ''
    })
  ]
}
export default config
```

配置说明：本地开发环境下，我们可以有选择的添加`rollup-plugin-serve`插件，它类似于`webpack-dev-server`，能在开发环境下起一个服务方便我们进行开发和代码调试。

`rollup.config.prod.js`代码如下：

```js
import baseConfig from './rollup.config.base.js'
import { terser } from 'rollup-plugin-terser'
import { name } from '../package.json'
const config =  {
  ...baseConfig,
  output: [
    { file: 'dist/vue.min.js', format: 'umd', name },
    { file: 'dist/vue.common.min.js', format: 'cjs', name, exports: 'auto' },
    { file: 'dist/vue.esm.min.js', format: 'es', name, exports: 'default' }
  ],
  plugins: [
    ...baseConfig.plugins,
    terser()
  ]
}

export default config
```

配置说明：生产环境下，我们需要对代码进行压缩处理，对`ES Module`，`CommonJs`和`UMD`等规范分别生成其对应的压缩文件。

分别运行`npm run dev`和`npm run build`之后，我们可以得到如下的目录：

```sh
|-- dist
|   |-- vue.js            # UMD未压缩版本
|   |-- vue.min.js        # UMD压缩版本
|   |-- vue.esm.js        # ES Module未压缩版本
|   |-- vue.esm.min.js    # ES Module压缩版本
|   |-- vue.common.js     # CommonJs未压缩版本
|   |-- vue.common.min.js # CommonJs压缩版本
```

最后，如果我们像`Vue.js`一样构建的是一个库文件，那么我们还需要在`package.json`进行如下配置：

```json
{
  "main": "dist/vue.common.js",
  "module": "dist/vue.esm.js"
}

```



## 构建流程



`vue` 的源码按照功能拆分的十分清晰，每个功能都有单独的目录，那么项目中引用的 `vue` 文件是怎么编译出来的呢？

首先，我们看一下编译输出的 `dist` 目录。

```sh
|—— dist 
│   ├── vue.common.dev.js // common.js 规范未压缩开发版本
│   ├── vue.common.prod.js // common.js 规范压缩生产版本
│   ├── vue.esm.browser.js 
│   ├── vue.esm.browser.min.js 
│   ├── vue.esm.js // ES Module 规范
│   ├── vue.js  // UMD 规范
│   ├── vue.min.js // UMD 规范压缩版本
│   ├── vue.runtime.common.dev.js // runtime only 版本
│   ├── vue.runtime.common.js 
│   ├── vue.runtime.common.prod.js 
│   ├── vue.runtime.esm.js 
│   ├── vue.runtime.js 
│   ├── vue.runtime.min.js
```

可以看到，`dist` 下有 10 几个不同的 `vue` 文件，他们根据不同规范（包括 `CommonJS` 规范，`ES Module`，`UMD`）和 是否包含编译器 构建出的不同版本。

下面看一下 `vue` 具体构建过程，首先到 `pakage.json` 中看下 `vue` 编译执行的命令。

```bash
    "dev": "rollup -w -c scripts/config.js --source-map --environment TARGET:web-full-dev",
    "dev:cjs": "rollup -w -c scripts/config.js --environment TARGET:web-runtime-cjs-dev",
    "dev:esm": "rollup -w -c scripts/config.js --environment TARGET:web-runtime-esm",
    "build": "node scripts/build.js"
```

当运行 `npm run build` 命令，执行 `scripts` 目录下 `build.js` 文件。

下面是 `scripts/build.js` 核心代码

```js
// 判断是否存在 dist 目录，不存在就创建 dist
if (!fs.existsSync('dist')) {
  fs.mkdirSync('dist')
}

// 读取构建需要的配置
let builds = require('./config').getAllBuilds()

// 根据构建命令传入的参数过滤配置，过滤后的配置构建出不同 vue 版本文件
// filter builds via command line arg
if (process.argv[2]) {
  const filters = process.argv[2].split(',')
  builds = builds.filter(b => {
    return filters.some(f => b.output.file.indexOf(f) > -1 || b._name.indexOf(f) > -1)
  })
} else {
  // filter out weex builds by default
  builds = builds.filter(b => {
    return b.output.file.indexOf('weex') === -1
  })
}

build(builds)
```

从代码可以看出，首先通过 `script/config.js` 文件的 `getAllBuilds` 方法获取配置，然后根据构建命令传入的参数对配置进行过滤，最后根据过滤后的配置执行 `build` 函数，编译出对应版本的 vue 文件。

看一下 `build` 方法

```js
function build (builds) {
  let built = 0
  const total = builds.length
  const next = () => {
    buildEntry(builds[built]).then(() => {
      // 递归处理构建输出文件
      built++
      if (built < total) {
        next()
      }
    }).catch(logError)
  }

  next()
}
```

上面可以看到，`build` 方法递归的调用 `next` 方法，`next` 方法调用 `buildEntry` 打包输出

```js
function buildEntry (config) {
  const output = config.output
  const { file, banner } = output
  const isProd = /(min|prod)\.js$/.test(file) // 生产版本
  return rollup.rollup(config)
    .then(bundle => bundle.generate(output))
    .then(({ output: [{ code }] }) => {
      if (isProd) { // 生产版本开启代码压缩
        const minified = (banner ? banner + '\n' : '') + terser.minify(code, {
          toplevel: true,
          output: {
            ascii_only: true
          },
          compress: {
            pure_funcs: ['makeMap']
          }
        }).code
        return write(file, minified, true)
      } else {
        return write(file, code)
      }
    })
}
```

接下来我们在看一下配置文件 `script/config.js` 中的 `getAllBuilds` 是怎么获取具体配置的。

```js
if (process.env.TARGET) {
  module.exports = genConfig(process.env.TARGET)
} else {
  exports.getBuild = genConfig
  exports.getAllBuilds = () => Object.keys(builds).map(genConfig) // 
}
```

可以看出，`getAllBuilds` 方法首先通过 `Object.keys` 拿到 `builds` 对象所有 `key` 的组成的数组，并通过 `map` 遍历执行 `genConfig` 方法。下面我们先看一下 `builds` 对象。

```js
const aliases = require('./alias')
const resolve = p => {
  const base = p.split('/')[0]
  if (aliases[base]) {
    return path.resolve(aliases[base], p.slice(base.length + 1))
  } else {
    return path.resolve(__dirname, '../', p)
  }
}

const builds = {
  // Runtime only (CommonJS). Used by bundlers e.g. Webpack & Browserify
  'web-runtime-cjs-dev': {
    entry: resolve('web/entry-runtime.js'),
    dest: resolve('dist/vue.runtime.common.dev.js'),
    format: 'cjs',
    env: 'development',
    banner
  },
  'web-runtime-cjs-prod': {
    entry: resolve('web/entry-runtime.js'),
    dest: resolve('dist/vue.runtime.common.prod.js'),
    format: 'cjs',
    env: 'production',
    banner
  },
  //...
}
```

可以看出，`builds` 对象是不同版本 `vue` 的编译配置

```js
function genConfig (name) {
  const opts = builds[name]
  const config = {
    input: opts.entry, // 打包入口
    external: opts.external, // 第三方依赖或独立 npm 包
    plugins: [
      flow(),
      alias(Object.assign({}, aliases, opts.alias))
    ].concat(opts.plugins || []),
    output: {
      file: opts.dest, // 打包输出文件
      format: opts.format, // 文件规范 umd, commonjs, esm
      banner: opts.banner,
      name: opts.moduleName || 'Vue'
    }
  }
	//...

  return config
}
```

`genConfig` 通过 `key` 拿到 `builds` 中每个 `key` 对应的配置对象，然后根据这个对象重新定义一个 `config` 对象，这个 `config` 对象的结构才是 `rollup` 配置真正需要的结构。

看了 `builds` 对象和 `genConfig` 方法，我们就知道了 `getAllBuilds` 的目的，是通过映射把 `builds` 配置对象转化成 `rollup` 所需要的配置数据。

到这里，我们就清楚是如何构建出不同版本的 vue 代码了。



## 总结

学习源码时，不建议按照源码的顺序一行一行的阅读。首先要抓住主干，先梳理清楚主要的代码逻辑，再去仔细阅读具体的每行代码。另外按照源码顺序阅读可能很枯燥，很难坚持下来，可以先选择自己感兴趣的部分进行学习，最后再串联起来。