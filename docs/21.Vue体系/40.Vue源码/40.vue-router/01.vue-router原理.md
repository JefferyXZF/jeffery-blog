---
title: vue-router 原理
date: 2021-05-04 20:04:35
permalink: /pages/seweweeleeef7
author: jeffery
categories: 
  - Vue 源码
tags: 
  - Vue 源码
  - Vue
---

# vue-router 原理

## vue-router是什么？
vue-router是Vue.js官方的路由插件，它和vue.js是深度集成的，适合用于构建单页面应用。

那与传统的页面跳转有什么区别呢？

- vue的单页面应用是基于路由和组件的，路由用于设定访问路径，并将路径和组件映射起来。

- 传统的页面应用，是用一些超链接来实现页面切换和跳转的。

在vue-router单页面应用中，路径之间的切换，也就是组件的切换。路由模块的本质 就是建立起url和页面之间的映射关系。



## vue-router实现原理
SPA(single page application):单一页面应用程序，有且只有一个完整的页面；当它在加载页面的时候，不会加载整个页面的内容，而只更新某个指定的容器中内容。

`vue-router` 使用的是单页应用，它本质是监听 URL 的变化，然后匹配路由规则，显示相应的页面组件，无须刷新页面

单页面应用(SPA)的核心之一是:

- 更新视图而不重新请求页面;

- vue-router在实现单页面前端路由时，提供了三种方式：Hash模式、History模式、abstract模式，根据mode参数来决定采用哪一种方式。

#### 路由模式
vue-router 提供了三种运行模式：

● hash: 使用 URL hash 值来作路由。默认模式。

● history: 依赖 HTML5 History API 和服务器配置。查看 HTML5 History 模式。

● abstract: 支持所有 JavaScript 运行环境，如 Node.js 服务器端。

### Hash模式
**vue-router 默认模式是 hash 模式 —— 使用 URL 的 hash 来模拟一个完整的 URL，当 URL 改变时，页面不会去重新加载**。 

hash（#）是URL 的锚点，代表的是网页中的一个位置，单单改变#后的部分（/#/..），浏览器只会加载相应位置的内容，不会重新加载网页，也就是说 #是用来指导浏览器动作的，对服务器端完全无用，HTTP请求中不包括#；同时每一次改变#后的部分，都会在浏览器的访问历史中增加一个记录，使用”后退”按钮，就可以回到上一个位置；**所以说Hash模式通过锚点值的改变，根据不同的值，渲染指定DOM位置的不同数据**。

### History模式
HTML5 History API提供了一种功能，能让开发人员在不刷新整个页面的情况下修改站点的URL，就是利用 history.pushState API 来完成 URL 跳转而无须重新加载页面；

由于hash模式会在url中自带#，如果不想要很丑的 hash，我们可以用路由的 history 模式，只需要在配置路由规则时，加入"mode: 'history'",这种模式充分利用 history.pushState API 来完成 URL 跳转而无须重新加载页面。

```js
//main.js文件中
const router = new VueRouter({
  mode: 'history',
  routes: [...]
})
```
当你使用 history 模式时，URL 就像正常的 url，例如 `http://yoursite.com/user/id`，也好看！

不过这种模式要玩好，还需要后台配置支持。因为我们的应用是个单页客户端应用，如果后台没有正确的配置，当用户在浏览器直接访问 `http://oursite.com/user/id` 就会返回 404，这就不好看了。

所以呢，你要在服务端增加一个覆盖所有情况的候选资源：如果 URL 匹配不到任何静态资源，则应该返回同一个 `index.html` 页面，这个页面就是你 app 依赖的页面。

```js
export const routes = [ 
  {path: "/", name: "homeLink", component:Home}
  {path: "/register", name: "registerLink", component: Register},
  {path: "/login", name: "loginLink", component: Login},
  {path: "*", redirect: "/"}]
  
```
此处就设置如果URL输入错误或者是URL 匹配不到任何静态资源，就自动跳到到Home页面。

### abstract模式
abstract模式是使用一个不依赖于浏览器的浏览历史虚拟管理后端。

根据平台差异可以看出，在 Weex 环境中只支持使用 abstract 模式。 不过，vue-router 自身会对环境做校验，如果发现没有浏览器的 API，vue-router 会自动强制进入 abstract 模式，所以 在使用 vue-router 时只要不写 mode 配置即可，默认会在浏览器环境中使用 hash 模式，在移动端原生环境中使用 abstract 模式。

## vue-router使用流程
![使用流程](https://gitee.com/FIF/pic-beg/raw/master/images/javascript/852cd383-a782-414c-9933-149d19db4198.6f622c11.png)

1、**安装插件** Vue.use(VueRouter);

2、**创建路由对象，并配置路由规则**

3、**挂载Vue的实例**

具体实现请看如下代码：

```js
//main.js文件中引入
import Vue from 'vue';
import VueRouter from 'vue-router';
//主体
import App from './components/app.vue';
import index from './components/index.vue'
//1、安装插件
Vue.use(VueRouter); //挂载属性
//2、创建路由对象并配置路由规则
let router = new VueRouter({
    routes: [
        //一个个对象
        { path: '/index', component: index }
    ]
});

//3、new Vue 启动
new Vue({
    el: '#app',
    //让vue知道我们的路由规则
    router: router, //可以简写router
    render: c => c(App),
})
```


## 源码目录结构

![image-20210808172719176](https://gitee.com/FIF/pic-beg/raw/master/images/javascript/image-20210808172719176.png)



源码目录结构很清晰，主要分为全局注册的组件 `router-link`和 `router-view`、维护路由3种模式的history目录、vue插件的注册方法install.js、模块导出文件index.js

### 核心功能

![核心特性](https://gitee.com/FIF/pic-beg/raw/master/images/javascript/9516091f-4193-41fc-b668-a8bd5e511ffe.e4841337.png)

以上这些是vue-router提供的核心功能，完整的用法说明可以参考[官方文档](https://router.vuejs.org/zh/guide/essentials/dynamic-matching.html#响应路由参数的变化)，下面将逐步分析vue-router源码中是如何实现以上这些核心功能的。



### 源码重要函数脑图

![p1-jj.byteimg.com_to (1)](https://gitee.com/FIF/pic-beg/raw/master/images/javascript/p1-jj.byteimg.com_to%20(1).png)



## vue-router源码分析

我们先来看看vue的实现路径。



![](https://gitee.com/FIF/pic-beg/raw/master/images/javascript/16684f162d3090eb.png)

## 路由注册

使用路由之前，需要调用 `Vue.use(VueRouter)`，这是因为让插件可以使用 Vue

```js
export function initUse (Vue: GlobalAPI) {
  Vue.use = function (plugin: Function | Object) {
    // 判断重复安装插件
    const installedPlugins = (this._installedPlugins || (this._installedPlugins = []))
    if (installedPlugins.indexOf(plugin) > -1) {
      return this
    }
    const args = toArray(arguments, 1)
    // 插入 Vue
    args.unshift(this)
    // 一般插件都会有一个 install 函数
    // 通过该函数让插件可以使用 Vue
    if (typeof plugin.install === 'function') {
      plugin.install.apply(plugin, args)
    } else if (typeof plugin === 'function') {
      plugin.apply(null, args)
    }
    installedPlugins.push(plugin)
    return this
  }
}

```

接下来看下 `install` 函数的部分实现

```js
export function install (Vue) {
  // 确保 install 调用一次
  if (install.installed && _Vue === Vue) return
  install.installed = true
  // 把 Vue 赋值给全局变量
  _Vue = Vue
  const registerInstance = (vm, callVal) => {
    let i = vm.$options._parentVnode
    if (isDef(i) && isDef(i = i.data) && isDef(i = i.registerRouteInstance)) {
      i(vm, callVal)
    }
  }
  // 给每个组件的钩子函数混入实现
  // 可以发现在 `beforeCreate` 钩子执行时
  // 会初始化路由
  Vue.mixin({
    beforeCreate () {
      // 判断组件是否存在 router 对象，该对象只在根组件上有
      if (isDef(this.$options.router)) {
        // 根路由设置为自己
        this._routerRoot = this
        this._router = this.$options.router
        // 初始化路由
        this._router.init(this)
        // 很重要，为 _route 属性实现双向绑定
        // 触发组件渲染
        Vue.util.defineReactive(this, '_route', this._router.history.current)
      } else {
        // 用于 router-view 层级判断
        this._routerRoot = (this.$parent && this.$parent._routerRoot) || this
      }
      registerInstance(this, this)
    },
    destroyed () {
      registerInstance(this)
    }
  })
  // 全局注册组件 router-link 和 router-view
  Vue.component('RouterView', View)
  Vue.component('RouterLink', Link)
}

```

对于路由注册来说，核心就是调用 `Vue.use(VueRouter)`，使得 VueRouter 可以使用 Vue。然后通过 Vue 来调用 VueRouter 的 `install` 函数。在该函数中，核心就是给组件混入钩子函数和全局注册两个路由组件。



## VueRouter 实例化

在安装插件后，对 VueRouter 进行实例化。

```js
const Home = { template: '<div>home</div>' }
const Foo = { template: '<div>foo</div>' }
const Bar = { template: '<div>bar</div>' }

// 3. Create the router
const router = new VueRouter({
  mode: 'hash',
  base: __dirname,
  routes: [
    { path: '/', component: Home }, // all paths are defined without the hash.
    { path: '/foo', component: Foo },
    { path: '/bar', component: Bar }
  ]
})

```



来看一下 VueRouter 的构造函数

![路由实例router](https://gitee.com/FIF/pic-beg/raw/master/images/javascript/3208bfb8-d96d-4e3f-bdd0-aa6d2687235d.4063c41c.png)

在入口文件中需要实例化一个 VueRouter 的实例对象 ，然后将其传入 Vue 实例的 options 中。

```js
export default class VueRouter {
  constructor (options: RouterOptions = {}) {

    // 1、创建 matcher 匹配函数
    this.matcher = createMatcher(options.routes || [], this)
    // 根据 mode 实例化具体的 History，默认为'hash'模式
    let mode = options.mode || 'hash'
    // 通过 supportsPushState 判断浏览器是否支持'history'模式
    // 如果设置的是'history'但是如果浏览器不支持的话，'history'模式会退回到'hash'模式
    // fallback 是当浏览器不支持 history.pushState 控制路由是否应该回退到 hash 模式。默认值为 true。
    this.fallback = mode === 'history' && !supportsPushState && options.fallback !== false
    if (this.fallback) {
      mode = 'hash'
    }
    // 不在浏览器内部的话，就会变成'abstract'模式
    if (!inBrowser) {
      mode = 'abstract'
    }
    this.mode = mode
     // 根据不同模式选择实例化对应的 History 类
    switch (mode) {
      case 'history':
        this.history = new HTML5History(this, options.base)
        break
      case 'hash':
        this.history = new HashHistory(this, options.base, this.fallback)
        break
      case 'abstract':
        this.history = new AbstractHistory(this, options.base)
        break
      default:
        if (process.env.NODE_ENV !== 'production') {
          assert(false, `invalid mode: ${mode}`)
        }
    }
  }

  match (
    raw: RawLocation,
    current?: Route,
    redirectedFrom?: Location
  ): Route {
    return this.matcher.match(raw, current, redirectedFrom)
  }

  get currentRoute (): ?Route {
    return this.history && this.history.current
  }

  init (app: any /* Vue component instance */) {
    process.env.NODE_ENV !== 'production' && assert(
      install.installed,
      `not installed. Make sure to call \`Vue.use(VueRouter)\` ` +
      `before creating root instance.`
    )

    this.apps.push(app)

    // main app already initialized.
    if (this.app) {
      return
    }

    this.app = app

    const history = this.history
    // 根据history的类别执行相应的初始化操作和监听
    if (history instanceof HTML5History) {
      history.transitionTo(history.getCurrentLocation())
    } else if (history instanceof HashHistory) {
      const setupHashListener = () => {
        history.setupListeners()
      }
      history.transitionTo(
        history.getCurrentLocation(),
        setupHashListener,
        setupHashListener
      )
    }

    history.listen(route => {
      this.apps.forEach((app) => {
        app._route = route
      })
    })
  }
  // 路由跳转之前
  beforeEach (fn: Function): Function {
    return registerHook(this.beforeHooks, fn)
  }
  // 路由导航被确认之间前
  beforeResolve (fn: Function): Function {
    return registerHook(this.resolveHooks, fn)
  }
  // 路由跳转之后
  afterEach (fn: Function): Function {
    return registerHook(this.afterHooks, fn)
  }
  // 第一次路由跳转完成时被调用的回调函数
  onReady (cb: Function, errorCb?: Function) {
    this.history.onReady(cb, errorCb)
  }
  // 路由报错
  onError (errorCb: Function) {
    this.history.onError(errorCb)
  }
  // 路由添加，这个方法会向history栈添加一个记录，点击后退会返回到上一个页面。
  push (location: RawLocation, onComplete?: Function, onAbort?: Function) {
    this.history.push(location, onComplete, onAbort)
  }
  // 这个方法不会向history里面添加新的记录，点击返回，会跳转到上上一个页面。上一个记录是不存在的。
  replace (location: RawLocation, onComplete?: Function, onAbort?: Function) {
    this.history.replace(location, onComplete, onAbort)
  }
  // 相对于当前页面向前或向后跳转多少个页面,类似 window.history.go(n)。n可为正数可为负数。正数返回上一个页面
  go (n: number) {
    this.history.go(n)
  }
  // 后退到上一个页面
  back () {
    this.go(-1)
  }
  // 前进到下一个页面
  forward () {
    this.go(1)
  }

  getMatchedComponents (to?: RawLocation | Route): Array<any> {
    const route: any = to
      ? to.matched
        ? to
        : this.resolve(to).route
      : this.currentRoute
    if (!route) {
      return []
    }
    return [].concat.apply([], route.matched.map(m => {
      return Object.keys(m.components).map(key => {
        return m.components[key]
      })
    }))
  }

  resolve (
    to: RawLocation,
    current?: Route,
    append?: boolean
  ): {
    location: Location,
    route: Route,
    href: string,
    // for backwards compat
    normalizedTo: Location,
    resolved: Route
  } {
    const location = normalizeLocation(
      to,
      current || this.history.current,
      append,
      this
    )
    const route = this.match(location, current)
    const fullPath = route.redirectedFrom || route.fullPath
    const base = this.history.base
    const href = createHref(base, fullPath, this.mode)
    return {
      location,
      route,
      href,
      // for backwards compat
      normalizedTo: location,
      resolved: route
    }
  }

  addRoutes (routes: Array<RouteConfig>) {
    this.matcher.addRoutes(routes)
    if (this.history.current !== START) {
      this.history.transitionTo(this.history.getCurrentLocation())
    }
  }
}
```

在实例化 VueRouter 的过程中，核心是创建一个路由匹配对象，并且根据 mode 来采取不同的路由方式。



### init方法的实现

这里的init方法与install.js中注册的全局mixin关联最大，是vue组件在create时执行的初始化路由方法，需要重点分析一下。

```javascript
init (app: any /* Vue component instance */) {
  this.apps.push(app)

  app.$once('hook:destroyed', () => {
    const index = this.apps.indexOf(app)
    if (index > -1) this.apps.splice(index, 1)
    if (this.app === app) this.app = this.apps[0] || null
  })

  if (this.app) {
    return
  }

  this.app = app

  const history = this.history

  if (history instanceof HTML5History) {
    history.transitionTo(history.getCurrentLocation())
  } else if (history instanceof HashHistory) {
    const setupHashListener = () => {
      history.setupListeners()
    }
    history.transitionTo(
      history.getCurrentLocation(),
      setupHashListener,
      setupHashListener
    )
  }

  history.listen(route => {
    this.apps.forEach((app) => {
      app._route = route
    })
  })
}
```

源码：[L83](https://github.com/vuejs/vue-router/blob/dev/src/index.js#L83)

这里的app是vue组件的实例，通过 `app.$once('hook:destroyed', () => {}` 声明式地注册组件destroyed生命周期钩子，保证对应组件销毁时组件app实例从`router.apps`上移除。

**保证路由初仅始化一次**：由于init是被全局注册的mixin调用，此处通过this.app是否存在的判断逻辑保证路由初始化仅仅在根组件 `<App />` 上初始化一次，`this.app`最后保存的根据组件实例。

**触发路由变化&开始路由监听**：使用 `history.transitionTo` 分路由模式触发路由变化，使用 `history.listen` 监听路由变化来更新根组件实例 `app._route` 是当前跳转的路由。

## 基础概念——路由匹配器matcher

路由匹配器macther是由create-matcher生成一个对象，其将传入VueRouter类的路由记录进行内部转换，对外提供根据location匹配路由方法——match、注册路由方法——addRoutes。

- [match](https://github.com/vuejs/vue-router/blob/dev/src/create-matcher.js#L26)方法：根据内部的路由映射匹配location对应的路由对象route
- [addRoutes](https://github.com/vuejs/vue-router/blob/dev/src/create-matcher.js#L22)方法：将路由记录添加到matcher实例的路由映射中

### 生成matcher

```javascript
// src/index.js
constructor (options: RouterOptions = {}) {
    ...
    this.matcher = createMatcher(options.routes || [], this)
  	...
}
```

源码：[L42](https://github.com/vuejs/vue-router/blob/dev/src/index.js#L42)

`options.routes`为进行 `new VueRoute` 操作是传入的路由记录

### createMatcher内部

createMatcher来自于`import { createMatcher } from './create-matcher'`, 内部进行路由地址到路由对象的转换、路由记录的映射、路由参数处理等操作

```javascript
// src/create-matcher.js
export function createMatcher (
  routes: Array<RouteConfig>,
  router: VueRouter
): Matcher {
  ...
  function addRoutes (routes) {
    createRouteMap(routes, pathList, pathMap, nameMap)
  }
  function match (
    raw: RawLocation,
    currentRoute?: Route,
    redirectedFrom?: Location
  ): Route {
    ...
  }
  function _createRoute (
    record: ?RouteRecord,
    location: Location,
    redirectedFrom?: Location
  ): Route {
    ...
  }
    
  return {
    match,
    addRoutes
  }
}
```

源码：[L16](https://github.com/vuejs/vue-router/blob/dev/src/create-matcher.js#L16)

createRoute：将外部传入的路由记录转换成统一的route对象，传入**组件实例的$route**就是此处返回的 alias：处理路由别名 nameMap：处理命名路由 **路由参数解析**：解析路由location.params、query参数、hash等，**动态路由匹配正是来自此处**

# 动态路由匹配&嵌套路由

## 动态路由匹配

动态路由匹配指的是可以在路径中设置多段参数，参数将会被设置到 `$route.params` 上，例如：

|           **模式**            |    **匹配路径**     |          **$route.params**           |
| :---------------------------: | :-----------------: | :----------------------------------: |
|        /user/:username        |     /user/evan      |         { username: 'evan' }         |
| /user/:username/post/:post_id | /user/evan/post/123 | { username: 'evan', post_id: '123' } |

参考：[官网例子](https://router.vuejs.org/zh/guide/essentials/dynamic-matching.html#动态路由匹配)

## 嵌套路由

嵌套路由指的是路由可以像组件一样具有嵌套关系，一条路由记录下可以通过 `children` 属性嵌套由多个子路由记录组成的数组，例如：

```javascript
const router = new VueRouter({
  routes: [
    { path: '/user/:id', component: User,
      children: [
        {
          // 当 /user/:id/profile 匹配成功，
          // UserProfile 会被渲染在 User 的 <router-view> 中
          path: 'profile',
          component: UserProfile
        },
        {
          // 当 /user/:id/posts 匹配成功
          // UserPosts 会被渲染在 User 的 <router-view> 中
          path: 'posts',
          component: UserPosts
        }
      ]
    }
  ]
})
```

参考：[官网例子](https://router.vuejs.org/zh/guide/essentials/nested-routes.html)

在项目中只要使用vue-router，几乎不可避免要使用到动态路由匹配和嵌套路由，可见两个功能在vue-router是何等重要，在研究其源码时这两个功能肯定是要研究的，下面将探究上述功能在vue-router是如何实现的。

## 主要实现思路

要实现动态路由匹配主要是要实现路由记录的path属性与实际的路由路径的参数进行匹配，而要实现嵌套路由则需要根据嵌套规则对路由记录解析，这两个都在create-route-map进行实现，实现的思路如下：

![主要实现思路](https://gitee.com/FIF/pic-beg/raw/master/images/javascript/00a39db2-760f-43d5-bc9f-a472c4450710.bf9f8f08.png)

create-route-map中的核心代码如下：

```javascript
export function createRouteMap (
  routes: Array<RouteConfig>,
  oldPathList?: Array<string>,
  oldPathMap?: Dictionary<RouteRecord>,
  oldNameMap?: Dictionary<RouteRecord>
): {
  pathList: Array<string>,
  pathMap: Dictionary<RouteRecord>,
  nameMap: Dictionary<RouteRecord>
} {
 	...
 	routes.forEach(route => {
    addRouteRecord(pathList, pathMap, nameMap, route)
  })
  ...
  /**
   * TODO:
   * 处理路由的优先级循序：将路由记录中的通配符*表示的路由按循序移动到路由记录末尾
   * 采用的哪种排序算法？
   */
  for (let i = 0, l = pathList.length; i < l; i++) {
    if (pathList[i] === '*') {
      pathList.push(pathList.splice(i, 1)[0])
      l--
      i--
    }
  }
  ...
  /**
   * TODO:
   * 路由记录，将路由所有的路由记录映射到pathMap、nameMap中，pathMap：按路径映射，nameMap：按名称映射，pathList所有路由path组成的数组
   * 处理嵌套路由：递归调用此方法，parent表示父级路由
   * 处理路由别名：把路径别名看成是指向同一个组件的路由记录，由此方法处理一遍这个别名组成的路由
   * 处理路由名称：若存在路由名称，则将该路由映射到nameMap中存储
   */
  function addRouteRecord (
    pathList: Array<string>,
    pathMap: Dictionary<RouteRecord>,
    nameMap: Dictionary<RouteRecord>,
    route: RouteConfig,
    parent?: RouteRecord,
    matchAs?: string
  ) {
    ...
  }
  ...
  return {
    pathList,
    pathMap,
    nameMap
  }
}
```

源码：[L7](https://github.com/vuejs/vue-router/blob/dev/src/create-route-map.js#L7)

`createRouteMap`方法主要是遍历路由配置routes，调用 `addRouteRecord` 方法来处理路由，处理完路由后得到 `pathList` `pathMap` `nameMap` ，并将其组成对象并返回。

### 动态路由匹配的实现

在 `addRouteRecord` 方法处理路由的实现中由将 `route.path` 使用path-to-regexp转换成正则表达式， `record` 是处理完成后保存在 `pahtMap` `nameMap` 映射中的值。

```javascript
const record: RouteRecord = {
	...
  regex: compileRouteRegex(normalizedPath, pathToRegexpOptions),
  ...
}
...
/**
 * TODO:
 * 调用path-to-regexp生成路由匹配用的正则
 */
function compileRouteRegex (
  path: string,
  pathToRegexpOptions: PathToRegexpOptions
): RouteRegExp {
  const regex = Regexp(path, [], pathToRegexpOptions)
  if (process.env.NODE_ENV !== 'production') {
    const keys: any = Object.create(null)
    regex.keys.forEach(key => {
      warn(
        !keys[key.name],
        `Duplicate param keys in route with path: "${path}"`
      )
      keys[key.name] = true
    })
  }
  return regex
}
```

源码：[L178](https://github.com/vuejs/vue-router/blob/dev/src/create-route-map.js#L178)

然后在create-matcher提供的match方法中根据 `route.name` 、 `route.path` 进行路由匹配，**匹配的时候回调用上述得到的正则表达式进行路由匹配及参数解析**，从而得到路径或者路由名称匹配的路由以及动态参数。

### 嵌套路由的实现

`addRouteRecord` 方法实现嵌套路由部分的源码如下：

```javascript
export function createRouteMap (
  routes: Array<RouteConfig>,
  oldPathList?: Array<string>,
  oldPathMap?: Dictionary<RouteRecord>,
  oldNameMap?: Dictionary<RouteRecord>
): {
  pathList: Array<string>,
  pathMap: Dictionary<RouteRecord>,
  nameMap: Dictionary<RouteRecord>
} {
 	...
  if (route.children) {
    route.children.forEach(child => {
      const childMatchAs = matchAs
        ? cleanPath(`${matchAs}/${child.path}`)
        : undefined
      addRouteRecord(pathList, pathMap, nameMap, child, record, childMatchAs)
    })
  }
  ...
}
```

源码：[L102](https://blog.lessing.online/program/Take-you-to-analyze-the-source-code-of-Vue-router.html)

路由记录的children表示当前路由下嵌套的路由记录，当其存在时递归处理路由；处理子路由时会拼接完整的路由path放入 `pathMap` `nameMap` 。

故不论是否嵌套路由与否，最后都是进行评级的路由映射，统一路由match方法进行路由匹配。

# 导航守卫机制

导航守卫给给路由使用者传入自定义的控制路由跳转逻辑的钩子方法，通过 `next` 方法串行执行下一个路由的匹配逻辑，根据定义导航守卫的位置不同可以将其分为三类：**全局导航守卫、路由独享守卫、组件内部导航守卫**。

![导航守卫机制](https://blog.lessing.online/assets/img/83b03bac-1783-42ca-aba7-35ec8952d325.327c824b.png)

## 导航守卫的注册

用注册导航守卫方法或导航守卫配置会被注册到执行队列中，在路由跳转时根据根据路由配置映射计算出组件实例的更新、替换、重用等情况，然后在对应组件上遍历执行导航守卫队列。

### 注册全局导航守卫

全局导航守卫分为：全局前置导航守卫、全局解析守卫、全局后置守卫，分别通过 `router.beforeEach` `router.beforeResolve` `router.afterEach` 进行注册。

```javascript
// src/index.js
beforeEach (fn: Function): Function {
  return registerHook(this.beforeHooks, fn)
}

beforeResolve (fn: Function): Function {
  return registerHook(this.resolveHooks, fn)
}

afterEach (fn: Function): Function {
  return registerHook(this.afterHooks, fn)
}
```

源码：[L133](https://github.com/vuejs/vue-router/blob/dev/src/index.js#L133)

注册全局导航守卫是调用 `registerHook` 方法向钩子函数队列中推入钩子函数，同时返回删除钩子函数的方法。

> 这是常见队列入栈出栈用法，vue源码中很常见的一种用法

registerHook方法源码如下：

```javascript
// src/index.js
function registerHook (list: Array<any>, fn: Function): Function {
  list.push(fn)
  return () => {
    const i = list.indexOf(fn)
    if (i > -1) list.splice(i, 1)
  }
}
```

### 注册路由独享守卫

路由独享守卫是以路由配置的形式进行注册，例如：

```javascript
const router = new VueRouter({
  routes: [
    {
      path: '/foo',
      component: Foo,
      beforeEnter: (to, from, next) => {
        // ...
      }
    }
  ]
})
```

### 注册组件内部守卫

组件内部守卫是通过配置组件的导航守卫属性进行注册，例如：

```javascript
const Foo = {
  template: `...`,
  beforeRouteEnter (to, from, next) {
    // 在渲染该组件的对应路由被 confirm 前调用
    // 不！能！获取组件实例 `this`
    // 因为当守卫执行前，组件实例还没被创建
  },
  beforeRouteUpdate (to, from, next) {
    // 在当前路由改变，但是该组件被复用时调用
    // 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候，
    // 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。
    // 可以访问组件实例 `this`
  },
  beforeRouteLeave (to, from, next) {
    // 导航离开该组件的对应路由时调用
    // 可以访问组件实例 `this`
  }
}
```

## 导航守卫的解析流程

将上面在全局注册、路由配置注册、组件内部注册的导航守卫解析出来，按照**导航钩子解析顺序**推进队列中

```javascript
const queue: Array<?NavigationGuard> = [].concat(
  // in-component leave guards
  extractLeaveGuards(deactivated),  // 失效组件的beforeRouterLeave
  // global before hooks
  this.router.beforeHooks,					// 全局的前置钩子beforeEach
  // in-component update hooks
  extractUpdateHooks(updated),			// 重用的组件beforeRouteUpdate
  // in-config enter guards
  activated.map(m => m.beforeEnter),// 路由配置的beforeRouteEnter
  // async components
  resolveAsyncComponents(activated) // 路由配置中异步组件的加载解析
)
```

源码：[L133](https://github.com/vuejs/vue-router/blob/dev/src/history/base.js#L133)

**导航钩子的解析流程** ![解析流程](https://gitee.com/FIF/pic-beg/raw/master/images/javascript/3cf41362-5479-4926-afa5-eb867f07fddc.a8a9ffba.png)

**导航钩子解析对应的源码**

```javascript
// 执行前置守卫
runQueue(queue, iterator, () => {
  const postEnterCbs = []
  const isValid = () => this.current === route
  const enterGuards = extractEnterGuards(activated, postEnterCbs, isValid)
  const queue = enterGuards.concat(this.router.resolveHooks)
  // 执行解析守卫
  runQueue(queue, iterator, () => {
    if (this.pending !== route) {
      return abort()
    }
    this.pending = null
    onComplete(route)
    if (this.router.app) {
      this.router.app.$nextTick(() => {
        // 执行后置守卫
        postEnterCbs.forEach(cb => {
          cb()
        })
      })
    }
  })
})
```

源码：[L179](https://github.com/vuejs/vue-router/blob/dev/src/history/base.js#L179)

# 路由懒加载

路由懒加载是以路由为基础单位对页面代码进行分包，在匹配到对应路由时候在异步下载对应路由组件的代码，以vue-cli新建的项目可以直接使用[webpack 的 code-splitting 功能](https://webpack.js.org/guides/code-splitting/)，一个结合[vue异步组件](https://cn.vuejs.org/v2/guide/components-dynamic-async.html#异步组件)+ES新语法的路由懒加载的例子如下：

```javascript
vue VueRouter({
	routes: [
    {
     	path: '/foot',
      component: () => import('./my-async-component')
    }
  ]
})
```

异步组件的加载需要关注其加载状态，在vue-router中的异步组件的加载状态只有loading、error等，而在vue-router是重新实现的组件懒加载实现了更细致的组件加载状态控制、路由解析控制。

vue-router的异步组件解析在[导航守卫队列的解析流程](https://blog.lessing.online/program/Take-you-to-analyze-the-source-code-of-Vue-router.html#5Pm5h)里面，其中重点的解析异步组件的方法源码如下：

```javascript
// util/resolve-components.js
/**
 * TODO:
 * 异步路由解析：重写异步组件的resolve、reject方法，添加了组件加载状态控制、路由解析控制；对异步组件的传统写法及promise写进行兼容
 */
export function resolveAsyncComponents (matched: Array<RouteRecord>): Function {
  return (to, from, next) => {
    let hasAsync = false
    let pending = 0
    let error = null

    flatMapComponents(matched, (def, _, match, key) => {
      if (typeof def === 'function' && def.cid === undefined) {
        hasAsync = true
        pending++
        // 重写vue异步组件的resolve和reject方法
        const resolve = once(resolvedDef => {
          if (isESModule(resolvedDef)) {
            resolvedDef = resolvedDef.default
          }
          // save resolved on async factory in case it's used elsewhere
          def.resolved = typeof resolvedDef === 'function'
            ? resolvedDef
            : _Vue.extend(resolvedDef)
          match.components[key] = resolvedDef
          pending--
          if (pending <= 0) {
            next()
          }
        })

        const reject = once(reason => {
          const msg = `Failed to resolve async component ${key}: ${reason}`
          process.env.NODE_ENV !== 'production' && warn(false, msg)
          if (!error) {
            error = isError(reason)
              ? reason
              : new Error(msg)
            next(error)
          }
        })

        let res
        try {
          res = def(resolve, reject)
        } catch (e) {
          reject(e)
        }
        // 兼容异步组件的promise写法
        if (res) {
          if (typeof res.then === 'function') {
            res.then(resolve, reject)
          } else {
            // new syntax in Vue 2.3
            const comp = res.component
            if (comp && typeof comp.then === 'function') {
              comp.then(resolve, reject)
            }
          }
        }
      }
    })
  }
}
```

源码：[L6](https://github.com/vuejs/vue-router/blob/dev/src/util/resolve-components.js#L6)

重写了vue异步组件加载的resolve和reject方法来实现对路由解析是否进入下一个匹配的控制，加入了路由匹配的组件解析失败的异常处理，同时还对异步组件的promise写法也进行了兼容。

# router-view组件

router-view是vue-router提供的两个核心组件之一，它是一个函数式组件不存在自己的组件实例，只负责调用父组件上存储的 `keepAlive` `$route.match` 等相关的属性/方法来控制路由对应的组件的渲染情况。

router-view组件可以嵌套来配合实现嵌套路由，其自身所在的页面位置最终是其匹配上的路由组件所挂载的位置。

其源码render部分的核心源码如下：

```javascript
render (_, { props, children, parent, data }) {
  // 标识当前组件是router-view
  data.routerView = true
  const h = parent.$createElement
  const name = props.name
  const route = parent.$route
  const cache = parent._routerViewCache || (parent._routerViewCache = {})
  
  let depth = 0
  let inactive = false
  // 由router-view组件向上遍历直到跟组件，遇到其他的router-view组件则路由深度+1
  // vnodeData.keepAlivepj
  while (parent && parent._routerRoot !== parent) {
    const vnodeData = parent.$vnode ? parent.$vnode.data : {}
    if (vnodeData.routerView) {
      depth++
    }
    if (vnodeData.keepAlive && parent._directInactive && parent._inactive) {
      inactive = true
    }
    parent = parent.$parent
  }
  data.routerViewDepth = depth

	// 启用缓存时
  if (inactive) {
    const cachedData = cache[name]
    const cachedComponent = cachedData && cachedData.component
    if (cachedComponent) {
      if (cachedData.configProps) {
        fillPropsinData(cachedComponent, data, cachedData.route, cachedData.configProps)
      }
      return h(cachedComponent, data, children)
    } else {
      return h()
    }
  }

  const matched = route.matched[depth]
  const component = matched && matched.components[name]
  
  if (!matched || !component) {
    cache[name] = null
    return h()
  }

  cache[name] = { component }

  // 往父组件注册registerRouteInstance方法
  data.registerRouteInstance = (vm, val) => {
    // val could be undefined for unregistration
    const current = matched.instances[name]
    if (
      (val && current !== vm) ||
      (!val && current === vm)
    ) {
      matched.instances[name] = val
    }
  }
	...
  return h(component, data, children)
}
```

源码：[L13](https://github.com/vuejs/vue-router/blob/dev/src/components/view.js#L13)

## 路由缓存的判断

parent表示router-view组件的直接父级组件实例，从当router-view往外层组件遍历，遇到router-view则说明存在嵌套路由，路由深度+1，同时若满足条件则表示路由启用了缓存；

即如下结构会使用路由缓存

```html
<keep-alive>
  <router-view></router-view>
</keep-alive>
```

缓存的路由组件实例存在父级组件实例上，若启用了路由缓存则用父级缓存的已匹配的路由组件进行渲染，无则用 `$route.match` 来匹配 `matcher` 中匹配上的路由进行渲染。

**`parent._inactive`**由vue核心模块的`observer/scheduler`调度器更新 `**parent._directInactive**`由vue核心模块的`instance/lifecycle`更新，两者都是用于标识当前组件是否处于active状态，具体区别可参考这个issue[#1212](https://github.com/vuejs/vue-router/issues/1212)。

# router-link组件

router-link是vue-router提供的两个核心组件之一，它是一个普通组件，内部取消了`a标签`的默认跳转行为，并控制了组件与`control`、`meta`等按键同时存在的兼容性问题，提供了当前激活路由匹配时的样式类；

通过 `to` 来决定点击事件跳转的目标路由，通过 `append` `replace`等属性改变默认路由跳转的行为。

## 通过slot分发内容

```javascript
const scopedSlot =
  !this.$scopedSlots.$hasNormal &&
  this.$scopedSlots.default &&
  this.$scopedSlots.default({
    href,
    route,
    navigate: handler,
    isActive: classes[activeClass],
    isExactActive: classes[exactActiveClass]
  })

if (scopedSlot) {
  if (scopedSlot.length === 1) {
    return scopedSlot[0]
  } else if (scopedSlot.length > 1 || !scopedSlot.length) {
    if (process.env.NODE_ENV !== 'production') {
      warn(
        false,
        `RouterLink with to="${
          this.to
        }" is trying to use a scoped slot but it didn't provide exactly one child. Wrapping the content with a span element.`
      )
    }
    return scopedSlot.length === 0 ? h() : h('span', {}, scopedSlot)
  }
}
```

源码：[L91](https://github.com/vuejs/vue-router/blob/dev/src/components/link.js#L91)

## 统一处理点击事件兼容性

```javascript
function guardEvent (e) {
  // don't redirect with control keys
  if (e.metaKey || e.altKey || e.ctrlKey || e.shiftKey) return
  // don't redirect when preventDefault called
  if (e.defaultPrevented) return
  // don't redirect on right click
  if (e.button !== undefined && e.button !== 0) return
  // don't redirect if `target="_blank"`
  if (e.currentTarget && e.currentTarget.getAttribute) {
    const target = e.currentTarget.getAttribute('target')
    if (/\b_blank\b/i.test(target)) return
  }
  // this may be a Weex event which doesn't have this method
  if (e.preventDefault) {
    e.preventDefault()
  }
  return true
}
```

源码：[L158](https://github.com/vuejs/vue-router/blob/dev/src/components/link.js#L158)

## 查找渲染的a标签

递归查找children中的a标签作为组件默认插槽的默认替换内容

```javascript
function findAnchor (children) {
  if (children) {
    let child
    for (let i = 0; i < children.length; i++) {
      child = children[i]
      if (child.tag === 'a') {
        return child
      }
      if (child.children && (child = findAnchor(child.children))) {
        return child
      }
    }
  }
}
```

源码：[L177](https://github.com/vuejs/vue-router/blob/dev/src/components/link.js#L177)

### HashHistory

• hash虽然出现在url中，但不会被包括在http请求中，它是用来指导浏览器动作的，对服务器端没影响，因此，改变hash不会重新加载页面。

• 可以为hash的改变添加监听事件：

```js
window.addEventListener("hashchange",funcRef,false)
```
• 每一次改变hash(window.location.hash)，都会在浏览器访问历史中增加一个记录。


```js
export class HashHistory extends History {
  constructor (router: Router, base: ?string, fallback: boolean) {
    super(router, base)
    // check history fallback deeplinking
    // 如果是从history模式降级来的，需要做降级检查
    if (fallback && checkFallback(this.base)) {
    // 如果降级且做了降级处理，则返回
      return
    }
    ensureSlash()
  }
  .......
```

```js
function checkFallback (base) {
  const location = getLocation(base)
  // 得到除去base的真正的 location 值
  if (!/^\/#/.test(location)) {
  // 如果此时地址不是以 /# 开头的
  // 需要做一次降级处理，降为 hash 模式下应有的 /# 开头
    window.location.replace(
      cleanPath(base + '/#' + location)
    )
    return true
  }
}

function ensureSlash (): boolean {
// 得到 hash 值
  const path = getHash()
  if (path.charAt(0) === '/') {
   // 如果是以 / 开头的，直接返回即可
    return true
  }
  // 不是的话，需要手动保证一次 替换 hash 值
  replaceHash('/' + path)
  return false
}

export function getHash (): string {
  // We can't use window.location.hash here because it's not
  // consistent across browsers - Firefox will pre-decode it!
  // 因为兼容性的问题，这里没有直接使用 window.location.hash
  // 因为 Firefox decode hash 值
  const href = window.location.href
  const index = href.indexOf('#')
  return index === -1 ? '' : decodeURI(href.slice(index + 1))
}
// 得到hash之前的url地址
function getUrl (path) {
  const href = window.location.href
  const i = href.indexOf('#')
  const base = i >= 0 ? href.slice(0, i) : href
  return `${base}#${path}`
}
// 添加一个hash
function pushHash (path) {
  if (supportsPushState) {
    pushState(getUrl(path))
  } else {
    window.location.hash = path
  }
}
// 替代hash
function replaceHash (path) {
  if (supportsPushState) {
    replaceState(getUrl(path))
  } else {
    window.location.replace(getUrl(path))
  }
}
```
hash的改变会自动添加到浏览器的访问历史记录中。 那么视图的更新是怎么实现的呢，看下 transitionTo()方法：

```js
transitionTo (location: RawLocation, onComplete?: Function, onAbort?: Function) {
    const route = this.router.match(location, this.current) //找到匹配路由
    this.confirmTransition(route, () => { //确认是否转化
      this.updateRoute(route) //更新route
      onComplete && onComplete(route)
      this.ensureURL()

      // fire ready cbs once
      if (!this.ready) {
        this.ready = true
        this.readyCbs.forEach(cb => { cb(route) })
      }
    }, err => {
      if (onAbort) {
        onAbort(err)
      }
      if (err && !this.ready) {
        this.ready = true
        this.readyErrorCbs.forEach(cb => { cb(err) })
      }
    })
  }
  
//更新路由
updateRoute (route: Route) {
    const prev = this.current // 跳转前路由
    this.current = route // 装备跳转路由
    this.cb && this.cb(route) // 回调函数，这一步很重要，这个回调函数在index文件中注册，会更新被劫持的数据 _router
    this.router.afterHooks.forEach(hook => {
      hook && hook(route, prev)
    })
  }
}
```

#### pushState 

```js
export function pushState (url?: string, replace?: boolean) {
  saveScrollPosition()
  // try...catch the pushState call to get around Safari
  // DOM Exception 18 where it limits to 100 pushState calls
  // 加了 try...catch 是因为 Safari 有调用 pushState 100 次限制
  // 一旦达到就会抛出 DOM Exception 18 错误
  const history = window.history
  try {
    if (replace) {
    // replace 的话 key 还是当前的 key 没必要生成新的
      history.replaceState({ key: _key }, '', url)
    } else {
    // 重新生成 key
      _key = genKey()
       // 带入新的 key 值
      history.pushState({ key: _key }, '', url)
    }
  } catch (e) {
  // 达到限制了 则重新指定新的地址
    window.location[replace ? 'replace' : 'assign'](url)
  }
}
```
#### replaceState

```js
// 直接调用 pushState 传入 replace 为 true
export function replaceState (url?: string) {
  pushState(url, true)
}
```
pushState和replaceState两种方法的共同特点：当调用他们修改浏览器历史栈后，虽然当前url改变了，但浏览器不会立即发送请求该url，这就为单页应用前端路由，更新视图但不重新请求页面提供了基础。
#### supportsPushState

```js
export const supportsPushState = inBrowser && (function () {
  const ua = window.navigator.userAgent

  if (
    (ua.indexOf('Android 2.') !== -1 || ua.indexOf('Android 4.0') !== -1) &&
    ua.indexOf('Mobile Safari') !== -1 &&
    ua.indexOf('Chrome') === -1 &&
    ua.indexOf('Windows Phone') === -1
  ) {
    return false
  }

  return window.history && 'pushState' in window.history
})()
```
其实所谓响应式属性，即当_route值改变时，会自动调用Vue实例的render()方法，更新视图。
$router.push()-->HashHistory.push()-->History.transitionTo()-->History.updateRoute()-->{app._route=route}-->vm.render()

#### 监听地址栏
在浏览器中，用户可以直接在浏览器地址栏中输入改变路由，因此还需要监听浏览器地址栏中路由的变化 ，并具有与通过代码调用相同的响应行为，在HashHistory中这一功能通过setupListeners监听hashchange实现：

```js
setupListeners () {
    window.addEventListener('hashchange', () => {
        if (!ensureSlash()) {
            return
        }
        this.transitionTo(getHash(), route => {
            replaceHash(route.fullPath)
        })
    })
}
```
### HTML5History

History interface是浏览器历史记录栈提供的接口，通过back(),forward(),go()等方法，我们可以读取浏览器历史记录栈的信息，进行各种跳转操作。

```js
export class HTML5History extends History {
  constructor (router: Router, base: ?string) {
    super(router, base)

    const expectScroll = router.options.scrollBehavior //指回滚方式
    const supportsScroll = supportsPushState && expectScroll

    if (supportsScroll) {
      setupScroll()
    }

    const initLocation = getLocation(this.base)
    //监控popstate事件
    window.addEventListener('popstate', e => {
      const current = this.current

      // Avoiding first `popstate` event dispatched in some browsers but first
      // history route not updated since async guard at the same time.
      // 避免在某些浏览器中首次发出“popstate”事件
      // 由于同一时间异步监听，history路由没有同时更新。
      const location = getLocation(this.base)
      if (this.current === START && location === initLocation) {
        return
      }

      this.transitionTo(location, route => {
        if (supportsScroll) {
          handleScroll(router, route, current, true)
        }
      })
    })
  }
```
hash模式仅改变hash部分的内容，而hash部分是不会包含在http请求中的(hash带#)：

http://oursite.com/#/user/id //如请求，只会发送http://oursite.com/

所以hash模式下遇到根据url请求页面不会有问题

而history模式则将url修改的就和正常请求后端的url一样(history不带#)

http://oursite.com/user/id

如果这种向后端发送请求的话，后端没有配置对应/user/id的get路由处理,会返回404错误。

官方推荐的解决办法是在服务端增加一个覆盖所有情况的候选资源：如果 URL 匹配不到任何静态资源，则应该返回同一个 index.html 页面，这个页面就是你 app 依赖的页面。同时这么做以后，服务器就不再返回 404 错误页面，因为对于所有路径都会返回 index.html 文件。为了避免这种情况，在 Vue 应用里面覆盖所有的路由情况，然后在给出一个 404 页面。或者，如果是用 Node.js 作后台，可以使用服务端的路由来匹配 URL，当没有匹配到路由的时候返回 404，从而实现 fallback。

#### 两种模式比较
一般的需求场景中，hash模式与history模式是差不多的，根据MDN的介绍，调用history.pushState()相比于直接修改hash主要有以下优势：

• pushState设置的新url可以是与当前url同源的任意url,而hash只可修改#后面的部分，故只可设置与当前同文档的url

• pushState设置的新url可以与当前url一模一样，这样也会把记录添加到栈中，而hash设置的新值必须与原来不一样才会触发记录添加到栈中

• pushState通过stateObject可以添加任意类型的数据记录中，而hash只可添加短字符串
pushState可额外设置title属性供后续使用

### AbstractHistory
'abstract'模式，不涉及和浏览器地址的相关记录，流程跟'HashHistory'是一样的，其原理是通过数组模拟浏览器历史记录栈的功能


```js
//abstract.js实现，这里通过栈的数据结构来模拟路由路径
export class AbstractHistory extends History {
  index: number;
  stack: Array<Route>;

  constructor (router: Router, base: ?string) {
    super(router, base)
    this.stack = []
    this.index = -1
  }
  
  // 对于 go 的模拟
  go (n: number) {
    // 新的历史记录位置
    const targetIndex = this.index + n
    // 小于或大于超出则返回
    if (targetIndex < 0 || targetIndex >= this.stack.length) {
      return
    }
    // 取得新的 route 对象
    // 因为是和浏览器无关的 这里得到的一定是已经访问过的
    const route = this.stack[targetIndex]
    // 所以这里直接调用 confirmTransition 了
    // 而不是调用 transitionTo 还要走一遍 match 逻辑
    this.confirmTransition(route, () => {
      this.index = targetIndex
      this.updateRoute(route)
    })
  }
```

```js
 //确认是否转化路由
  confirmTransition (route: Route, onComplete: Function, onAbort?: Function) {
    const current = this.current
    const abort = err => {
      if (isError(err)) {
        if (this.errorCbs.length) {
          this.errorCbs.forEach(cb => { cb(err) })
        } else {
          warn(false, 'uncaught error during route navigation:')
          console.error(err)
        }
      }
      onAbort && onAbort(err)
    }
    //判断如果前后是同一个路由，不进行操作
    if (
      isSameRoute(route, current) &&
      route.matched.length === current.matched.length
    ) {
      this.ensureURL()
      return abort()
    }
    //下面是各类钩子函数的处理
    //*********************
    })
  }
```



## 拓展阅读

- [VueRouter 源码深度解析](https://juejin.cn/post/6844903647378145294)
- [带你全面分析vue-router源码（万字长文）](https://juejin.cn/post/6844904064367460366)
- [技术揭秘-vue-router源码](https://ustbhuangyi.github.io/vue-analysis/v2/vue-router/)









