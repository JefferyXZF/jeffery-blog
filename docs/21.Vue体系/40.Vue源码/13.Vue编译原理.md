---
title: Vue 编译原理
date: 2020-04-17 20:45:35
permalink: /pages/sswlwew331ef7
author: jeffery
categories: 
  - Vue 源码
tags: 
  - Vue 源码
  - Vue
---

# Vue 编译原理

阅读源码的注释仓库[github](https://github.com/JefferyXZF/vue/tree/dev-doc)
## 概念

平时使用模板时，可以在模板中使用变量、表达式或者指令等，如 `v-on`、`v-if`，这些语法在 `html` 中是不存在的，那 `vue` 中为什么可以实现？这就归功于模板编译功能。

`Vue` 内置的编译器或 `vue-loader` 插件带有编译功能，它把`<template></template>`标签中类似于原生`HTML`的内容进行编译，本质上通过正则匹配，生成渲染函数，也就是`render`函数，而`render`函数会将模板内容生成对应的`VNode`，而`VNode`再经过`patch`过程创建真实的`DOM`节点并插入到视图中， 最终完成视图的渲染更新。



![](https://gitee.com/FIF/pic-beg/raw/master/images/vue/1620553289128-templatef1b4afd6821eaa43f866765b702c6675.png)

从图中我们也可以看到，模板编译过程就是把用户写的模板经过一系列处理最终生成`render`函数的过程。

## 模板渲染过程

![](https://gitee.com/FIF/pic-beg/raw/master/images/vue/vuetemplate.jpg)





从执行流程图中我们可以知道，在 `$mount` 挂载会执行 `compileToFunctions` 方法，`compile` 进行模板编译,  编译过程主要做了三件事：

- `parse` :  通过正则匹配解析模板字符串生成 `ast`，它是一个抽象语法树，[ast在线演示工具](https://astexplorer.net/)
- `optimize`: 优化语法树， 打上静态节点或根静态节点标识
- `generate`:  `ast` 转化为可执行代码

在 `Vue` 源码中实现编译过程没有这么直观，为了兼容不同的编译平台，它使用了函数柯里化的技巧，有点绕，不过只要记住上面是编译的核心方法，接下来分析它的源码。

编译结果可以借助这个在线工具 [模版在线编译工具](https://template-explorer.vuejs.org)

 

## 编译入口



当我们使用` Runtime + Compiler` 的 Vue.js，它的入口是 `src/platforms/web/entry-runtime-with-compiler.js`，看一下它对 `$mount` 函数的定义：

```js
// 缓存 $mount
const mount = Vue.prototype.$mount
// 重新定义 $mount，实现编译功能
Vue.prototype.$mount = function (
  el?: string | Element,
  hydrating?: boolean
): Component {
  //... 模板编译
  const { render, staticRenderFns } = compileToFunctions(template, {
        shouldDecodeNewlines,
        shouldDecodeNewlinesForHref,
        delimiters: options.delimiters,
        comments: options.comments
      }, this)
      options.render = render
      options.staticRenderFns = staticRenderFns
  //...
  return mount.call(this, el, hydrating)
}
```

`compileToFunctions` 方法是一个编译器，把模板 `template` 编译生成 `render` 以及 `staticRenderFns`，它的定义在 `src/platforms/web/compiler/index.js` 中：

```js
import { baseOptions } from './options'
import { createCompiler } from 'compiler/index'

const { compile, compileToFunctions } = createCompiler(baseOptions)

export { compile, compileToFunctions }
```

可以看到 `compileToFunctions` 方法实际上是 `createCompiler` 方法的返回值，该方法接收一个编译配置参数，接下来我们来看一下 `createCompiler` 方法的定义，在 `src/compiler/index.js` 中：

```js
export const createCompiler = createCompilerCreator(function baseCompile (
  template: string,
  options: CompilerOptions
): CompiledResult {
  // 解析器 template => ast
  const ast = parse(template.trim(), options)
  // 优化器，打上静态节点或根静态节点标识
  if (options.optimize !== false) {
    optimize(ast, options)
  }
  // 代码生成器， ast => render 函数
  const code = generate(ast, options)
  return {
    ast,
    render: code.render,
    staticRenderFns: code.staticRenderFns
  }
})
```

`createCompiler` 方法实际上是通过调用 `createCompilerCreator` 方法返回的，该方法传入的参数是一个函数，真正的编译过程都在这个 `baseCompile` 函数里执行，那么 `createCompilerCreator` 又是什么呢，它的定义在 `src/compiler/create-compiler.js` 中：

```js
export function createCompilerCreator (baseCompile: Function): Function {
  return function createCompiler (baseOptions: CompilerOptions) {
    function compile (
      template: string,
      options?: CompilerOptions
    ): CompiledResult {
      // ... 执行编译
      const compiled = baseCompile(template, finalOptions)
      // ...
      return compiled
    }

    return {
      compile,
      compileToFunctions: createCompileToFunctionFn(compile)
    }
  }
}
```

该方法返回了一个 `createCompiler` 的函数，它接收一个 `baseOptions` 的参数，返回的是一个对象，包括 `compile` 方法属性和 `compileToFunctions` 属性，这个 `compileToFunctions` 对应的就是 `$mount` 函数调用的 `compileToFunctions` 方法，它是调用 `createCompileToFunctionFn` 方法的返回值，我们接下来看一下 `createCompileToFunctionFn` 方法，它的定义在 `src/compiler/to-function/js` 中：

```js
export function createCompileToFunctionFn (compile: Function): Function {
  const cache = Object.create(null)

  return function compileToFunctions (
    template: string,
    options?: CompilerOptions,
    vm?: Component
  ): CompiledFunctionResult {
    // ...

    // check cache 缓存编译结果
    const key = options.delimiters
      ? String(options.delimiters) + template
      : template
    if (cache[key]) {
      return cache[key]
    }

    // compile 编译
    const compiled = compile(template, options)

    // 实例化为可执行函数
    res.render = createFunction(compiled.render, fnGenErrors)
    res.staticRenderFns = compiled.staticRenderFns.map(code => {
      return createFunction(code, fnGenErrors)
    })

    return (cache[key] = res)
  }
}
```

`compileToFunctions` 的最终定义，它接收 3 个参数、编译模板 `template`，编译配置 `options` 和 Vue 实例 `vm`。这也是我们在`$mount` 真正执行的方法，它核心的编译过程就一行代码：

```js
const compiled = compile(template, options)
```

接下来我们捋一下 `compileToFunctions` 执行流程：

- `$mount` 方法 -》 执行 `compileToFunctions` 
- `compileToFunctions`  -》 执行 `compile` ，它是一个函数参数
- `compile` -》执行 `baseCompile`
- `baseCompile` -》 执行 `parse, optimize, generate` -》返回 `render`

所以经过层层方法执行，最终编译结果是 `render` 函数

## 具体流程

从上面可以看出执行流程比较绕，我们从新梳理一下。

编译过程将字符串模板解析成抽象语法树`AST`后，`AST` 来生成`render`函数。其具体流程可大致分为三个阶段：

- 模板解析阶段：将模板字符串用正则等方式解析成抽象语法树`AST`——解析器——源码路径：`src/compiler/parser/index.js`
- 优化阶段：遍历`AST`，找出其中的静态节点，并打上标记；——优化器——源码路径：`src/compiler/optimizer.js`;
- 代码生成阶段：将`AST`转换成渲染函数； 这三个阶段在源码中分别对应三个模块——代码生成器——源码路径：`src/compiler/codegen/index.js`

```js
// 源码位置: /src/complier/index.js
export const createCompiler = createCompilerCreator(function baseCompile (
  template: string,
  options: CompilerOptions
): CompiledResult {
  // 模板解析阶段：用正则等方式解析 template 模板中的指令、class、style等数据，形成AST
  const ast = parse(template.trim(), options)
  if (options.optimize !== false) {
    // 优化阶段：遍历AST，找出其中的静态节点，并打上标记；
    optimize(ast, options)
  }
  // 代码生成阶段：将AST转换成渲染函数；
  const code = generate(ast, options)
  return {
    ast,
    render: code.render,
    staticRenderFns: code.staticRenderFns
  }
})

```

可以看到 `baseCompile` 的代码非常的简短主要核心代码。

- **const ast =parse(template.trim(), options)**:`parse` 会用正则等方式解析 `template` 模板中的指令、`class`、`style`等数据，形成`AST`。
- **optimize(ast, options)**: `optimize` 的主要作用是标记静态节点，这是 `Vue` 在编译过程中的一处优化，当在进行`patch` 的过程中， `DOM-Diff` 算法会直接跳过静态节点，从而减少了比较的过程，优化了 `patch` 的性能。
- **const code =generate(ast, options)**: 将 `AST` 转化成 `render`函数字符串的过程，得到结果是 `render`函数 的字符串以及 `staticRenderFns` 字符串。 最终 `baseCompile` 的返回值

```js
{
     ast: ast,
     render: code.render,
     staticRenderFns: code.staticRenderFns
 }
```

最终返回了抽象语法树( ast )，渲染函数( render )，静态渲染函数( staticRenderFns )，且`render` 的值为`code.render`，`staticRenderFns` 的值为`code.staticRenderFns`，也就是说通过 `generate`处理 `ast`之后得到的返回值 `code` 是一个对象。

下面再给出模板编译内部具体流程图，便于理解。流程图如下：

![综述 - 图3](https://gitee.com/FIF/pic-beg/raw/master/images/vue/1620557987109-9b32f7dc778367c251479fe8fb9b07f7.png)



## parse 解析器

`parse` 解析器将 `template` 模版通过正则匹配转化为 `ast` 抽象语法树，解析器除了解析 `html` 标签，还会解析文本和过滤器，所以解析器包含 `html` 解析器，文本解析器和过滤器解析器。

在整个模版解析过程中，`HTML` 解析器是主线，先用 `HTML` 解析器进行解析整个模板，在解析过程中如果碰到文本内容，那就调用文本解析器来解析文本，如果碰到文本中包含过滤器那就调用过滤器解析器来解析。

### parse 源码分析

解析器的源码位于`/src/complier/parser`文件夹下，其主线代码如下：

```js
// 代码位置：/src/complier/parser/index.js
export function parse (
  template: string,
  options: CompilerOptions
): ASTElement | void {
  getFnsAndConfigFromOptions(options)

  parseHTML(template, {
    // options ...
    // 解析开始标签，如：<div id="app">
    start (tag, attrs, unary) {
      let element = createASTElement(tag, attrs)
      processElement(element)
      treeManagement()
    },
    // 解析结束标签，如：</div>
    end () {
      treeManagement()
      closeElement()
    },
    // 解析文本字符串
    chars (text: string) {
      handleText()
      createChildrenASTOfText()
    },
    // 解析注释节点，如：<!-- 注释 -->
    comment (text: string) {
      createChildrenASTOfComment()
    }
  })
  return astRootElement
}
```

从上面代码中可以看到，`parse` 函数就是解析器的主函数，在`parse` 函数内调用了`parseHTML` 函数对模板字符串进行解析，在`parseHTML` 函数解析模板字符串的过程中，如果遇到文本信息，就会调用文本解析器`parseText`函数进行文本解析；如果遇到文本中包含过滤器，就会调用过滤器解析器`parseFilters`函数进行解析。

`parse` 还包含几个配置函数 `start`, `end`, `chars`, `comment` 分别是处理开始标签、结束标签、文本、和注释文本

### parseHTML （HTML解析器）

对于 `template` 模板的解析主要是通过 `parseHTML` 函数，它的定义在 `src/compiler/parser/html-parser` 中：

```js
export function parseHTML (html, options) {
  let lastTag
  while (html) {
    if (!lastTag || !isPlainTextElement(lastTag)){
      let textEnd = html.indexOf('<')
      if (textEnd === 0) {
         if(matchComment) {
           advance(commentLength)
           continue
         }
         if(matchDoctype) {
           advance(doctypeLength)
           continue
         }
         if(matchEndTag) {
           advance(endTagLength)
           parseEndTag()
           continue
         }
         if(matchStartTag) {
           parseStartTag()
           handleStartTag()
           continue
         }
      }
      handleText()
      advance(textLength)
    } else {
       handlePlainTextElement()
       parseEndTag()
    }
  }
}
```

上面整体逻辑，循环解析 `template` ，用正则做各种匹配，对于不同情况分别进行不同的处理，直到整个 template 被解析完毕。 在匹配的过程中会利用 `advance` 函数不断前进整个模板字符串，直到字符串末尾。



### 解析流程图

![img](https://gitee.com/FIF/pic-beg/raw/master/images/vue/parse-20210509231627945.png)



## optimize 优化器

`parse` 优化阶段主要做了两件事：

- 在`AST`中找出所有静态节点并打上标记；
- 在`AST`中找出所有静态根节点并打上标记； 优化阶段的源码位于`src/compiler/optimizer.js`中，如下：

```js
export function optimize (root: ?ASTElement, options: CompilerOptions) {
  if (!root) return
  isStaticKey = genStaticKeysCached(options.staticKeys || '')
  isPlatformReservedTag = options.isReservedTag || no
  // 标记静态节点
  markStatic(root)
  // 标记静态根节点
  markStaticRoots(root, false)
}
```

### 标记静态节点

从`AST`中找出所有静态节点，从根节点开始，先标记根节点是否为静态节点，然后看根节点如果是元素节点，那么就去向下递归它的子节点，子节点如果还有子节点那就继续向下递归，直到标记完所有节点。代码如下：

```js
function markStatic (node: ASTNode) {
  node.static = isStatic(node)
  if (node.type === 1) {
    if (
      !isPlatformReservedTag(node.tag) &&
      node.tag !== 'slot' &&
      node.attrsMap['inline-template'] == null
    ) {
      return
    }
    for (let i = 0, l = node.children.length; i < l; i++) {
      const child = node.children[i]
      markStatic(child)
      if (!child.static) {
        node.static = false
      }
    }
    if (node.ifConditions) {
      for (let i = 1, l = node.ifConditions.length; i < l; i++) {
        const block = node.ifConditions[i].block
        markStatic(block)
        if (!block.static) {
          node.static = false
        }
      }
    }
  }
}
```

在上面代码中，首先调用`isStatic`函数标记节点是否为静态节点，该函数若返回`true`表示该节点是静态节点，若返回`false`表示该节点不是静态节点，函数实现如下：

```js
function isStatic (node: ASTNode): boolean {
  if (node.type === 2) { // 包含变量的动态文本节点
    return false
  }
  if (node.type === 3) { // 不包含变量的纯文本节点
    return true
  }
  return !!(node.pre || (
    !node.hasBindings && // no dynamic bindings
    !node.if && !node.for && // not v-if or v-for or v-else
    !isBuiltInTag(node.tag) && // not a built-in
    isPlatformReservedTag(node.tag) && // not a component
    !isDirectChildOfTemplateFor(node) &&
    Object.keys(node).every(isStaticKey)
  ))
}
```

该函数的实现过程其实也说明了如何判断一个节点是否为静态节点。还记得在`HTML`解析器在调用钩子函数创建`AST`节点时会根据节点类型的不同为节点加上不同的`type`属性，用`type`属性来标记`AST`节点的节点类型，其对应关系如下：

| type取值 | 对应的AST节点类型      |
| :------- | :--------------------- |
| 1        | 元素节点               |
| 2        | 包含变量的动态文本节点 |
| 3        | 不包含变量的纯文本节点 |

所以在判断一个节点是否为静态节点时首先会根据`type`值判断节点类型，如果`type`值为2，那么该节点是包含变量的动态文本节点，它就肯定不是静态节点。

如果元素节点是静态节点，那就必须满足以下几点要求：

- 如果节点使用了`v-pre`指令，那就断定它是静态节点；

- 如果节点没有使用

  ```
  v-pre
  ```

  指令，那它要成为静态节点必须满足：

  - 不能使用动态绑定语法，即标签上不能有`v-`、`@`、`:`开头的属性；
  - 不能使用`v-if`、`v-else`、`v-for`指令；
  - 不能是内置组件，即标签名不能是`slot`和`component`；
  - 标签名必须是平台保留标签，即不能是组件；
  - 当前节点的父节点不能是带有 `v-for` 的 `template` 标签；
  - 节点的所有属性的 `key` 都必须是静态节点才有的 `key`，注：静态节点的`key`是有限的，它只能是`type`,`tag`,`attrsList`,`attrsMap`,`plain`,`parent`,`children`,`attrs`之一； 标记完当前节点是否为静态节点之后，如果该节点是元素节点，那么还要继续去递归判断它的子节点

如果有一个子节点不是静态节点，那么它是父节点也标识为非静态节点

```js
if (node.ifConditions) {
    for (let i = 1, l = node.ifConditions.length; i < l; i++) {
        const block = node.ifConditions[i].block
        markStatic(block)
        if (!block.static) {
            node.static = false
        }
    }
}
```

### 标记静态根节点

一个节点要想成为静态根节点，它必须满足以下要求：

- 节点本身必须是静态节点；
- 必须拥有子节点 `children`；
- 子节点不能只是只有一个文本节点； 否则的话，对它的优化成本将大于优化后带来的收益。

如果当前节点不是静态根节点，那就继续递归遍历它的子节点`node.children`和`node.ifConditions`，如下：

```js
if (node.children) {
    for (let i = 0, l = node.children.length; i < l; i++) {
        markStaticRoots(node.children[i], isInFor || !!node.for)
    }
}
if (node.ifConditions) {
    for (let i = 1, l = node.ifConditions.length; i < l; i++) {
        markStaticRoots(node.ifConditions[i].block, isInFor)
    }
}
```

## generate 代码生成器

代码生成阶段的源码位于`src/compiler/codegen/index.js` 中，核心逻辑如下：

```js
export function generate (ast,option) {
  const state = new CodegenState(options)
  const code = ast ? genElement(ast, state) : '_c("div")'
  return {
    render: `with(this){return ${code}}`,
    staticRenderFns: state.staticRenderFns
  }
}
```

调用`generate`函数并传入优化后得到的`ast`，在`generate`函数内部先判断`ast`是否为空，不为空则调用`genElement(ast, state)`函数创建`VNode`，为空则创建一个空的元素型`div`的`VNode`。然后将得到的结果用`with(this){return ${code}}`包裹返回。可以看出，真正起作用的是`genElement`函数，下面我们继续来看一下`genElement`函数内部是怎样的。

`genElement`函数定义如下：

```js
export function genElement (el: ASTElement, state: CodegenState): string {
  if (el.staticRoot && !el.staticProcessed) {
    return genStatic(el, state)
  } else if (el.once && !el.onceProcessed) {
    return genOnce(el, state)
  } else if (el.for && !el.forProcessed) {
    return genFor(el, state)
  } else if (el.if && !el.ifProcessed) {
    return genIf(el, state)
  } else if (el.tag === 'template' && !el.slotTarget) {
    return genChildren(el, state) || 'void 0'
  } else if (el.tag === 'slot') {
    return genSlot(el, state)
  } else {
    // component or element
    let code
    if (el.component) {
      code = genComponent(el.component, el, state)
    } else {
      const data = el.plain ? undefined : genData(el, state)
      const children = el.inlineTemplate ? null : genChildren(el, state, true)
      code = `_c('${el.tag}'${
        data ? `,${data}` : '' // data
      }${
        children ? `,${children}` : '' // children
      })`
    }
    // module transforms
    for (let i = 0; i < state.transforms.length; i++) {
      code = state.transforms[i](el, code)
    }
    return code
  }
}
```

`genElement`函数逻辑很清晰，就是根据当前 `AST` 元素节点属性的不同从而执行不同的代码生成函数。虽然元素节点属性的情况有很多种，但是最后真正创建出来的`VNode`无非就三种，分别是元素节点，文本节点，注释节点。接下来我们就着重分析一下如何生成这三种节点类型的`render`函数的。

### 元素节点

生成元素型节点的`render`函数代码如下：

```js
const data = el.plain ? undefined : genData(el, state)
const children = el.inlineTemplate ? null : genChildren(el, state, true)
code = `_c('${el.tag}'${
data ? `,${data}` : '' // data
}${
children ? `,${children}` : '' // children
})`
```

生成元素节点的`render`函数就是生成一个`_c()`函数调用的字符串，上文提到了`_c()`函数接收三个参数，分别是节点的标签名`tagName`，节点属性`data`，节点的子节点列表`children`。那么我们只需将这三部分都填进去即可。

- 获取节点属性data

首先判断`plain`属性是否为`true`，若为`true`则表示节点没有属性，将`data`赋值为`undefined`；如果不为`true`则调用`genData`函数获取节点属性`data`数据。`genData`函数定义如下：

```js
export function genData (el: ASTElement, state: CodegenState): string {
  let data = '{'
  const dirs = genDirectives(el, state)
  if (dirs) data += dirs + ','
    // key
    if (el.key) {
        data += `key:${el.key},`
    }
    // ref
    if (el.ref) {
        data += `ref:${el.ref},`
    }
    if (el.refInFor) {
        data += `refInFor:true,`
    }
    // pre
    if (el.pre) {
        data += `pre:true,`
    }
    // 篇幅所限，省略其他情况的判断
    data = data.replace(/,$/, '') + '}'
    return data
}
```

在拼接字符串，先给`data`赋值为一个`{`，然后判断存在哪些属性数据，就将这些数据拼接到`data`中，最后再加一个`}`，最终得到节点全部属性`data`。

- 获取子节点列表children

获取子节点列表`children`其实就是遍历`AST`的`children`属性中的元素，然后根据元素属性的不同生成不同的`VNode`创建函数调用字符串，如下：

```js
export function genChildren (el):  {
    if (children.length) {
        return `[${children.map(c => genNode(c, state)).join(',')}]`
    }
}
function genNode (node: ASTNode, state: CodegenState): string {
  if (node.type === 1) {
    return genElement(node, state)
  } if (node.type === 3 && node.isComment) {
    return genComment(node)
  } else {
    return genText(node)
  }
}
```

- 上面两步完成之后，生成`_c（）`函数调用字符串，如下：

```js
code = `_c('${el.tag}'${
        data ? `,${data}` : '' // data
      }${
        children ? `,${children}` : '' // children
      })`
```

### 文本节点

文本型的`VNode`可以调用`_v(text)`函数来创建，所以生成文本节点的`render`函数就是生成一个`_v(text)`函数调用的字符串。`_v()`函数接收文本内容作为参数，如果文本是动态文本，则使用动态文本`AST`节点的`expression`属性，如果是纯静态文本，则使用`text`属性。其生成代码如下：

```js
export function genText (text: ASTText | ASTExpression): string {
  return `_v(${text.type === 2
    ? text.expression // no need for () because already wrapped in _s()
    : transformSpecialNewlines(JSON.stringify(text.text))
  })`
}
```

### 注释节点

注释型的`VNode`可以调用`_e(text)`函数来创建，所以生成注释节点的`render`函数就是生成一个`_e(text)`函数调用的字符串。`_e()`函数接收注释内容作为参数，其生成代码如下：

```js
export function genComment (comment: ASTText): string {
  return `_e(${JSON.stringify(comment.text)})`
}
```

## 模板编译的整体流程

最开始调用的`compileToFunctions`函数内部调用了`compile`函数，在`compile`函数内部又调用了`baseCompile`函数，而`baseCompile`函数返回的是代码生成阶段生成好的`render`函数字符串。所以在`compileToFunctions`函数内部调用`compile`函数就可以拿到生成好的`render`函数字符串，然后在`compileToFunctions`函数内部将`render`函数字符串传给`createFunction`函数从而变成真正的`render`函数返回出去，最后将其赋值给`options.render`



![总结 - 图1](https://gitee.com/FIF/pic-beg/raw/master/images/vue/14ebb3e5a563e3b7a392a05d21cc7b5b.jpeg)

## 参考文章

- https://www.bookset.io/read/Learn-Vue-Source-Code/047cbc3ffd2f606c.md

- https://ustbhuangyi.github.io/vue-analysis/v2/compile/