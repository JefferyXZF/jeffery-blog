---
title: keep-alive 实现原理
date: 2021-04-27 20:45:35
permalink: /pages/sseeeewweef7
author: jeffery
categories: 
  - Vue 源码
tags: 
  - Vue 源码
---

# keep-alive 实现原理

## 前言

`<keep-alive>` 是 `Vue` 实现的一个内置组件，也就是说 `Vue` 源码不仅实现了一套组件化的机制，也实现了一些内置组件，关于`<keep-alive>`组件，官网如下介绍：

> `<keep-alive>`是`Vue`中内置的一个抽象组件，它自身不会渲染一个 `DOM` 元素，也不会出现在父组件链中。当它包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们。

这句话的意思简单来说：就是我们可以把一些不常变动的组件或者需要缓存的组件用`<keep-alive>`包裹起来，这样`<keep-alive>`就会帮我们把组件保存在内存中，而不是直接的销毁，这样做可以保留组件的状态或避免多次重新渲染，以提高页面性能。



### 基础使用

介绍原理之前，我们先根据官方文档来回顾一下`<keep-alive>`组件的具体用法，如下：

`<keep-alive>`组件可接收三个属性：

- `include` - 字符串或正则表达式。只有名称匹配的组件会被缓存。
- `exclude` - 字符串或正则表达式。任何名称匹配的组件都不会被缓存。
- `max` - 数字。最多可以缓存多少组件实例。

`include` 和 `exclude` 属性允许组件有条件地缓存。二者都可以用逗号分隔字符串、正则表达式或一个数组来表示：

```html
<!-- 逗号分隔字符串 -->
<keep-alive include="a,b">
  <component :is="view"></component>
</keep-alive>

<!-- 正则表达式 (使用 `v-bind`) -->
<keep-alive :include="/a|b/">
  <component :is="view"></component>
</keep-alive>

<!-- 数组 (使用 `v-bind`) -->
<keep-alive :include="['a', 'b']">
  <component :is="view"></component>
</keep-alive>

```

匹配时首先检查组件自身的 `name` 选项，如果 `name` 选项不可用，则匹配它的局部注册名称 (父组件 `components` 选项的键值)，也就是组件的标签值。匿名组件不能被匹配。

`max`表示最多可以缓存多少组件实例。一旦这个数字达到了，在新实例被创建之前，**已缓存组件中最久没有被访问的实例**会被销毁掉。



`keep-alive`的基本使用只需要在动态组件或者 `view-router` 的最外层添加标签即可。

```html
<div id="app">
    <button @click="changeTabs('child1')">child1</button>
    <button @click="changeTabs('child2')">child2</button>
    <keep-alive>
        <component :is="chooseTabs">
        </component>
    </keep-alive>
</div>
<script>
var child1 = {
    template: '<div><button @click="add">add</button><p>{{num}}</p></div>',
    data() {
        return {
            num: 1
        }
    },
    methods: {
        add() {
            this.num++
        }
    },
    mounted() {
        console.log('child1 mounted')
    },
    activated() {
        console.log('child1 activated')
    },
    deactivated() {
        console.log('child1 deactivated')
    },
    destoryed() {
        console.log('child1 destoryed')
    }
}
var child2 = {
    template: '<div>child2</div>',
    mounted() {
        console.log('child2 mounted')
    },
    activated() {
        console.log('child2 activated')
    },
    deactivated() {
        console.log('child2 deactivated')
    },
    destoryed() {
        console.log('child2 destoryed')
    }
}

var vm = new Vue({
    el: '#app',
    components: {
        child1,
        child2,
    },
    data() {
        return {
            chooseTabs: 'child1',
        }
    },
    methods: {
        changeTabs(tab) {
            this.chooseTabs = tab;
        }
    }
})
</script>
```

简单的结果如下，动态组件在`child1,child2`之间来回切换，当第二次切到`child1`时，`child1`保留着原来的数据状态，`num = 5`。

![img](https://gitee.com/FIF/pic-beg/raw/master/images/javascript/13.1.gif)

## 从模板编译到生成vnode

从模板的解析开始说起，第一个疑问便是：内置组件和普通组件在编译过程有区别吗？答案是没有的，不管是内置的还是用户定义组件，本质上组件在模板编译成`render`函数的处理方式是一致的，按照之前的编译流程，最终 `keep-alive`的`render`函数的结果如下：

```js
with(this){···_c('keep-alive',{attrs:{"include":"child2"}},[_c(chooseTabs,{tag:"component"})],1)}
Copy
```

有了`render`函数，接下来从子开始到父会执行生成`Vnode`对象的过程，`_c('keep-alive'···)`的处理，会执行`createElement`生成组件`Vnode`,其中由于`keep-alive`是组件，所以会调用`createComponent`函数去创建子组件`Vnode`,`createComponent`之前也有分析过，这个环节和创建普通组件`Vnode`不同之处在于，`keep-alive`的`Vnode`会剔除多余的属性内容，**由于`keep-alive`除了`slot`属性之外，其他属性在组件内部并没有意义，例如`class`样式，`<keep-alive clas="test"></keep-alive>`等，所以在`Vnode`层剔除掉多余的属性是有意义的。而`<keep-alive slot="test">`的写法在2.6以上的版本也已经被废弃。**(其中`abstract`作为抽象组件的标志)

```js
// 创建子组件Vnode过程
function createComponent(Ctordata,context,children,tag) {
    // abstract是内置组件(抽象组件)的标志
    if (isTrue(Ctor.options.abstract)) {
        // 只保留slot属性，其他标签属性都被移除，在vnode对象上不再存在
        var slot = data.slot;
        data = {};
        if (slot) {
            data.slot = slot;
        }
    }
}
Copy
```

## 初次渲染

`keep-alive`之所以特别，是因为它不会重复渲染相同的组件，只会利用初次渲染保留的缓存去更新节点。所以为了全面了解它的实现原理，我们需要从`keep-alive`的首次渲染开始说起。



### 首次渲染流程图

为了理清楚流程，画了一个流程图，流程图大致覆盖了初始渲染`keep-alive`所执行的过程，接下来会照着这个过程进行源码分析。

![img](https://gitee.com/FIF/pic-beg/raw/master/images/javascript/13.2.png)

和渲染普通组件相同的是，`Vue`会拿到前面生成的`Vnode`对象执行真实节点创建的过程，也就是熟悉的`patch`过程,`patch`执行阶段会调用`createElm`创建真实`dom`，在创建节点途中，`keep-alive`的`vnode`对象会被认定是一个组件`Vnode`,因此针对组件`Vnode`又会执行`createComponent`函数，它会对`keep-alive`组件进行初始化和实例化。

```js
function createComponent (vnode, insertedVnodeQueue, parentElm, refElm) {
      var i = vnode.data;
      if (isDef(i)) {
        // isReactivated用来判断组件是否缓存。
        var isReactivated = isDef(vnode.componentInstance) && i.keepAlive;
        if (isDef(i = i.hook) && isDef(i = i.init)) {
            // 执行组件初始化的内部钩子 init
          i(vnode, false /* hydrating */);
        }
        if (isDef(vnode.componentInstance)) {
          // 其中一个作用是保留真实dom到vnode中
          initComponent(vnode, insertedVnodeQueue);
          insert(parentElm, vnode.elm, refElm);
          if (isTrue(isReactivated)) {
            reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm);
          }
          return true
        }
      }
    }

```

`keep-alive`组件会先调用内部钩子`init`方法进行初始化操作，我们先看看`init`过程做了什么操作。

```js
// 组件内部钩子
var componentVNodeHooks = {
    init: function init (vnode, hydrating) {
      if (
        vnode.componentInstance &&
        !vnode.componentInstance._isDestroyed &&
        vnode.data.keepAlive
      ) {
        // kept-alive components, treat as a patch
        var mountedNode = vnode; // work around flow
        componentVNodeHooks.prepatch(mountedNode, mountedNode);
      } else {
          // 将组件实例赋值给vnode的componentInstance属性
        var child = vnode.componentInstance = createComponentInstanceForVnode(
          vnode,
          activeInstance
        );
        child.$mount(hydrating ? vnode.elm : undefined, hydrating);
      }
    },
    // 后面分析
    prepatch： function() {}
}
```

第一次执行，很明显组件`vnode`没有`componentInstance`属性，`vnode.data.keepAlive`也没有值，所以会**调用`createComponentInstanceForVnode`方法进行组件实例化并将组件实例赋值给`vnode`的`componentInstance`属性，** 最终执行组件实例的`$mount`方法进行实例挂载。

`createComponentInstanceForVnode`就是组件实例化的过程，无非就是一系列选项合并，初始化事件，生命周期等初始化操作。

```js
function createComponentInstanceForVnode (vnode, parent) {
    var options = {
      _isComponent: true,
      _parentVnode: vnode,
      parent: parent
    };
    // 内联模板的处理，忽略这部分代码
    ···
    // 执行vue子组件实例化
    return new vnode.componentOptions.Ctor(options)
  }
```

## 组件实现原理

我们在使用组件的时候经常利用对象的形式定义组件选项，包括`data,method,computed`等，并在父组件或根组件中注册。`keep-alive`同样遵循这个道理，内置两字也说明了`keep-alive`是在`Vue`源码中内置好的选项配置，并且也已经注册到全局

```js
// keepalive组件选项
  var KeepAlive = {
    name: 'keep-alive',
    // 抽象组件的标志
    abstract: true,
    // keep-alive允许使用的props
    props: {
      include: patternTypes,
      exclude: patternTypes,
      max: [String, Number]
    },

    created: function created () {
      // 缓存组件vnode
      this.cache = Object.create(null);
      // 缓存组件名
      this.keys = [];
    },

    destroyed: function destroyed () {
      for (var key in this.cache) {
        pruneCacheEntry(this.cache, key, this.keys);
      }
    },

    mounted: function mounted () {
      var this$1 = this;
      // 动态include和exclude
      // 对include exclue的监听
      this.$watch('include', function (val) {
        pruneCache(this$1, function (name) { return matches(val, name); });
      });
      this.$watch('exclude', function (val) {
        pruneCache(this$1, function (name) { return !matches(val, name); });
      });
    },
    // keep-alive的渲染函数
    render: function render () {
      // 拿到keep-alive下插槽的值
      var slot = this.$slots.default;
      // 第一个vnode节点
      var vnode = getFirstComponentChild(slot);
      // 拿到第一个组件实例
      var componentOptions = vnode && vnode.componentOptions;
      // keep-alive的第一个子组件实例存在
      if (componentOptions) {
        // check pattern
        //拿到第一个vnode节点的name
        var name = getComponentName(componentOptions);
        var ref = this;
        var include = ref.include;
        var exclude = ref.exclude;
        // 通过判断子组件是否满足缓存匹配
        if (
          // not included
          (include && (!name || !matches(include, name))) ||
          // excluded
          (exclude && name && matches(exclude, name))
        ) {
          return vnode
        }

        var ref$1 = this;
        var cache = ref$1.cache;
        var keys = ref$1.keys;
        var key = vnode.key == null
          ? componentOptions.Ctor.cid + (componentOptions.tag ? ("::" + (componentOptions.tag)) : '')
          : vnode.key;
          // 再次命中缓存
        if (cache[key]) {
          vnode.componentInstance = cache[key].componentInstance;
          // make current key freshest
          remove(keys, key);
          keys.push(key);
        } else {
        // 初次渲染时，将vnode缓存
          cache[key] = vnode;
          keys.push(key);
          // prune oldest entry
          if (this.max && keys.length > parseInt(this.max)) {
            pruneCacheEntry(cache, keys[0], keys, this._vnode);
          }
        }
        // 为缓存组件打上标志
        vnode.data.keepAlive = true;
      }
      // 将渲染的vnode返回
      return vnode || (slot && slot[0])
    }
  };
```

可以看到，该组件内没有常规的`<template></template>`标签，取而代之的是它内部多了一个叫做`render`的函数，所以它不是一个常规的模板组件，而是一个函数式组件。执行 `<keep-alive>` 组件渲染的时候，就会执行到这个 `render` 函数。

### props

在`props`选项内接收传进来的三个属性：`include`、`exclude`和`max`。如下：

```javascript
props: {
    include: [String, RegExp, Array],
    exclude: [String, RegExp, Array],
    max: [String, Number]
}
```



`include` 表示只有匹配到的组件会被缓存，而 `exclude` 表示任何匹配到的组件都不会被缓存， `max`表示缓存组件的数量，因为我们是缓存的 `vnode` 对象，它也会持有 DOM，当我们缓存的组件很多的时候，会比较占用内存，所以该配置允许我们指定缓存组件的数量。

### created

在 `created` 钩子函数里定义并初始化了两个属性： `this.cache` 和 `this.keys`。

```javascript
created () {
    this.cache = Object.create(null)
    this.keys = []
}
```



`this.cache`是一个对象，用来存储需要缓存的组件，它将以如下形式存储：

```javascript
this.cache = {
    'key1':'组件1',
    'key2':'组件2',
    // ...
}
```

`this.keys`是一个数组，用来存储每个需要缓存的组件的`key`，即对应`this.cache`对象中的键值。



### destroyed

当`<keep-alive>`组件被销毁时，此时会调用`destroyed`钩子函数，在该钩子函数里会遍历`this.cache`对象，然后将那些被缓存的并且当前没有处于被渲染状态的组件都销毁掉并将其从`this.cache`对象中剔除。如下：

```javascript
destroyed () {
    for (const key in this.cache) {
        pruneCacheEntry(this.cache, key, this.keys)
    }
}

// pruneCacheEntry函数
function pruneCacheEntry (cache,key,keys,current) {
  const cached = cache[key]
  /* 判断当前没有处于被渲染状态的组件，将其销毁*/
  if (cached && (!current || cached.tag !== current.tag)) {
    cached.componentInstance.$destroy()
  }
  cache[key] = null
  remove(keys, key)
}
```

### mounted

在`mounted`钩子函数中观测 `include` 和 `exclude` 的变化，如下：

```javascript
mounted () {
    this.$watch('include', val => {
        pruneCache(this, name => matches(val, name))
    })
    this.$watch('exclude', val => {
        pruneCache(this, name => !matches(val, name))
    })
}
```



如果`include` 或`exclude` 发生了变化，即表示定义需要缓存的组件的规则或者不需要缓存的组件的规则发生了变化，那么就执行`pruneCache`函数，函数如下：

```javascript
function pruneCache (keepAliveInstance, filter) {
  const { cache, keys, _vnode } = keepAliveInstance
  for (const key in cache) {
    const cachedNode = cache[key]
    if (cachedNode) {
      const name = getComponentName(cachedNode.componentOptions)
      if (name && !filter(name)) {
        pruneCacheEntry(cache, key, keys, _vnode)
      }
    }
  }
}

function pruneCacheEntry (cache,key,keys,current) {
  const cached = cache[key]
  if (cached && (!current || cached.tag !== current.tag)) {
    cached.componentInstance.$destroy()
  }
  cache[key] = null
  remove(keys, key)
}
```



在该函数内对`this.cache`对象进行遍历，取出每一项的`name`值，用其与新的缓存规则进行匹配，如果匹配不上，则表示在新的缓存规则下该组件已经不需要被缓存，则调用`pruneCacheEntry`函数将这个已经不需要缓存的组件实例先销毁掉，然后再将其从`this.cache`对象中剔除。

### render

接下来就是重头戏`render`函数，也是本篇文章中的重中之重。以上工作都是一些辅助工作，真正实现缓存功能的就在这个`render`函数里，接下来我们逐行分析它。

在`render`函数中首先获取第一个子组件节点的 `vnode`：

```javascript
/* 获取默认插槽中的第一个组件节点 */
const slot = this.$slots.default
const vnode = getFirstComponentChild(slot)
```



由于我们也是在 `<keep-alive>` 标签内部写 DOM，所以可以先获取到它的默认插槽，然后再获取到它的第一个子节点。`<keep-alive>` 只处理第一个子元素，所以一般和它搭配使用的有 `component` 动态组件或者是 `router-view`。

接下来获取该组件节点的名称：

```javascript
/* 获取该组件节点的名称 */
const name = getComponentName(componentOptions)

/* 优先获取组件的name字段，如果name不存在则获取组件的tag */
function getComponentName (opts: ?VNodeComponentOptions): ?string {
  return opts && (opts.Ctor.options.name || opts.tag)
}
```



然后用组件名称跟 `include`、`exclude` 中的匹配规则去匹配：

```javascript
const { include, exclude } = this
/* 如果name与include规则不匹配或者与exclude规则匹配则表示不缓存，直接返回vnode */
if (
    (include && (!name || !matches(include, name))) ||
    // excluded
    (exclude && name && matches(exclude, name))
) {
    return vnode
}
```



如果组件名称与 `include` 规则不匹配或者与 `exclude` 规则匹配，则表示不缓存该组件，直接返回这个组件的 `vnode`，否则的话走下一步缓存：

```javascript
const { cache, keys } = this
/* 获取组件的key */
const key = vnode.key == null
? componentOptions.Ctor.cid + (componentOptions.tag ? `::${componentOptions.tag}` : '')
: vnode.key

/* 如果命中缓存，则直接从缓存中拿 vnode 的组件实例 */
if (cache[key]) {
    vnode.componentInstance = cache[key].componentInstance
    /* 调整该组件key的顺序，将其从原来的地方删掉并重新放在最后一个 */
    remove(keys, key)
    keys.push(key)
}
/* 如果没有命中缓存，则将其设置进缓存 */
else {
    cache[key] = vnode
    keys.push(key)
    /* 如果配置了max并且缓存的长度超过了this.max，则从缓存中删除第一个 */
    if (this.max && keys.length > parseInt(this.max)) {
        pruneCacheEntry(cache, keys[0], keys, this._vnode)
    }
}
/* 最后设置keepAlive标记位 */
vnode.data.keepAlive = true
```



首先获取组件的`key`值：

```javascript
const key = vnode.key == null?
componentOptions.Ctor.cid + (componentOptions.tag ? `::${componentOptions.tag}` : '')
: vnode.key
```



拿到`key`值后去`this.cache`对象中去寻找是否有该值，如果有则表示该组件有缓存，即命中缓存：

```javascript
/* 如果命中缓存，则直接从缓存中拿 vnode 的组件实例 */
if (cache[key]) {
    vnode.componentInstance = cache[key].componentInstance
    /* 调整该组件key的顺序，将其从原来的地方删掉并重新放在最后一个 */
    remove(keys, key)
    keys.push(key)
}
```



直接从缓存中拿 `vnode` 的组件实例，此时重新调整该组件key的顺序，将其从原来的地方删掉并重新放在`this.keys`中最后一个。

如果`this.cache`对象中没有该`key`值：

```javascript
/* 如果没有命中缓存，则将其设置进缓存 */
else {
    cache[key] = vnode
    keys.push(key)
    /* 如果配置了max并且缓存的长度超过了this.max，则从缓存中删除第一个 */
    if (this.max && keys.length > parseInt(this.max)) {
        pruneCacheEntry(cache, keys[0], keys, this._vnode)
    }
}
```



表明该组件还没有被缓存过，则以该组件的`key`为键，组件`vnode`为值，将其存入`this.cache`中，并且把`key`存入`this.keys`中。此时再判断`this.keys`中缓存组件的数量是否超过了设置的最大缓存数量值`this.max`，如果超过了，则把第一个缓存组件删掉。

那么问题来了：**为什么要删除第一个缓存组件并且为什么命中缓存了还要调整组件key的顺序？**

这其实应用了一个缓存淘汰策略LRU：

> LRU（**Least recently used**，最近最少使用）算法根据数据的历史访问记录来进行淘汰数据，其核心思想是“如果数据最近被访问过，那么将来被访问的几率也更高”。

它的算法是这样子的：

![img](https://gitee.com/FIF/pic-beg/raw/master/images/javascript/3.bfadecb3.png)

1. 将新数据从尾部插入到`this.keys`中；
2. 每当缓存命中（即缓存数据被访问），则将数据移到`this.keys`的尾部；
3. 当`this.keys`满的时候，将头部的数据丢弃；

LRU的核心思想是如果数据最近被访问过，那么将来被访问的几率也更高，所以我们将命中缓存的组件`key`重新插入到`this.keys`的尾部，这样一来，`this.keys`中越往头部的数据即将来被访问几率越低，所以当缓存数量达到最大值时，我们就删除将来被访问几率最低的数据，即`this.keys`中第一个缓存的组件。这也就之前加粗强调的**已缓存组件中最久没有被访问的实例**会被销毁掉的原因所在。

OK，言归正传，以上工作做完后设置 `vnode.data.keepAlive = true` ，最后将`vnode`返回。

以上就是`render`函数的整个过程。

### 真实节点的保存

我们回到`createComponent`的逻辑，`createComponent`会先执行`keep-alive`组件的初始化流程，也包括了子组件的挂载。并且我们通过`componentInstance`拿到了`keep-alive`组件的实例，而接下来**重要的一步是将真实的`dom`保存再`vnode`中**。

```js
function createComponent(vnode, insertedVnodeQueue) {
    ···
    if (isDef(vnode.componentInstance)) {
        // 其中一个作用是保留真实dom到vnode中
        initComponent(vnode, insertedVnodeQueue);
        // 将真实节点添加到父节点中
        insert(parentElm, vnode.elm, refElm);
        if (isTrue(isReactivated)) {
            reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm);
        }
        return true
    }
}
```

`insert`的源码不列举出来，它只是简单的调用操作`dom`的`api`,将子节点插入到父节点中，我们可以重点看看`initComponent`关键步骤的逻辑。

```js
function initComponent() {
    ···
    // vnode保留真实节点
    vnode.elm = vnode.componentInstance.$el;
    ···
}
```



由于`isReactivated`为`false`,`reactivateComponent`函数也不会执行。至此`keep-alive`的初次渲染流程分析完毕。

**如果忽略步骤的分析，只对初次渲染流程做一个总结：内置的`keep-alive`组件，让子组件在第一次渲染的时候将`vnode`和真实的`elm`进行了缓存。**

## 抽象组件

`Vue`提供的内置组件有一个描述组件类型的选项，这个选项就是`{ astract: true }`,它表明了该组件是抽象组件。什么是抽象组件，为什么要有这一类型的区别呢？我觉得归根究底有两个方面的原因。

1. 抽象组件没有真实的节点，它在组件渲染阶段不会去解析渲染成真实的`dom`节点，而只是作为中间的数据过渡层处理，在`keep-alive`中是对组件缓存的处理。
2. 在我们介绍组件初始化的时候曾经说到父子组件会显式的建立一层关系，这层关系奠定了父子组件之间通信的基础。我们可以再次回顾一下`initLifecycle`的代码。

```js
Vue.prototype._init = function() {
    ···
    var vm = this;
    initLifecycle(vm)
}

function initLifecycle (vm) {
    var options = vm.$options;

    var parent = options.parent;
    if (parent && !options.abstract) {
        // 如果有abstract属性，一直往上层寻找，直到不是抽象组件
      while (parent.$options.abstract && parent.$parent) {
        parent = parent.$parent;
      }
      parent.$children.push(vm);
    }
    ···
  }
```

子组件在注册阶段会把父实例挂载到自身选项的`parent`属性上，在`initLifecycle`过程中，会反向拿到`parent`上的父组件`vnode`,并为其`$children`属性添加该子组件`vnode`,如果在反向找父组件的过程中，父组件拥有`abstract`属性，即可判定该组件为抽象组件，此时利用`parent`的链条往上寻找，直到组件不是抽象组件为止。`initLifecycle`的处理，让每个组件都能找到上层的父组件以及下层的子组件，使得组件之间形成一个紧密的关系树。



## keep-alive 组件重新渲染流程分析

### 组件更新流程图

和首次渲染的分析一致，下面是再次渲染简单的流程图。

![img](https://gitee.com/FIF/pic-beg/raw/master/images/javascript/13.3.png)



###  重新渲染组件

再次渲染的流程从数据改变说起，在这个例子中，动态组件中`chooseTabs`数据的变化会引起依赖派发更新的过程。简单来说，`chooseTabs`这个数据在初始化阶段会收集使用到该数据的相关依赖。当数据发生改变时，收集过的依赖会进行派发更新操作。

其中，父组件中负责实例挂载的过程作为依赖会被执行，即执行父组件的`vm._update(vm._render(), hydrating);`。`_render`和`_update`分别代表两个过程，其中`_render`函数会根据数据的变化为组件生成新的`Vnode`节点，而`_update`最终会为新的`Vnode`生成真实的节点。而在生成真实节点的过程中，会利用`vitrual dom`的`diff`算法对前后`vnode`节点进行对比，使之尽可能少的更改真实节点。`patch`是新旧`Vnode`节点对比的过程，而`patchVnode`是其中核心的步骤，我们忽略`patchVnode`其他的流程，关注到其中对子组件执行`prepatch`钩子的过程中。

```js
function patchVnode (oldVnode,vnode,insertedVnodeQueue,ownerArray,index,removeOnly) {
    ···
    // 新vnode  执行prepatch钩子
    if (isDef(data) && isDef(i = data.hook) && isDef(i = i.prepatch)) {
        i(oldVnode, vnode);
    }
    ···
}
```

执行`prepatch`钩子时会拿到新旧组件的实例并执行`updateChildComponent`函数。而`updateChildComponent`会对针对新的组件实例对旧实例进行状态的更新，包括`props,listeners`等，最终会**调用`vue`提供的全局`vm.$forceUpdate()`方法进行实例的重新渲染。**

```js
var componentVNodeHooks = {
    // 之前分析的init钩子 
    init: function() {},
    prepatch: function prepatch (oldVnode, vnode) {
        // 新组件实例
      var options = vnode.componentOptions;
      // 旧组件实例
      var child = vnode.componentInstance = oldVnode.componentInstance;
      updateChildComponent(
        child,
        options.propsData, // updated props
        options.listeners, // updated listeners
        vnode, // new parent vnode
        options.children // new children
      );
    },
}

function updateChildComponent() {
    // 更新旧的状态，不分析这个过程
    ···
    // 迫使实例重新渲染。
    vm.$forceUpdate();
}
```

先看看`$forceUpdate`做了什么操作。`$forceUpdate`是源码对外暴露的一个api，他们迫使`Vue`实例重新渲染，本质上是执行实例所收集的依赖，在例子中`watcher`对应的是`keep-alive`的`vm._update(vm._render(), hydrating);`过程。

```js
Vue.prototype.$forceUpdate = function () {
    var vm = this;
    if (vm._watcher) {
      vm._watcher.update();
    }
  };
Copy
```

### 重用缓存组件

由于`vm.$forceUpdate()`会强迫`keep-alive`组件进行重新渲染，因此`keep-alive`组件会再一次执行`render`过程。这一次由于第一次对`vnode`的缓存，`keep-alive`在实例的`cache`对象中找到了缓存的组件。所以直接通过`cache[key]`取出缓存的组件实例并赋值给`vnode`的`componentInstance`属性。

### 真实节点的替换

执行了`keep-alive`组件的`_render`过程，接下来是`_update`产生真实的节点，同样的，`keep-alive`下有`child1`子组件，所以`_update`过程会调用`createComponent`递归创建子组件`vnode`,这个过程在初次渲染时也有分析过，我们可以对比一下，再次渲染时流程有哪些不同。

```js
function createComponent (vnode, insertedVnodeQueue, parentElm, refElm) {
    // vnode为缓存的vnode
      var i = vnode.data;
      if (isDef(i)) {
        // 此时isReactivated为true
        var isReactivated = isDef(vnode.componentInstance) && i.keepAlive;
        if (isDef(i = i.hook) && isDef(i = i.init)) {
          i(vnode, false /* hydrating */);
        }
        if (isDef(vnode.componentInstance)) {
          // 其中一个作用是保留真实dom到vnode中
          initComponent(vnode, insertedVnodeQueue);
          insert(parentElm, vnode.elm, refElm);
          if (isTrue(isReactivated)) {
            reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm);
          }
          return true
        }
      }
    }
```

**此时的`vnode`是缓存取出的子组件`vnode`**，并且由于在第一次渲染时对组件进行了标记`vnode.data.keepAlive = true;`,所以`isReactivated`的值为`true`,`i.init`依旧会执行子组件的初始化过程。但是这个过程由于有缓存，所以执行过程也不完全相同。

```js
var componentVNodeHooks = {
    init: function init (vnode, hydrating) {
      if (
        vnode.componentInstance &&
        !vnode.componentInstance._isDestroyed &&
        vnode.data.keepAlive
      ) {
        // 当有keepAlive标志时，执行prepatch钩子
        var mountedNode = vnode; // work around flow
        componentVNodeHooks.prepatch(mountedNode, mountedNode);
      } else {
        var child = vnode.componentInstance = createComponentInstanceForVnode(
          vnode,
          activeInstance
        );
        child.$mount(hydrating ? vnode.elm : undefined, hydrating);
      }
    },
}
Copy
```

显然因为有`keepAlive`的标志，所以子组件不再走挂载流程，只是执行`prepatch`钩子对组件状态进行更新。并且很好的利用了缓存`vnode`之前保留的真实节点进行节点的替换。

## 生命周期

我们通过例子来观察`keep-alive`生命周期和普通组件的不同。

![img](https://gitee.com/FIF/pic-beg/raw/master/images/javascript/13.4.gif)

在我们从`child1`切换到`child2`,再切回`child1`过程中，`chil1`不会再执行`mounted`钩子，只会执行`activated`钩子，而`child2`也不会执行`destoryed`钩子，只会执行`deactivated`钩子，这是为什么？`child2`的`deactivated`钩子又要比`child1`的`activated`提前执行，这又是为什么？

### deactivated

我们先从组件的销毁开始说起，当`child1`切换到`child2`时，`child1`会执行`deactivated`钩子而不是`destoryed`钩子，这是为什么？ 前面分析`patch`过程会对新旧节点的改变进行对比，从而尽可能范围小的去操作真实节点，当完成`diff`算法并对节点操作完毕后，接下来还有一个重要的步骤是**对旧的组件执行销毁移除操作**。这一步的代码如下：

```js
function patch(···) {
  // 分析过的patchVnode过程
  // 销毁旧节点
  if (isDef(parentElm)) {
    removeVnodes(parentElm, [oldVnode], 0, 0);
  } else if (isDef(oldVnode.tag)) {
    invokeDestroyHook(oldVnode);
  }
}

function removeVnodes (parentElm, vnodes, startIdx, endIdx) {
  // startIdx,endIdx都为0
  for (; startIdx <= endIdx; ++startIdx) {
    // ch 会拿到需要销毁的组件
    var ch = vnodes[startIdx];
    if (isDef(ch)) {
      if (isDef(ch.tag)) {
        // 真实节点的移除操作
        removeAndInvokeRemoveHook(ch);
        invokeDestroyHook(ch);
      } else { // Text node
        removeNode(ch.elm);
      }
    }
  }
}
```

`removeAndInvokeRemoveHook`会对旧的节点进行移除操作，其中关键的一步是会将真实节点从父元素中删除，有兴趣可以自行查看这部分逻辑。`invokeDestroyHook`是执行销毁组件钩子的核心。如果该组件下存在子组件，会递归去调用`invokeDestroyHook`执行销毁操作。销毁过程会执行组件内部的`destory`钩子。

```js
function invokeDestroyHook (vnode) {
    var i, j;
    var data = vnode.data;
    if (isDef(data)) {
      if (isDef(i = data.hook) && isDef(i = i.destroy)) { i(vnode); }
      // 执行组件内部destroy钩子
      for (i = 0; i < cbs.destroy.length; ++i) { cbs.destroy[i](vnode); }
    }
    // 如果组件存在子组件，则遍历子组件去递归调用invokeDestoryHook执行钩子
    if (isDef(i = vnode.children)) {
      for (j = 0; j < vnode.children.length; ++j) {
        invokeDestroyHook(vnode.children[j]);
      }
    }
  }
```

组件内部钩子前面已经介绍了`init`和`prepatch`钩子，而`destroy`钩子的逻辑更加简单。

```js
var componentVNodeHooks = {
  destroy: function destroy (vnode) {
    // 组件实例
    var componentInstance = vnode.componentInstance;
    // 如果实例还未被销毁
    if (!componentInstance._isDestroyed) {
      // 不是keep-alive组件则执行销毁操作
      if (!vnode.data.keepAlive) {
        componentInstance.$destroy();
      } else {
        // 如果是已经缓存的组件
        deactivateChildComponent(componentInstance, true /* direct */);
      }
    }
  }
}
```

当组件是`keep-alive`缓存过的组件，即已经用`keepAlive`标记过，则不会执行实例的销毁，即`componentInstance.$destroy()`的过程。`$destroy`过程会做一系列的组件销毁操作，其中的`beforeDestroy,destoryed`钩子也是在`$destory`过程中调用，而`deactivateChildComponent`的处理过程却完全不同。

```js
function deactivateChildComponent (vm, direct) {
  if (direct) {
    // 
    vm._directInactive = true;
    if (isInInactiveTree(vm)) {
      return
    }
  }
  if (!vm._inactive) {
    // 已经被停用
    vm._inactive = true;
    // 对子组件同样会执行停用处理
    for (var i = 0; i < vm.$children.length; i++) {
      deactivateChildComponent(vm.$children[i]);
    }
    // 最终调用deactivated钩子
    callHook(vm, 'deactivated');
  }
}
```

`_directInactive`是用来标记这个被打上停用标签的组件是否是最顶层的组件。而`_inactive`是停用的标志，同样的子组件也需要递归去调用`deactivateChildComponent`,打上停用的标记。**最终会执行用户定义的`deactivated`钩子。**

### activated

现在回过头看看`activated`的执行时机，同样是`patch`过程，在对旧节点移除并执行销毁或者停用的钩子后，对新节点也会执行相应的钩子。**这也是停用的钩子比启用的钩子先执行的原因。**

```js
function patch(···) {
  // patchVnode过程
  // 销毁旧节点
  {
    if (isDef(parentElm)) {
      removeVnodes(parentElm, [oldVnode], 0, 0);
    } else if (isDef(oldVnode.tag)) {
      invokeDestroyHook(oldVnode);
    }
  }
  // 执行组件内部的insert钩子
  invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch);
}

function invokeInsertHook (vnode, queue, initial) {
  // delay insert hooks for component root nodes, invoke them after the
  // 当节点已经被插入时，会延迟执行insert钩子
  if (isTrue(initial) && isDef(vnode.parent)) {
    vnode.parent.data.pendingInsert = queue;
  } else {
    for (var i = 0; i < queue.length; ++i) {
      queue[i].data.hook.insert(queue[i]);
    }
  }
}
```

同样的组件内部的`insert`钩子逻辑如下：

```js
// 组件内部自带钩子
  var componentVNodeHooks = {
    insert: function insert (vnode) {
      var context = vnode.context;
      var componentInstance = vnode.componentInstance;
      // 实例已经被挂载
      if (!componentInstance._isMounted) {
        componentInstance._isMounted = true;
        callHook(componentInstance, 'mounted');
      }
      if (vnode.data.keepAlive) {
        if (context._isMounted) {
          // vue-router#1212
          // During updates, a kept-alive component's child components may
          // change, so directly walking the tree here may call activated hooks
          // on incorrect children. Instead we push them into a queue which will
          // be processed after the whole patch process ended.
          queueActivatedComponent(componentInstance);
        } else {
          activateChildComponent(componentInstance, true /* direct */);
        }
      }
    },
  }
```

当第一次实例化组件时，由于实例的`_isMounted`不存在，所以会调用`mounted`钩子，当我们从`child2`再次切回`child1`时，由于`child1`只是被停用而没有被销毁，所以不会再调用`mounted`钩子，此时会执行`activateChildComponent`函数对组件的状态进行处理。有了分析`deactivateChildComponent`的基础，`activateChildComponent`的逻辑也很好理解，同样的`_inactive`标记为已启用，并且对子组件递归调用`activateChildComponent`做状态处理。

```js
function activateChildComponent (vm, direct) {
  if (direct) {
    vm._directInactive = false;
    if (isInInactiveTree(vm)) {
      return
    }
  } else if (vm._directInactive) {
    return
  }
  if (vm._inactive || vm._inactive === null) {
    vm._inactive = false;
    for (var i = 0; i < vm.$children.length; i++) {
      activateChildComponent(vm.$children[i]);
    }
    callHook(vm, 'activated');
  }
}
```

