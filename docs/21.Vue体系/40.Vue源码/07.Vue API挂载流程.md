---
title: Vue API挂载流程
date: 2021-04-13 15:45:35
permalink: /pages/sswewwwqe31ef7
author: jeffery
categories: 
  - Vue 源码
tags: 
  - Vue 源码
  - Vue
---

# Vue API挂载流程

阅读源码的注释仓库[github](https://github.com/JefferyXZF/vue/tree/dev-doc)

## Vue 构造函数API

`Vue` 之所以能实现各种高级的功能，比如响应式、编译、组件渲染，和它身上拥有丰富的 `API` 有关，`Vue` 在实例化前会挂载 `API` ，它的 `API` 分为**全局 API** 和**原型方法**，下面从入口文件到`Vue`构造函数挂载 `API` 的流程图：

![](https://gitee.com/FIF/pic-beg/raw/master/images/vue/process.8f86c136.png)

## initGlobalAPI挂载全局方法

`initGlobalAPI` 挂载全局方法，它的入口文件在 `src/core/index.js`

```js
import Vue from './instance/index'
import { initGlobalAPI } from './global-api/index'
initGlobalAPI(Vue)

export default Vue
```

`initGlobalAPI()`函数定义在 `src/core/global-api/index.js` 中：

```js

export function initGlobalAPI (Vue: GlobalAPI) {
  // config
  const configDef = {}
  // config 默认配置
  configDef.get = () => config

  // 使用代理，挂载 config 属性，get 方法定义了默认的配置
  Object.defineProperty(Vue, 'config', configDef)

  // 工具方法
  Vue.util = {
    warn,
    extend,
    mergeOptions,
    defineReactive
  }

  Vue.set = set
  Vue.delete = del
  Vue.nextTick = nextTick

  // 2.6 explicit observable API
  Vue.observable = <T>(obj: T): T => {
    observe(obj)
    return obj
  }

  Vue.options = Object.create(null)
  ASSET_TYPES.forEach(type => {
    Vue.options[type + 's'] = Object.create(null)
  })

  Vue.options._base = Vue

  //  注册 keep-alive 全局组件
  extend(Vue.options.components, builtInComponents)

  initUse(Vue) // 挂载 use 静态方法
  initMixin(Vue) // 挂载 mixin 静态方法，mergeOptions 方法合并 options
  initExtend(Vue) // 挂载 extend 静态方法
  initAssetRegisters(Vue) // 挂载 component, directive, filter 静态方法
}
```



`initGlobalAPI` 将`set`、`delete`、`nextTick`和`observable` 等函数直接挂载在`Vue`上，而其他几种`API`则是调用了一个以`init`开头的方法，我们以`initAssetRegisters()`方法为例

```js
// ['component','directive', 'filter']
import { ASSET_TYPES } from 'shared/constants'

export function initAssetRegisters (Vue: GlobalAPI) {
  ASSET_TYPES.forEach(type => {
    Vue[type] = function () {
      // 省略了函数的参数和函数实现代码
    }
  })
}
```

其中`ASSET_TYPES`是一个定义在`src/shared/constants.js`中的一个数组，然后在`initAssetRegisters()`方法中遍历这个数组，依次在`Vue`构造函数上挂载`Vue.component()`、`Vue.directive()`和`Vue.filter()`方法，另外三种`init`开头的方法挂载对应的全局`API`是一样的道理：

```js
// initUse
export function initUse(Vue) {
  Vue.use = function () {}
}

// initMixin
export function initMixin(Vue) {
  Vue.mixin = function () {}
}

// initExtend
export function initExtend(Vue) {
  Vue.extend = function () {}
}
```

最后，我们发现还差一个`Vue.compile()`方法，它其实是在`runtime+compile`版本才会有的一个全局方法，因此它在`src/platforms/web/entry-runtime-with-compile.js`中被定义：

```js
import Vue from './runtime/index'
import { compileToFunctions } from './compiler/index'
Vue.compile = compileToFunctions
export default Vue
```

根据`initGlobalAPI()`方法的逻辑，可以得到如下流程图：

![initGlobalAPI流程图](https://gitee.com/FIF/pic-beg/raw/master/images/vue/initGlobalAPIProcess.6d78bbb9.png)

## 挂载原型方法

挂载原型方法定义在 `src/core/instance/index.js`， 以 `xxxMixin` 结尾

```js
import { initMixin } from './init'
import { stateMixin } from './state'
import { renderMixin } from './render'
import { eventsMixin } from './events'
import { lifecycleMixin } from './lifecycle'
import { warn } from '../util/index'

function Vue (options) {
  this._init(options)
}

// 往 Vue 原型上添加属性和方法
initMixin(Vue) // 原型上添加 _init 方法
stateMixin(Vue) // 原型上添加 VUE 实例属性 $data, $props, $set, $delete, $watch
eventsMixin(Vue) // 原型上添加 $on, $once, $off, $emit 方法
lifecycleMixin(Vue) // 原型上添加 _update, $forceUpdate, $destroy 方法
renderMixin(Vue) // 安装运行时辅助工具，原型上添加 $nextTick, _render 方法

export default Vue
```

`xxxMixin` 结尾的方法定义在`instance`目录

```sh
|-- instance
|   |-- render-helpers      # render渲染相关的工具函数目录
|   |-- events.js           # 自定义事件处理相关
|   |-- init.js             # _init等方法相关
|   |-- inject.js           # inject和provide相关
|   |-- lifecycle.js        # 生命周期相关
|   |-- proxy.js            # 代理相关
|   |-- render.js           # 渲染相关
|   |-- state.js            # 数据状态相关
|   |-- index.js            # 入口文件
```

可以看到，目录结构文件有很多，而且包含的面也非常杂，但我们现在只需要对我们最关心的几个部分做介绍：

- `events.js`：处理自定义事件相关，例如：`$on`，`$off`，`$emit`以及`$once`等方法的实现。
- `init.js`：此部分代码逻辑包含了`Vue`从创建实例到实例挂载阶段的所有主要逻辑。
- `lifecycle.js`：生命周期相关，例如：`$destroy`、`$activated`和`$deactivated`。
- `state.js`：数据状态相关，例如：`data`、`props`以及`computed`等。
- `render.js`：渲染相关，其中最值得关注的是`Vue.prototype._render`渲染函数的定义。



### initMixin 流程

`initMixin()`方法的主要作用就是在`Vue.prototype`上定义一个`_init()`实例方法，接下来我们来看一下`_init()`函数的具体实现逻辑：

```js
Vue.prototype._init = function (options) {
    const vm = this
    // 1. 合并配置
    if (options && options._isComponent) {
      initInternalComponent(vm, options)
    } else {
      vm.$options = mergeOptions(
        resolveConstructorOptions(vm.constructor),
        options || {},
        vm
      )
    }

    // 2.render代理
    if (process.env.NODE_ENV !== 'production') {
      initProxy(vm)
    } else {
      vm._renderProxy = vm
    }

    // 3.初始化生命周期、初始化事件中心、初始化inject，
    //   初始化state、初始化provide、调用生命周期
    vm._self = vm
    initLifecycle(vm)
    initEvents(vm)
    initRender(vm)
    callHook(vm, 'beforeCreate')
    initInjections(vm)
    initState(vm)
    initProvide(vm)
    callHook(vm, 'created')

    // 4.挂载
    if (vm.$options.el) {
      vm.$mount(vm.$options.el)
    }
  }
```

`initMixin`整体流程图

![img](https://gitee.com/FIF/pic-beg/raw/master/images/vue/initMixin.9a4f8f37.png)

### stateMixin 流程

`stateMixin`主要是处理跟实例相关的属性和方法，它会在`Vue.prototype`上定义实例化使用到的属性或者方法，代码在`src/core/instance/state.js`

```js
import { set, del } from '../observer/index'
export function stateMixin (Vue) {
  // 定义$data, $props
  const dataDef = {}
  dataDef.get = function () { return this._data }
  const propsDef = {}
  propsDef.get = function () { return this._props }
  Object.defineProperty(Vue.prototype, '$data', dataDef)
  Object.defineProperty(Vue.prototype, '$props', propsDef)

  // 定义$set, $delete, $watch
  Vue.prototype.$set = set
  Vue.prototype.$delete = del
  Vue.prototype.$watch = function() {}
}
```

我们可以从上面代码中发现，`stateMixin()`方法中在`Vue.prototype`上定义的几个属性或者方法，全部都是和响应式相关的，我们来简要分析一下以上代码：

- `$data和$props`：根据以上代码，我们发现`$data`和`$props`分别是`_data`和`_props`的访问代理，从命名中我们可以推测，以下划线开头的变量，我们一般认为是私有变量，然后通过`$data`和`$props`来提供一个对外的访问接口，虽然可以通过属性的`get()`方法去取，但对于这两个私有变量来说是并不能随意`set`，对于`data`来说不能替换根实例，而对于`props`来说它是只读的。因此在原版源码中，还劫持了`set()`方法，当设置`$data`或者`$props`时会报错：

```js
if (process.env.NODE_ENV !== 'production') {
  dataDef.set = function () {
    warn(
      'Avoid replacing instance root $data. ' +
      'Use nested data properties instead.',
      this
    )
  }
  propsDef.set = function () {
    warn(`$props is readonly.`, this)
  }
}
```

- `$set`和`$delete`：`set`和`delete`这两个方法被定义在跟`instance`目录平级的`observer`目录下，在`stateMixin()`中，它们分别赋值给了`$set`和`$delete`方法，而在`initGlobalAPI`中，也同样使用到了这两个方法，只不过一个是全局方法，一个是实例方法。
- `$watch`：在`stateMixin()`方法中，详细实现了`$watch()`方法，此方法实现的核心是通过一个`watcher`实例来监听。当取消监听时，同样是使用`watcher`实例相关的方法，关于`watcher`我们会在后续响应式章节详细介绍。

```js
Vue.prototype.$watch = function (
    expOrFn: string | Function,
    cb: any,
    options?: Object
  ): Function {
    const vm: Component = this
    if (isPlainObject(cb)) {
      return createWatcher(vm, expOrFn, cb, options)
    }
    options = options || {}
    options.user = true
    const watcher = new Watcher(vm, expOrFn, cb, options)
    if (options.immediate) {
      try {
        cb.call(vm, watcher.value)
      } catch (error) {
        handleError(error, vm, `callback for immediate watcher "${watcher.expression}"`)
      }
    }
    return function  () {
      watcher.teardownunwatchFn()
    }
  }
```



### eventsMixin 流程

在使用`Vue`做开发的时候，我们一定经常使用到`$emit`、`$on`、`$off`和`$once`等几个实例方法，`eventsMixin`主要做的就是在`Vue.prototype`上定义这四个实例方法：

```js
export function eventsMixin (Vue) {
  // 定义$on
  Vue.prototype.$on = function (event, fn) {}

  // 定义$once
  Vue.prototype.$once = function (event, fn) {}

  // 定义$off
  Vue.prototype.$off = function (event, fn) {}

  // 定义$emit
  Vue.prototype.$emit = function (event) {}
}
```



#### $on 的实现

- **参数**：

  - `{string | Array<string>} event` (数组只在 2.2.0+ 中支持)
  - `{Function} callback`

- **用法**：

  监听当前实例上的自定义事件。事件可以由 `vm.$emit` 触发。回调函数会接收所有传入事件触发函数的额外参数。

`$on`方法可以接受一个数组`event`，当传递一个`event`数组时，会通过遍历数组的形式递归调用`$on`方法。

```js
Vue.prototype.$on = function (event: string | Array<string>, fn: Function): Component {
  const vm: Component = this
  // 第一个参数是数组，递归处理
  if (Array.isArray(event)) {
    for (let i = 0, l = event.length; i < l; i++) {
      vm.$on(event[i], fn)
    }
  } else {
    // 将事件添加到 _events 对象下
    (vm._events[event] || (vm._events[event] = [])).push(fn)
    // optimize hook:event cost by using a boolean flag marked at registration
    // instead of a hash lookup
    if (hookRE.test(event)) {
      vm._hasHookEvent = true
    }
  }
  return vm
}
```



#### $emit 的实现

**参数**：

- `{string} eventName`
- `[...args]`

触发当前实例上的事件。附加参数都会传给监听器回调。

```js
Vue.prototype.$emit = function (event: string): Component {
  const vm: Component = this
  // ...省略处理边界代码
  let cbs = vm._events[event]
  if (cbs) {
    cbs = cbs.length > 1 ? toArray(cbs) : cbs
    const args = toArray(arguments, 1)
    const info = `event handler for "${event}"`
    for (let i = 0, l = cbs.length; i < l; i++) {
      invokeWithErrorHandling(cbs[i], vm, args, vm, info)
    }
  }
  return vm
}
```

代码分析：

- 从整体上看，`$emit`实现方法非常简单，第一步从`_events`对象中取出对应的`cbs`，接着一个个遍历`cbs`数组、调用并传参。

- `invokeWithErrorHandling`代码中会使用`try/catch`把我们函数调用并执行的地方包裹起来，当函数调用出错时，会执行`Vue`的`handleError()`方法，这种做法不仅更加友好，而且对错误处理也非常有用。



#### $off 的实现

- **参数**：

  - `{string | Array<string>} event` (只在 2.2.2+ 支持数组)
  - `{Function} [callback]`

- **用法**：

  移除自定义事件监听器。

  - 如果没有提供参数，则移除所有的事件监听器；
  - 如果只提供了事件，则移除该事件所有的监听器；
  - 如果同时提供了事件与回调，则只移除这个回调的监听器。

```js
  /**
   * 注销事件处理逻辑；_events 对象是存储所有注册对事件
   * 1、如果不传参数，注销所有事件
   * 2、如果第一个参数是数组，则进行递归处理
   * 3、只闯入一个参数，注销该类型事件
   * 4、如果传人两个参数，遍历删除该注册事件
   * @param {*} event 
   * @param {*} fn 
   */
  Vue.prototype.$off = function (event?: string | Array<string>, fn?: Function): Component {
    const vm: Component = this
    // all 不传参数，清空所有到事件
    if (!arguments.length) {
      vm._events = Object.create(null)
      return vm
    }
    // array of events
    if (Array.isArray(event)) {
      for (let i = 0, l = event.length; i < l; i++) {
        vm.$off(event[i], fn)
      }
      return vm
    }
    // specific event
    const cbs = vm._events[event]
    if (!cbs) {
      return vm
    }
    if (!fn) {
      vm._events[event] = null
      return vm
    }
    // specific handler
    let cb
    let i = cbs.length
    while (i--) {
      cb = cbs[i]
      if (cb === fn || cb.fn === fn) {
        cbs.splice(i, 1)
        break
      }
    }
    return vm
  }
```



`$off`方法的实现，相对来说比较复杂一点，因为它需要根据不同的传参做不同的事情：

- 当没有提供任何参数时，移除全部事件监听。
- 当只提供`event`参数时，只移除此`event`对应的监听器。
- 同时提供`event`参数和`fn`回调，则只移除此`event`对应的`fn`这个监听器。



#### $once 的实现

- **参数**：

  - `{string} event`
  - `{Function} callback`

- **用法**：

  监听一个自定义事件，但是只触发一次。一旦触发之后，监听器就会被移除。

```js
  /**
   * 只监听一次事件处理流程
   * 1、$on 注册事件处理流程
   * 2、监听过后，取消监听，执行函数
   * @param {*} event 
   * @param {*} fn 
   */
  Vue.prototype.$once = function (event: string, fn: Function): Component {
    const vm: Component = this
    function on () {
      vm.$off(event, on)
      fn.apply(vm, arguments)
    }
    on.fn = fn
    vm.$on(event, on)
    return vm
  }

```

**注意**：在源码中`$once`的实现是在回调函数中使用`fn`绑定了原回调函数的引用，在上面已经提到过的`$off`方法中也同样进行了`cb.fn === fn`的判断。

### lifecycleMixin 流程

`lifecycleMixin`主要是定义实例方法和生命周期，例如：`$forceUpdate()`、`$destroy`，另外它还定义一个`_update`的私有方法，其中当调用`$forceUpdate()`方法强制组件重新渲染时会调用这个方法，`lifecycleMixin`精简代码如下：

```js
export function lifecycleMixin (Vue) {
  // 私有方法
  Vue.prototype._update = function () {}

  // 实例方法
  Vue.prototype.$forceUpdate = function () {
    if (this._watcher) {
      this._watcher.update()
    }
  }
  Vue.prototype.$destroy = function () {}
}
```

代码分析：

- `_update()`会在组件渲染的时候调用
- `$forceUpdate()`为一个强制`Vue`实例重新渲染的方法，它的内部调用了`_update`，也就是强制组件重新编译渲染。
- `$destroy()`为组件销毁方法，在其具体的实现中，会处理父子组件的关系，事件监听，触发生命周期等操作。

### renderMixin 流程

原型上添加运行时辅助工具方法， `$nextTick`, `_render` 方法

- `$nextTick` 异步队列更新，它和 `Promise` 实现有关
- `_render` 内部方法，调用编译生成的 `render` 函数，将 `template` 模版生成 `vnode tree`

```js
export function renderMixin (Vue) {
  // 挂载各种私有方法，例如this._c，this._v等
  installRenderHelpers(Vue.prototype)
  Vue.prototype._render = function () {}

  // 实例方法
  Vue.prototype.$nextTick = function (fn) {
    return nextTick(fn, this)
  }
}
```

代码分析：

- `installRenderHelpers`：它会在`Vue.prototype`上挂载各种私有方法，例如`this._n = toNumber`、`this._s = toString`、`this._v = createTextVNode`和`this._e = createEmptyVNode`。
- `_render()`：`_render()`方法会把模板编译成`VNode`，我们会在其后的编译章节详细介绍。
- `nextTick`：就像我们之前介绍过的，`nextTick`会在`Vue`构造函数上挂载一个全局的`nextTick()`方法，而此处为实例方法，本质上引用的是同一个`nextTick`。

## Vue 实例化和挂载执行流程图


![挂载流程图](http://assets.processon.com/chart_image/6040fb5107912951ff326adb.png)


## Vue执行流程思维导图

[Vue执行流程思维导图](https://www.processon.com/view/link/605e9c67f346fb6d9eeb6c4a)


## Runtime Only VS Runtime + Compiler

当执行 `import Vue from 'vue'` 的时候，从源码入口开始初始化。 `vue` 基于源码构建有两个版本，一个是 `runtime only` (只包含运行时的版本)，另一个是 `runtime + compiler` (同时包含编译器和运行时的版本)。两个版本的区别仅在于后者包含了一个编译器，内置的编译器实现了将 `template` 模板转换编译为可执行 `javascript` 脚本的功能。

### Runtime + Compiler

一个完整的 `Vue` 版本是包含编译器的，我们可以使用 `template` 进行模板编写。编译器会自动将模板字符串编译成渲染函数的代码, 源码中就是 `render` 函数。如果你需要在客户端编译模板 (比如传入一个字符串给 `template` 选项，或挂载到一个元素上并以其 `DOM` 内部的 `HTML` 作为模板)，就需要一个包含编译器的版本。

```js
// 需要编译器的版本
new Vue({
  template: '<div>{{ hi }}</div>'
})
```

### Runtime Only

只包含运行时的代码拥有创建 `Vue` 实例、渲染并处理 `Virtual DOM` 等功能，基本上就是除去编译器外的完整代码。`Runtime Only` 的适用场景：我们在选项中通过手写 `render` 函数去定义渲染过程，这个时候并不需要包含编译器的版本便可完整执行。

```js
// 不需要编译器
new Vue({
  render (h) {
    return h('div', this.hi)
  }
})
```

## Vue 源码构建入口

当执行 `npm run dev`,  `vue` 构建的版本是 `Runtime + Compiler`, 它的入口文件是 `src/platforms/web/entry-runtime-with-compiler.js`：

```js
import Vue from './runtime/index'

// 缓存 $mount 方法
const mount = Vue.prototype.$mount
/**
 * 重写 $mount 方法，使用 compileToFunctions 编译 template 或 el 为 render 函数
 * @param {*} el
 * @param {*} hydrating
 */
Vue.prototype.$mount = function (
  el?: string | Element, // 接收字符串或 DOM 元素
  hydrating?: boolean // 是否是服务端渲染
): Component {

  //...
  // 最后重新调用缓存的 $mount方法
  return mount.call(this, el, hydrating)
}

export default Vue

```

## Vue 的入口

在上方这个构建入口 JS 的我们可以找到 Vue 的来源：`import Vue from './runtime/index'`，先来看一下这块儿的实现，它定义在 `src/platforms/web/runtime/index.js` 中：new Vue 做了什么

从上面源码分析我们知道，`new Vue` 会执行 `_init` 方法

```js
function Vue (options) {
  if (process.env.NODE_ENV !== 'production' &&
    !(this instanceof Vue)
  ) {
    warn('Vue is a constructor and should be called with the `new` keyword')
  }
  this._init(options)
}
```



`_init` 方法会进行选型合并配置，数据代理，初始化组件将当前 vm 实例添加到父类上，建立组成层级关系。初始化事件中心将父组件监听事件注册到子组件上，初始化渲染，初始化 `props`、`methods`、`data`、`computed`、`watcher`，执行生命周期钩子函数, 调用 `$mount` 手动挂载 `DOM`。


```js
Vue.prototype._init = function (options) {
  ···
  // 选项合并
  vm.$options = mergeOptions(
    resolveConstructorOptions(vm.constructor),
    options || {},
    vm
  );
  // 数据代理
  initProxy(vm);
  vm._self = vm;
  // 创建组件关联
  initLifecycle(vm);
  // 初始化事件处理
  initEvents(vm);
  // 定义渲染函数
  initRender(vm);
  // 构建响应式系统
  initState(vm);
  // 等等
  ···
  if (vm.$options.el) {
    vm.$mount(vm.$options.el);
  }
}
```

`_init` 方法进行一系列初始化过程后，执行挂载 `$mount`



### 挂载代码分析

内部真正实现挂载的方法

```js
// 内部真正实现挂载的方法
Vue.prototype.$mount = function (el, hydrating) {
  el = el && inBrowser ? query(el) : undefined;
  // 调用mountComponent方法挂载
  return mountComponent(this, el, hydrating)
};
```



如果是 `runtime + compiler` 版本的 `vue`，会走下面的逻辑，在 `$mount` 方法外再套一层，目的是添加编译器，编译器主要做三件事情：

- parse 解析器：调用 `parse ` 方法，执行 `parseHTML` 通过正则匹配将 `template` 解析为 `AST` 抽象语法树
- optimize 优化器：调用`optimize` 方法，为元素打上静态节点和根静态节点标识，目的是 `diff` 对比更新减少编译过程优化性能
- codegen 代码生成器：将 `AST` 转化为 可执行代码 `render` 函数

所以， `template` 模版经过编译后得到 `render` 函数赋值给 `options` 



```js
// 缓存了原型上的 $mount 方法
var mount = Vue.prototype.$mount;
// 重新定义$mount,为包含编译器和不包含编译器的版本提供不同封装，最终调用的是缓存原型上的$mount方法
Vue.prototype.$mount = function (el, hydrating) {
  // 获取挂载元素
  el = el && query(el);
  // 挂载元素不能为跟节点
  if (el === document.body || el === document.documentElement) {
    warn(
      "Do not mount Vue to <html> or <body> - mount to normal elements instead."
    );
    return this
  }
  var options = this.$options;
  // 需要编译 or 不需要编译
  // render选项不存在，代表是template模板的形式，此时需要进行模板的编译过程
  if (!options.render) {
    ···
    // 使用内部编译器编译模板
  }
  // 无论是template模板还是手写render函数最终调用缓存的$mount方法
  return mount.call(this, el, hydrating)
}

```

`mountComponent` 挂载组件，会实例化 `Watch`，在回调函数中执行 `updateComponent` 方法，`updateComponent` 主要做两件事

- 调用 `_render` 方法，执行 `render` 函数，得到 `vnode` 
- 调用 `_update` 方法，执行 `patch` 函数，将 `vnode` 生成真实的 `DOM` 节点



```js
// mountComponent方法思路
function mountComponent(vm, el, hydrating) {
  // 定义updateComponent方法，在watch回调时调用。
  updateComponent = function () {
    // render函数渲染成虚拟DOM， 虚拟DOM渲染成真实的DOM
    vm._update(vm._render(), hydrating);
  };
  // 实例化渲染watcher
  new Watcher(vm, updateComponent, noop, {})
}

```



## Vue 调试

`vue` 源码整个构建流程说完了，接下来就是启动项目调试，过程很简单。

`vue` 项目有个 `example` 目录，它是引用 `dist` 目录下 `vue` 文件的一些 `demo`，也可以创建一个包含 `html` 和 `js` 文件的目录，如果想直接在服务上打开 `html` 文件，可以安装 `VSC` 编译器的 `Live Server` 插件，无需安装服务软件就可以打开一个静态页面，执行 `npm` 命令痛快的打断点调试了

```bash
git clone  https://github.com/vuejs/vue.git

安装 VSC 插件 live Sever

npm install

npm run dev

断点调试
```
