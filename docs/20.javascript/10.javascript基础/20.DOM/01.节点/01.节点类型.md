---
title: 节点概述
date: 2021-04-04 19:27:01
permalink: /pages/seeesweew
author: 
  name: jeffery
categories: 
  - javascript
tags: 
  - javascript
---

# 节点概述

`DOM` (文档对象模型) 是 `javascript` 操作网页的接口，它的作用是将网页转为一个 `javascript` 对象，从而可以使用 `javascript` 对网页进行各种操作(比如增删内容)。

浏览器根据 `DOM` 模型，将 `HTML` 文档解析成一系列的节点，再由这些节点组成一个树状结构。`DOM` 的最小组成单位叫做节点(node)，**文档的树形结构(DOM树)由12种类型的节点组成**

## 节点

节点至少拥有 `nodeType`、`nodeName`和 `nodeValue` 这三个基本属性。节点类型不同，这三个属性的值也不相同

**nodeType**

`nodeType` 属性返回节点类型的常数值。不同的类型对应不同的常数值，12种类型分别对应1到12的常数值

```
元素节点            　　Node.ELEMENT_NODE(1)
属性节点            　　Node.ATTRIBUTE_NODE(2)
文本节点            　　Node.TEXT_NODE(3)
CDATA节点             Node.CDATA_SECTION_NODE(4)
实体引用名称节点    　　 Node.ENTRY_REFERENCE_NODE(5)
实体名称节点        　　Node.ENTITY_NODE(6)
处理指令节点        　　Node.PROCESSING_INSTRUCTION_NODE(7)
注释节点            　 Node.COMMENT_NODE(8)
文档节点            　 Node.DOCUMENT_NODE(9)
文档类型节点        　　Node.DOCUMENT_TYPE_NODE(10)
文档片段节点        　　Node.DOCUMENT_FRAGMENT_NODE(11)
DTD声明节点            Node.NOTATION_NODE(12)
```

`DOM` 定义了一个 `Node` 节点接口，这个接口在 `javascript` 中是作为`Node` 类型实现的，而在 `IE8-` 浏览器中的所有 `DOM` 对象都是以 `COM` 对象的形式实现的。所以，IE8-浏览器并不支持 `Node` 对象的写法

```
//在标准浏览器下返回1，而在IE8-浏览器中报错，提示Node未定义
console.log(Node.ELEMENT_NODE);//1
```

**nodeName**

`nodeName` 属性返回节点的名称

**nodeValue**

`nodeValue` 属性返回或设置当前节点的值，格式为字符串

 

## 元素节点

元素节点 `element` 对应网页的 `HTML` 标签元素。

元素节点的三个 `node` 属性—— `nodeType`、`nodeName`、`nodeValue` 分别是1、元素的大写标签名和null，其父节点 `parentNode` 指向包含该元素节点的元素节点 `Element` 或文档节点`Document`

::: tip
要访问元素的标签名可以使用 `nodeName`，也可以使用 `tagName` 属性，这两个属性会返回相同的值
:::


```html
<div id="test">123</div>
<script>
console.log(test.nodeType);//1
console.log(test.nodeName);//'DIV'
console.log(test.nodeValue);//null
console.log(test.parentNode);//<body>
console.log(test.childNodes);//[text]
console.log(test.tagName,test.tagName === test.nodeName);//'DIV' true
</script>
```

### 子节点

元素可以有任意数目的子节点和后代节点，因为元素可以是其他元素的子节点。元素的 `childNodes` 属性中包含了它的所有子节点，这些子节点可能是元素、文本、注释、处理指令节点

### 元素节点-属性操作

每个元素都有一个或多个特性，这些特性的用途是给出相应元素或其内容的附加信息。操作特性的 `DOM` 方法主要有 `hasAttribute()` 、`getAttribute()`、`setAttribute()`、`removeAttribute()` 四个

**hasAttribute()**

`hasAttribute()` 方法返回一个布尔值，表示当前元素节点是否包含指定属性

[注意]IE7-浏览器不支持 `hasAttribute()` 方法

```html
<div id="test" class="class1"></div>
<script>
console.log(test.hasAttribute('class'));//true
console.log(test.hasAttribute('title'));//false
</script>
```

**getAttribute()**

`getAttribute()` 方法用于取得特性的值，如果给定名称的特性不存在或无参数则返回 `null`

```html
<div id="test" class="class1"></div>
<script>
console.log(test.getAttribute('class'));//'class1'
console.log(test.getAttribute('title'));//null
</script>
```

**setAttribute()**

`setAttribute()` 方法接受两个参数：要设置的特性名和值，如果已经存在，则替换现有的值。如果特性不存在，`setAttribute()` 则创建该属性并设置相应的值。该方法无返回值

```html
<div id="box">123</div>
<script>
var oBox = document.getElementById('box');
oBox.setAttribute("id","test");
//注意获取oBox.id时并不会报错，因为oBox保存的是当时id为box的对象，也就是现在id为test的对象
console.log(oBox.id);//test
</script>
```

::: tip
通过 `setAttrbute()` 方法设置的特性名会统一转换成小写形式
:::

```html
<div id="box">123</div>
<script>
var oBox = document.getElementById('box');
oBox.setAttribute("ABC","test");
console.log(oBox.getAttribute("ABC"));//test
console.log(oBox.getAttribute("abc"));//test
</script>
```

**removeAttribute()**

`removeAttribute()` 方法用于彻底删除元素的特性，这个方法不仅会彻底删除元素的特性值，还会删除元素特性。该方法无返回值

```html
<div class="box" id="box"></div>
<script>
var oBox = document.getElementById('box');
console.log(oBox.getAttribute("id"));//box
console.log(oBox.removeAttribute("id"));//undefined
console.log(oBox.getAttribute("id"));//null    
</script>
```

### attributes属性

元素节点 `Element` 是唯一一个使用 `attributes` 属性的 `DOM` 节点类型。`attributes` 属性中包含一个 `NamedNodeMap`，与 `NodeList` 类似，也是一个动态的集合。元素的每一个特性都由一个 `Attr` 节点表示，每个节点都保存在 `NamedNodeMap` 对象中，每个节点的 `nodeName` 就是特性的名称，节点的 `nodeValue` 就是特性的值

`attributes` 属性包含以下四个方法

**getNamedItem(name)**

`getNamedItem(name)` 方法返回 `nodeName` 属性等于 `name` 的节点

```html
<div class="box" id="box" name="abc" index="123" title="test"></div>
<script>
var oBox = document.getElementById('box');
console.log(oBox.attributes);//NamedNodeMap {0: class, 1: id, 2: name, 3: index, 4: title}
console.log(oBox.attributes.getNamedItem("index"));//index='123'
console.log(oBox.attributes.getNamedItem("index").nodeName);//'index'
console.log(oBox.attributes.getNamedItem("index").nodeValue);//'123'
console.log(oBox.attributes.index);//index='123'
</script>
```

**removeNamedItem(name)**

`removeNamedItem(name)` 方法从列表中移除 `nodeName` 属性等于 `name` 的节点，并返回该节点

```html
<div class="box" id="box" name="abc" index="123" title="test"></div>
<script>
var oBox = document.getElementById('box');
console.log(oBox.attributes);//NamedNodeMap {0: class, 1: id, 2: name, 3: index, 4: title}
console.log(oBox.attributes.getNamedItem("index"));//index='123'
console.log(oBox.attributes.removeNamedItem("index"));//index='123'
console.log(oBox.attributes.getNamedItem("index"));//null
</script>
```

**setNamedItem(node)**

`setNamedItem(node)` 方法向列表中添加节点，该方法无返回值

```html
<div class="box" id="box" name="abc" index="123" title="test"></div>
<script>
var oBox = document.getElementById('box');
console.log(oBox.attributes);//NamedNodeMap {0: class, 1: id, 2: name, 3: index, 4: title}
var oldItem = oBox.attributes.removeNamedItem("index");
console.log(oBox.attributes.getNamedItem("index"));//null
console.log(oldItem);//index='123'
console.log(oBox.attributes.setNamedItem(oldItem));//null
console.log(oBox.attributes.getNamedItem("index"));//index='123'
</script>
```

**item(pos)**

`item(pos)` 方法返回位于数字 `pos` 位置处的节点，也可以用方括号法[]简写

```html
<div class="box" id="box" name="abc" index="123" title="test"></div>
<script>
var oBox = document.getElementById('box');
console.log(oBox.attributes);//NamedNodeMap {0: class, 1: id, 2: name, 3: index, 4: title}
console.log(oBox.attributes.item(2));//name="abc"
console.log(oBox.attributes[2]);//name="abc"
</script>
```

**遍历**

`attributes` 属性主要用于特性遍历。在需要将 `DOM` 结构序列化为 `HTML` 字符串时，多数都会涉及遍历元素特性

```js
function outputAttributes(element){
    var pairs = new Array(),
      attrName,
      attrValue

    for(let i = 0,len=element.attributes.length;i<len;i++){
        attrName = element.attributes[i].nodeName;
        attrValue = element.attributes[i].nodeValue;
        pairs.push(attrName +"=\"" + attrValue + "\"");
    }
    return pairs.join(" ");
}
```

针对 `attributes` 对象中的特性，不同浏览器返回的顺序不同

```html
<div class="box" id="box" name="abc" index="123" title="test"></div>
<script>
function outputAttributes(element){
    var pairs = new Array(),
      attrName,
      attrValue

    for(let i = 0,len=element.attributes.length;i<len;i++){
        attrName = element.attributes[i].nodeName;
        attrValue = element.attributes[i].nodeValue;
        pairs.push(attrName +"=\"" + attrValue + "\"");
    }
    return pairs.join(" ");
}
//(chrome\safari)class="box" id="box" name="abc" index="123" title="test"
//(firefox)title="test" index="123" name="abc" id="box" class="box"
//(IE8+)title="test" class="box" id="box" index="123" name="abc"
//(IE7-)输出所有的特性
console.log(outputAttributes(document.getElementById("box")))
</script>
```

## 特性节点

元素的特性在 `DOM` 中以 `Attr` 类型表示，对应网页中 `HTML` 标签的属性，存在于元素的 `attributes` 属性中，它并不是 `DOM` 文档树的一部分。

### 特征

特性节点的三个 `node` 属性———— `nodeType`、`nodeName`、`nodeValue` 分别是2、特性名称和特性值，其父节点 `parentNode` 是`null`

::: tip
关于特性节点是否存在子节点，各个浏览器表现不一致
:::

```html
<div id="box"></div>
<script>
var oBox = document.getElementById('box');
var oAttr = oBox.attributes;
//(chrome\safari\IE9+\firefox) 2 id box null
//(IE7-) 2 onmsanimationiteration null null
console.log(oAttr[0].nodeType,oAttr[0].nodeName,oAttr[0].value,oAttr[0].parentNode)
//(chrome\firefox) undefined
//(safari) Text
//(IE9+) box
//(IE8-) 报错
console.log(oAttr[0].childNodes[0])
</script> 
```


现在，`div` 元素有 `id="test"` 的属性

```js
<div id="test"></div>
<script>
var attr = test.attributes.id;
//2 'id' 'test'
console.log(attr.nodeType,attr.nodeName,attr.nodeValue)
console.log(Node.ATTRIBUTE_NODE === 2);//true    
</script>
```

 

### 属性

`Attr` 特性节点有3个属性：`name`、`value` 和 `specified`

**name**　

`name` 是特性名称，与 `nodeName` 的值相同

**value**

`value` 是特性的值，与 `nodeValue` 的值相同

**specified**

`specified` 是一个布尔值，用以区别特性是在代码中指定的，还是默认的。这个属性的值如果为 `true`，则意味着要么是在 `HTML` 中指定了相应特性，要么是通过 `setAttribute()` 方法设置了该属性。在IE中，所有未设置过的特性的该属性值都为 `false`，而在其他浏览器中，所有设置过的特性的该属性值都是 `true` ，未设置过的特性，如果强行为其设置 `specified`属性，则报错。因为 `undefied` 没有属性

### 方法

**createAttribute()**

`createAttribute()` 方法传入特性名称并创建新的特性节点

**setAttributeNode()**

`setAttributeNode()` 方法传入特性节点并将特性添加到元素上，无返回值

**getAttributeNode()**

`getAttributeNode()` 方法传入特性名并返回特性节点

**removeAttributeNode()**

`removeAttributeNode()` 方法传入特性名删除并返回删除的特性节点，但IE7-浏览器下无法删除

```html
<div id="box"></div>
<script>
var oBox = document.getElementById('box');
var attr = document.createAttribute('title');
attr.value = "test";
console.log(oBox.setAttributeNode(attr));//null
console.log(oBox.getAttributeNode("title").name, attr.name);//title title
console.log(oBox.getAttributeNode("title").value,attr.value);//test test
//返回删除的节点
console.log(oBox.removeAttributeNode(attr));
//IE7-浏览器下无法删除，其他浏览器返回null
console.log(oBox.getAttributeNode("title"));
</script>
```

#### 小结

特性节点在12种节点类型中排行老二，但是其属性和方法并不常用，因为元素节点都有对应的可替代的方法，而且使用起来更为方便。特性是节点，但不存在 `DOM` 树中



## 文本节点

文本节点 `text` 代表网页中的 `HTML` 标签内容。文本节点的节点类型`nodeType` 值是3，节点名称 `nodeName` 值是 `#text`，`nodeValue` 值是标签内容值

```html
<div id="box">test</div>
<script>
var oTxt = box.firstChild;
console.log(oTxt.nodeType);//3
console.log(oTxt.nodeValue);//test
console.log(oTxt.nodeName);//'#text'
console.log(oTxt.parentNode);//<div>
console.log(oTxt.childNodes);//[]
</script>
</script>
```

 ### 空白文本节点

 关于文本节点，遇到最多的兼容问题是空白文本节点问题。IE8-浏览器不识别空白文本节点，而其他浏览器会识别空白文本节点

 ```html
<div id="box">
    <div>1</div>
</div>
<script>
//标准浏览器输出[text, div, text]，text表示空白文本节点
//IE8-浏览器输出[div]，并不包含空白文本节点
console.log(box.childNodes);    
</script>

 ```

### 方法

**createTextNode()**

`createTextNode()` 方法用于创建文本节点，这个方法接收一个参数——要插入节点中的文本

```html
<div id="box">123</div>
<script>
var oBox = document.getElementById('box');
var oText = document.createTextNode('<strong>hello</strong> world!');
oBox.appendChild(oText);
//'123&lt;strong&gt;hello&lt;/strong&gt; world!'
console.log(oBox.innerHTML);
//此时，页面中有两个文本节点
console.log(oBox.childNodes.length);
</script>
```

**normalize()**

`normalize()` 方法的作用是合并相邻的文本节点，该方法在文本节点的父节点——元素节点上调用

[注意]IE9+浏览器无法正常使用该方法

```html
<div id="box">0</div>
<script>
var oText1 = document.createTextNode('1');
var oText2 = document.createTextNode('2');
box.appendChild(oText1);
box.appendChild(oText2);
console.log(box.childNodes);//[text, text, text]
console.log(box.childNodes.length);//3
box.normalize();
//IE9+浏览器返回[text,text]，而其他浏览器返回[text]
console.log(box.childNodes);
//IE9+浏览器返回'01'，而其他浏览器返回'012'
console.log(box.childNodes[0]);
//IE9+浏览器返回2，使用该方法时只能将所有的文本节点减1；其他浏览器正常，返回2
console.log(box.childNodes.length);//1
</script>
```

**splitText()**

与 `normalize()` 方法作用相反，`splitText()` 方法将一个文本节点分成两个文本节点，即按照指定的位置分割 `nodeValue` 值。原来的文本节点将包含从开始到指定位置之前的内容。这个方法会返回一个新文本节点，包含剩下的文本。`splitText()` 方法返回的节点与原节点的 `parentNode` 相同 

```html
<div id="box">123</div>
<script>
var oBox = document.getElementById('box');
var newNode = oBox.firstChild.splitText(1);
console.log(newNode,newNode === oBox.lastChild);//'23' true
console.log(oBox.firstChild);//'1'
</script>
```

**appendData()**

`appendData(text)` 方法将 `text` 添加到节点的末尾，该方法无返回值

```html
<div id="box">123</div>
<script>
var oBox = document.getElementById('box');
var oText = oBox.firstChild;
console.log(oText.appendData('4'));//undefined
console.log(oText.data);//'1234'
console.log(oBox.childNodes.length);//1
</script>
```

**deleteData()**

`deleteData(offset,count)` 方法从 `offset` 指定的位置开始删除`count` 个字符，无返回值

```html
<div id="box">123</div>
<script>
var oBox = document.getElementById('box');
var oText = oBox.firstChild;
console.log(oText.deleteData(0,2));//undefined
console.log(oText.data);//'3'
console.log(oBox.childNodes.length);//1
</script>
```

**insertData()**

`insertData(offset,text)` 方法在 `offset` 指定的位置插入 `text`，无返回值

```html
<div id="box">123</div>
<script>
var oBox = document.getElementById('box');
var oText = oBox.firstChild;
console.log(oText.insertData(1,'test'));//undefined
console.log(oText.data);//'1test23'
console.log(oBox.childNodes.length);//1
</script>
```

**replaceData()**

`replaceData(offset,count,text)` 方法用 `text` 替换从 `offset`指定位置开始到 `offset+count` 为止的文本，无返回值

```html
<div id="box">123</div>
<script>
var oBox = document.getElementById('box');
var oText = oBox.firstChild;
console.log(oText.replaceData(1,1,"test"));//undefined
console.log(oText.data);//'1test3'
console.log(oBox.childNodes.length);//1
</script>
```

**substringData()**

`substringData(offset,count)` 方法提取从 `offset` 指定的位置开始到 `offset+count` 为止处的字符串，并返回该字符串。原来的文本节点无变化

```html
<div class="box" id="box">123</div>
<script>
var oBox = document.getElementById('box');
var oText = oBox.firstChild;
console.log(oText.substringData(1,1));//'2'
console.log(oText);//'123'
</script>
```

## CDATA节点

`CDATASection` 类型只针对基于 `XML` 的文档，只出现在 `XML` 文档中，表示的是 `CDATA` 区域，格式一般为

```html
<![CDATA[]]>
```

该类型节点的节点类型 `nodeType` 的值为 4，节点名称 `nodeName` 的值为 `#cdata-section`，`nodevalue` 的值是 `CDATA` 区域中的内容

## 注释节点

注释在 `DOM` 中是通过 `Comment` 类型来表示，注释节点的三个 `node` 属性—— `nodeType`、`nodeName`、`nodeValue`分别是 `8`、`#comment`和注释的内容，其父节点 `parentNode` 可能是 `Document` 或 `Element`，注释节点没有子节点

```html
<body><!-- 我是注释-->
<script>
var oComment = document.body.firstChild;
//#comment 8 我是注释
console.log(oComment.nodeName,oComment.nodeType,oComment.nodeValue)
//<body> []
console.log(oComment.parentNode,oComment.childNodes)
</script>
```

### 属性

注释节点 `Comment` 与 `文本节点Text` 继承自相同的基类，因此它拥有除了 `splitText()` 之外的所有字符串操作方法。与 `Text` 类型相似，也可以通过 `nodeValue` 或 `data` 属性来取得注释的内容

**data**

注释节点的 `data` 属性与 `nodeValue` 属性相同

**length**

注释节点的 `length` 属性保存着节点字符的数目，而且 `nodeValue.length`、`data.length`也保存着相同的值

```html
<body><!--我是注释-->
<script>
var oComment = document.body.firstChild;
//我是注释   我是注释  true
console.log(oComment.nodeValue,oComment.data,oComment.data == oComment.nodeValue);
//4 4 4
console.log(oComment.length,oComment.nodeValue.length,oComment.data.length);
</script>
</body>
```

### 方法

**createComment()**

`createComment()` 方法用于创建注释节点，这个方法接收一个参数——要插入节点中的注释文本

```js
var oComment = document.createComment('hello world!');
var oBase = document.body.firstChild;
document.body.insertBefore(oComment,oBase);
//<!--hello world!-->
console.log(document.body.firstChild);
```

**appendData()**

`appendData(text)` 方法将 `text` 添加到节点的末尾

```html
<body><!--我是注释-->
<script>
var oComment = document.body.firstChild;
console.log(oComment.data);//我是注释
console.log(oComment.appendData('test'));//undefined
console.log(oComment.data);//我是注释test
</script>
</body>
```

**deleteData()**

`deleteData(offset,count)` 方法从 `offset` 指定的位置开始删除`count`个字符

```html
<body><!--我是注释-->
<script>
var oComment = document.body.firstChild;
console.log(oComment.data);//我是注释
console.log(oComment.deleteData(0,1));//undefined
console.log(oComment.data);//是注释
</script>
</body>
```

**insertData()**

`insertData(offset,text)` 方法在 `offset` 指定的位置插入 `text`

```html
<body><!--我是注释-->
<script>
var oComment = document.body.firstChild;
console.log(oComment.data);//我是注释
console.log(oComment.insertData(1,"test"));//undefined
console.log(oComment.data);//我test是注释
</script>
</body>
```

**replaceData()**

`replaceData(offset,count,text)` 方法用 `text` 替换从 `offset` 指定的位置开始到 `offset+count` 处为止处的文本

```html
<body><!--我是注释-->
<script>
var oComment = document.body.firstChild;
console.log(oComment.data);//我是注释
console.log(oComment.replaceData(1,1,"test"));//undefined
console.log(oComment.data);//我test注释
</script>
</body>
```

**substringData()**

`substringData(offset,count)` 方法提取从 `offset` 指定的位置开始到 `offset+count` 为止处的字符串

```html
<body><!--我是注释-->
<script>
var oComment = document.body.firstChild;
console.log(oComment.data);//我是注释
console.log(oComment.substringData(1,1));//是
console.log(oComment.data);//我是注释
</script>
</body>    
```

## 文档类型节点

文档类型节点 [DocumentType] 包含着与文档的 `doctype` 有关的所有信息。文档类型节点的节点类型 `nodeType` 的值为 10，节点名称 `nodeName` 的值为 `doctype` 的名称，`nodeValue` 的值为 `null`, 其父节点 `parentNode` 是 `Document`，文档类型节点没有子节点

```html
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Document</title>
</head>
<body>
<script>
var nodeDocumentType = document.firstChild;
//10 "html" null
console.log(nodeDocumentType.nodeType,nodeDocumentType.nodeName,nodeDocumentType.nodeValue);
console.log(Node.DOCUMENT_TYPE_NODE === 10);
</script>
</body>
</html>
```

文档类型节点有一个快捷写法是 `document.doctype`

【属性】

文档类型节点 `DocumentType` 对象有3个属性: `name`、`entities`、`notations`

**name**

`name` 表示文档类型的名称，与 `nodeName` 的属性相同

**entities**

`entities` 表示由文档类型描述的实体的 `NamedNodeMap` 对象

**notations**

`notations` 表示由文档类型描述的符号的 `NamedNodeMap` 对象

通常浏览器中的文档使用的都是 `HTML` 或 `XHTML` 文档类型，因而`entites`和`notations`都是空列表(列表中的项来自行内文档类型声明)

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Document</title>
</head>
<body>
<script>
//IE8-浏览器不支持document.doctype
var oDoctype = document.doctype;
if(oDoctype){
    console.log(oDoctype.name,oDoctype.name=== oDoctype.nodeName);//html true
    console.log(oDoctype.entities,oDoctype.notations);//undefined undefined
}
</script>
</body> 
</ht
```

## 文档节点

文档节点 `document` 表示 `HTML` 文档，也称为根节点，指向 `document` 对象。文档节点的节点类型`nodeType` 的值为9，节点名称`nodeName` 的值为 `#documen`，`nodeValue` 的值为 `null`, 其父节点 `parentNode` 指向 `null`，`ownerDocument` 也指向 `null`

```js
console.log(document.nodeType);//9
console.log(document.nodeValue);//null
console.log(document.nodeName);//'#document'
console.log(document.parentNode);//null
console.log(document.ownerDocument);//null
```

### 快捷访问

**子节点**

【1】`<html>`

`document.documentElement` 属性始终指向 `HTML` 页面中的 `<html>`元素　

```js
console.log(document.documentElement.nodeName);//'HTML'
```

【2】 `<body>`

`document.body` 属性指向 `<body>` 元素

```js
console.log(document.body.nodeName);//'BODY'
```

【3】`<!DOCTYPE>`

`document.doctype` 属性指向 `<!DOCTYPE>` 标签

[注意]IE8-不识别，输出null，因为IE8-浏览器将其识别为注释节点

```js
console.log(document.doctype.nodeName);//'html'
```

【4】`<head>`

`document.head` 属性指向文档的 `<head>` 元素

[注意]IE8-浏览器下不支持

```js
console.log(document.head.nodeName);//'HEAD'
```

**文档信息**

【1】`title`

`<title>` 元素显示在浏览器窗口的标题栏或标签页上，`document.title` 包含着 `<title>` 元素中的文本，这个属性可读可写

```js
console.log(document.title);//Document
document.title="test";
console.log(document.title);//test
```

【2】`URL`、`domain`、`referrer`

- URL：页面的完整地址

- domain：domain与URL是相互关联的，包含页面的域名

- referrer：表示链接到当前页面的上一个页面的URL，在没有来源页面时，可能为空

::: tip
上面这些信息都来自请求的HTTP头部，只不过可以通过这三个属性在 javascript中访问它而已
:::

```js
console.log(document.URL);
console.log(document.domain);
console.log(document.referrer);
```

在这3个属性中，只有 `domain` 是可以设置的。但由于安全方面的限制，也并非可以给 `domain` 设罝任何值。如果 `URL` 中包含一个子域名，例如 `kaifa.baidu.com` ,那么就只能将 `domain` 设置为 `baidu.com`。不能将这个属性设置为 `URL` 中不包含的域

```js
document.domain = 'baidu.com';//"cnblogs.com"
//Uncaught DOMException: Failed to set the 'domain' property on 'Document': 'qq.com' is not a suffix of 'cnblogs.com'
document.domain = 'qq.com';
```

【3】baseURI

`document.baseURI` 返回 `<base>` 标签中的 `URL`，如果没有设置 `<base>`，则该值与 `document.URL` 相同

```js
console.log(document.baseURI);'//http://www.github.com/jeffery/'

<base href="http://www.baidu.com"> 
<script>
console.log(document.baseURI);//'http://www.baidu.com/'
</script>
```

【4】字符集charset

`document.charset` 表示文档中实际使用的字符集

```js
console.log(document.charset);//'UTF-8'
```

【5】defaultView

`document.defaultView` 保存着一个指针，指向拥有给定文档的窗口或框架。IE8-浏览器不支持` defaultView` 属性，但IE中有一个等价的属性名叫`parentWindow`。所以要确定文档的归属窗口，其兼容写法为：　　

```js
var parentWindow = document.defaultView || document.parentWindow;//Window
```

【6】兼容模式compatMode

`document.compatMode` 表示文档的模式，在标准模式下值为 `CSS1Compat`，在兼容模式下值为 `BackCompat`

```js
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Document</title>
</head>
<body>
<script>
console.log(document.compatMode)//CSS1Compat
</script>
</body>
</html>  

// 声明不同
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Document</title>
</head>
<body>
<script>
console.log(document.compatMode)//BackCompat
</script>
</body>
</html> 
```

【7】文档模式documentMode

`document.documentMode` 属性表示当前的文档模式

[注意]该属性只有IE11-浏览器支持

```js
//IE11返回11，IE10返回10，IE9返回9，IE8返回8，IE7返回7，IE6返回6
console.log(document.documentMode);
```

【8】时间戳lastModified

`document.lastModified` 属性返回当前文档最后修改的时间戳，格式为字符串

```js
console.log(document.lastModified); //09/02/2016 15:36:15
```

**节点集合**

【1】anchors

`document.anchors` 包含文档中所有带 `name` 特性的 `<a>` 元素

```js
<a href= "#" name="a1">a1</a>
<a href= "#" name="a2">a2</a>
<a href= "#" >3</a>
<script>
console.log(document.anchors.length)//2
</script>
```

【2】links

`document.links` 包含文档中所有带 `href` 特性的 `<a>` 元素

```js
<a href="#">1</a>
<a href="#">2</a>
<a>3</a>
<script>
console.log(document.links.length)//2
</script>
```

【3】forms

`document.forms` 包含文档中所有的 `<form>`元素，与 `document.getElementsByTagName("form")` 结果相同

```js
<form action="#">1</form>
<form action="#">2</form>
<script>
console.log(document.forms.length)//2
</script>
```

【4】images

`document.images` 包含文档中所有的 `<img>` 元素，与 `document.getElementsByTagName('img')` 结果相同

```js
<img src="#" alt="#">
<img src="#" alt="#">
<script>
console.log(document.images.length)//2
</script>
```

【5】scripts

`document.scripts` 属性返回当前文档的所有脚本(即 `script` 标签)

```js
<script>
console.log(document.scripts.length)//1
</script>
```

以上五个属性返回的都是 `HTMLCollection` 对象实例

```js
console.log(document.links instanceof HTMLCollection); // true
console.log(document.images instanceof HTMLCollection); // true
console.log(document.forms instanceof HTMLCollection); // true
console.log(document.anchors instanceof HTMLCollection); // true
console.log(document.scripts instanceof HTMLCollection); // true
```

由于 `HTMLCollection` 实例可以用 `HTML` 元素的 `id` 或 `name` 属性引用，因此如果一个元素有 `id` 或 `name` 属性，就可以在上面这五个属性上引用

```js
<form name="myForm">
<script>
console.log(document.myForm === document.forms.myForm); // true    
</script>
```


### 文档写入方法

将输出流写入到网页的能力有4个方法：`write()`、`writeln()`、`open()`、`close()`

**write()和writeln()**

`write()`和`writeln()`方法都接收一个字符串参数，即要写入到输出流中的文本

`write()`会原样写入，而`writeln()`则在字符串的末尾添加一个换行符 `\n`，但换行符会被页面解析为空格

在页面被加载的过程中，可以使用这两个方法向页面中动态地加入内容

```html
<button id="btn">替换内容</button>
<script>
btn.onclick = function(){
    document.write('123');
    document.writeln('abc');
    document.write('456');
}    
</script>
```

**open()和close()**

`open()`和`close()`方法分别用于打开和关闭网页的输出流

`open()` 方法实际上等于清除当前文档

```html
<button id="btn">清除内容</button>
<script>
btn.onclick = function(){
    document.open();
}    
</script>
```

`close()` 方法用于关闭 `open` 方法所新建的文档。一旦关闭，`write` 方法就无法写入内容了。如果再调用 `write` 方法，就等同于又调用 `open方法`，新建一个文档，再写入内容。所以，实际上，`close()`只是和`open()`方法配套使用而已

```js
<button id="btn">替换内容</button>
<script>
//相当于'123'又把'1'覆盖了
btn.onclick = function(){
    document.open();
    document.write('1');
    document.close();
    document.write('123');
}    
</script>
```


一般地，先使用 `open()`方法用于新建一个文档，然后使用`write()`和`writeln()`方法写入文档，最后使用`close()`方法，停止写入

```html
<button id="btn">替换内容</button>
<script>
btn.onclick = function(){
    document.open();
    document.writeln('hello');
    document.write('world');
    document.close();    
}
</script>    
```

[注意]如果是在页面加载期间使用 `write()` 和 `writeln()` 方法，则不需要用到这两个方法 

```html
<button id="btn">内容</button>
<script>
document.writeln('hello');
document.write('world');
</script>    
```

## 文档片段节点

文档片段节点 `DocumentFragment` 在文档中没有对应的标记，是一种轻量级的文档，可以包含和控制节点，但不会像完整的文档那样占用额外的资源。

### 特征

创建文档片段，要使用 `document.createDocumentFragment()`方法。文档片段继承了 `Node` 的所有方法，通常用于执行那些针对文档的 `DOM` 操作

文档片段节点的三个 `node` 属性—— `nodeType`、`nodeName`、`nodeValue`分别是11、`#document-fragment` 和 `null`，文档片段节点没有父节点 `parentNode`

```js
var frag = document.createDocumentFragment();
console.log(frag.nodeType);//11
console.log(frag.nodeValue);//null
console.log(frag.nodeName);//'#document-fragment'
console.log(frag.parentNode);//null
```

### 作用

我们经常使用 `javascript` 来操作 `DOM` 元素，比如使用 `appendChild()`方法。每次调用该方法时，浏览器都会重新渲染页面。如果大量的更新 `DOM`节点，则会非常消耗性能，影响用户体验

`javascript` 提供了一个文档片段 `DocumentFragment` 的机制。如果将文档中的节点添加到文档片段中，就会从文档树中移除该节点。把所有要构造的节点都放在文档片段中执行，这样可以不影响文档树，也就不会造成页面渲染。当节点都构造完成后，再将文档片段对象添加到页面中，这时所有的节点都会一次性渲染出来，这样就能减少浏览器负担，提高页面渲染速度


```html
<ul id="list1"></ul>
<script>
var list1 = document.getElementById('list1');
console.time("time");
var fragment = document.createDocumentFragment();
for(var i = 0; i < 500000; i++){
    fragment.appendChild(document.createElement('li'));
}
list1.appendChild(fragment);
console.timeEnd('time');
</script>

<ul id="list"></ul>
<script>
var list = document.getElementById('list');
console.time("time");
for(var i = 0; i < 500000; i++){
    list.appendChild(document.createElement('li'));
}
console.timeEnd('time');
</script>
```

循环50万次的各浏览器结果

```
           　　 使用文档片段        　　不使用文档片段
firefox        402.04ms              469.31ms
chrome         429.800ms             729.634ms
```

循环10万次的各浏览器结果

```
            　　使用文档片段        　　不使用文档片段
IE11        　　2382.15ms             2204.47ms
IE10        　　2404.239ms            2225.721ms
IE9             2373ms                 2255ms
IE8             4464ms                 4210ms
IE7             5887ms                 5394ms
```

由以上结果可以看出，若使用 `IE` 浏览器，则使用文档片段 `DocumentFragment` 的性能并不会更好，反而变差；若使用 `chrome` 和`firefox`浏览器，使用文档片段 `DocumentFragment` 可以提升性能

### DTD声明节点

`DTD`声明节点`notation`代表`DTD`中声明的符号。该节点的节点类型`nodeType`的值为12，节点名称`nodeName`的值为符号名称，`nodeValue`的值为`null`

 

## 最后

`DOM` 共有12种节点类型。其中，常用的有 `Element`元素节点、`Attribute`特性节点、`Text`文本节点、`Comment`注释节点、`Document`文档节点和`DocumentFragment`文档片段节点