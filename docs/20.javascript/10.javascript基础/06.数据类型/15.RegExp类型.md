---
title: RegExp 正则表达式
date: 2021-01-14 16:13:03
permalink: /pages/safaeegjjasweew
author: 
  name: jeffery
categories: 
  - javascript
  - 数据类型
tags: 
  - javascript
  - 数据类型
---

# RegExp 正则表达式

## 定义

正则表达式是一门简单语言的语法规范，是强大、便捷、高效的文本处理工具，它应用在一些方法中，对字符串中的信息实现查找、替换和提取操作

`javascript` 中的正则表达式用 `RegExp` 对象表示，有两种写法：一种是字面量写法；另一种是构造函数写法

正则表达式的匹配模式支持下列3个标志：

- `g` : 表示全局(global)模式，即模式将被应用于所有字符串，而并非在发现第一个匹配项时立即停止

- `i`: 表示不区分大小写(case-insensitive)模式，即在确定匹配项时忽略模式与字符串的大小写

- `m`: 表示多行(multiline)模式，即在到达一行文本末尾时还会继续查找下一行中是否存在与模式匹配的项

```js
//匹配字符串所有'at'的实例
var p = /at/g;
//test()方法返回一个布尔值表示是否可以找到匹配项
console.log(p.test('ata'));//true
console.log(p.test('aba'));//false
```

## RegExp 属性

### 实例属性

每个 `RegExp` 实例对象都包含如下5个属性

```
global:  布尔值，表示是否设置了g标志
ignoreCase:  布尔值，表示是否设置了i标志
lastIndex:   整数，表示开始搜索下一个匹配项的字符位置，从0算起
multiline:   布尔值，表示是否设置了标志m
source:  正则表达式的字符串表示，按照字面量形式而非传入构造函数中的字符串模式返回
```

举例：
```js
var pattern = new RegExp('\\[bc\\]at','i');
console.log(pattern.global);//false
console.log(pattern.ignoreCase);//true    
console.log(pattern.multiline);//false
console.log(pattern.lastIndex);//0
console.log(pattern.source);//'\[bc\]at'
```

如果使用 `RegExp` 的 `exec()` 或 `test()` 函数，并且设定了全局模式 `'g'`，正则表达式的匹配就会从 `lastIndex` 的位置开始，并且在每次匹配成功之后重新设定 `lastIndex`。这样，就可以在字符串中重复迭代，依次寻找各个匹配结果。

但是，如果需要对不同字符串调用同一个 `RegExp` 的 `exec()` 或 `test()` 方法，这个变量也可能会带来意料之外的匹配结果，所以在更换字符串时，要显式地将 `RegExp` 的 `lastIndex` 置为 `0`

```js
//exec()方法以数组形式返回匹配项
var p = /\w/g;
var s = 'ab';
console.log(p.lastIndex);//0
console.log(p.exec(s));//['a']
console.log(p.lastIndex);//1
console.log(p.exec(s));//['b']
console.log(p.lastIndex);//2
console.log(p.exec(s));//null
console.log(p.lastIndex);//0
```

### 构造函数属性

`RegExp` 构造函数属性被看成静态属性，这些属性基于所执行的最近一次正则表达式操作而变化

有两种方式访问它们，即长属性名和短属性名
```
长属性名        短属性名       　　　　     说明
input             $_                最近一次要匹配的字符串
lastMatch         $&                最近一次的匹配项
lastParen         $+                最近一次匹配的捕获组
leftContext       $`                input字符串中lastMatch之前的文本
multiline         $*                布尔值，表示是否所有表达式都使用多行模式
rightContext      $'                input字符串中lastMatch之后的文本
```

使用这些属性，可以从exec()方法或test()方法执行的操作中提取出更具体的信息

```js
//test()用于测试一个字符串是否匹配某个正则表达式，并返回一个布尔值
var text = 'this has been a short summer';
var pattern = /(.)hort/g;
if(pattern.test(text)){
    console.log(RegExp.input);//'this has been a short summer'
    console.log(RegExp.leftContext);//'this has been a '
    console.log(RegExp.rightContext);//' summer'
    console.log(RegExp.lastMatch);//'short'
    console.log(RegExp.lastParen);//'s'
    console.log(RegExp.multiline);//false
    console.log(RegExp['$_']);//'this has been a short summer'
    console.log(RegExp['$`']);//'this has been a '
    console.log(RegExp["$'"]);//' summer'
    console.log(RegExp['$&']);//'short'
    console.log(RegExp['$+']);//'s'
    console.log(RegExp['$*']);//false        
}
```

## 方法

RegExp对象的实例方法共5个

对象通用方法3个

`RegExp` 对象继承了 `Object` 对象的通用方法 `toString()`、`toLocaleString()`、`valueOf()`这三个方法

`test()`、`exec()` 正则匹配方法2个


### exec()

`exec()` 方法专门为捕获组而设计，接受一个参数，即要应用模式的字符串。然后返回包含匹配项信息的数组，在没有匹配项的情况下返回 `null`

数组包含两个额外的属性：`index` 和 `input` 。`index` 表示匹配项在字符串的位置，`input` 表示应用正则表达式的字符串

```js
var text = 'mom and dad and baby and others';
var pattern = /mom( and dad( and baby)?)?/gi;
var matches = pattern.exec(text);
console.log(matches);

//matches[0]:'mom and dad and baby'
//matches[1]:' and dad and baby'
//matches[2]:' and baby'
//matches.index:0
//matches.input:'mom and dad and baby and others'   
```

对于 `exec()` 方法而言，即使在模式中设置了全局标志(g)，它每次也只会返回一个匹配项。在不设置全局标志的情况下，在同一个字符串上多次调用 `exec()`，将始终返回第一个匹配项的信息；而在设置全局标志的情况下，每次调用 `exec()` 都会在字符串中继续查找新匹配项

```js
var text = 'cat,bat,sat,fat';
var pattern1 = /.at/;
var matches = pattern1.exec(text);
console.log(pattern1,matches);
//pattern1.lastIndex:0
//matches[0]:'cat'
//matches.index:0
//matches.input:'cat,bat,sat,fat'
var text = 'cat,bat,sat,fat';
matches = pattern1.exec(text);    
console.log(pattern1,matches);    
//pattern1.lastIndex:0
//matches[0]:'cat'
//matches.index:0
//matches.input:'cat,bat,sat,fat'
```

全局匹配
```js
var text = 'cat,bat,sat,fat';
var pattern2 = /.at/g;
var matches = pattern2.exec(text);
console.log(pattern2,matches);    
//pattern2.lastIndex:3
//matches[0]:'cat'
//matches.index:0
//matches.input:'cat,bat,sat,fat'

var text = 'cat,bat,sat,fat';
matches = pattern2.exec(text);
console.log(pattern2,matches);    
//pattern2.lastIndex:7
//matches[0]:'bat'
//matches.index:4
//matches.input:'cat,bat,sat,fat'    
```

## 元字符


```
元字符         名称              匹配对象
.             点号               单个任意字符(除回车\r、换行\n、行分隔符\u2028和段分隔符\u2029外)
[]            字符组             列出的单个任意字符
[^]           排除型字符组        未列出的单个任意字符
?             问号               匹配0次或1次
*             星号               匹配0次或多次
+             加号               匹配1次或多次
{min,max}     区间量词            匹配至少min次，最多max次
^             脱字符             行的起始位置
$             美元符             行的结束位置
|             竖线               分隔两边的任意一个表达式
()            括号               限制多选结构的范围，标注量词作用的元素，为反向引用捕获文本
\1,\2...      反向引用            匹配之前的第一、第二...组括号内的表达式匹配的文本
```


## 量词

```
{n}       匹配n次
{n,m}     匹配至少n次，最多m次
{n,}      匹配至少n次
?         相当于{0,1}
*         相当于{0,}
+         相当于{1,}
```


## 括号

括号有两个功能，分别是分组和引用。具体而言，用于限定量词或选择项的作用范围，也可以用于捕获文本并进行引用或反向引用

### 分组

如果把一个表达式用括号包围起来，这个元素就是括号里的表达式，被称为子表达式

如果希望字符串 `'ab'` 重复出现2次，应该写为`(ab){2}`，而如果写为 `ab{2}`，则{2}只限定 `b`

```js
console.log(/(ab){2}/.test('abab'));//true
console.log(/(ab){2}/.test('abb'));//false
console.log(/ab{2}/.test('abab'));//false
console.log(/ab{2}/.test('abb'));//true
```

### 捕获

括号不仅可以对元素进行分组，还会保存每个分组匹配的文本，等到匹配完成后，引用捕获的内容。这种捕获了文本叫捕获分组

比如，要匹配诸如2016-06-23这样的日期字符串
```js
/(\d{4})-(\d{2})-(\d{2})/
```

与以往不同的是，年、月、日这三个数值被括号括起来了，从左到右为第1个括号、第2个括号和第3个括号，分别代表第1、2、3个捕获组

`javascript` 有9个用于存储捕获组的构造函数属性

```
RegExp.$1\RegExp.$2\RegExp.$3……到RegExp.$9分别用于存储第一、第二……第九个匹配的捕获组。在调用exec()或test()方法时，这些属性会被自动填充
```

`exec()` 方法是专门为捕获组而设计的，返回的数组中，第一项是与整个模式匹配的字符串，其他项是与模式中的捕获组匹配的字符串

```js
console.log(/(\d{4})-(\d{2})-(\d{2})/.exec('2016-06-23'));//["2016-06-23", "2016", "06", "23"]
```

在 `replace()` 方法中也可以引用分组，形式是 `$num`，`num` 是对应分组的编号

```js
//把2000-01-01的形式变成01-01-2000的形式
console.log('2000-01-01'.replace(/(\d{4})-(\d{2})-(\d{2})/g,'$3-$2-$1'));//'01-01-2000'
```

### 反向引用

英文中不少单词都有重叠出现的字母，如 `shoot`或 `beep`。若想检查某个单词是否包含重叠出现的字母，则需要引入**反向引用**

反向引用允许在正则表达式内部引用之前捕获分组匹配的文本，形式是 `\num`，`num` 表示所引用分组的编号

```js
//重复字母
/([a-z])\1/
console.log(/([a-z])\1/.test('aa'));//true
console.log(/([a-z])\1/.test('ab'));//false
```

反向引用可以用于建立前后联系。`HTML` 标签的开始标签和结束标签是对应的

```js
//开始标签
<([^>]+)>
//标签内容
[\s\S]*?
//匹配成对的标签
/<([^>]+)>[\s\S]*?<\/\1>/
console.log(/<([^>]+)>[\s\S]*?<\/\1>/.test('<a>123</a>'));//true
console.log(/<([^>]+)>[\s\S]*?<\/\1>/.test('<a>123</b>'));//false
```

### 非捕获

除了捕获分组，正则表达式还提供了非捕获分组，以 `(?:)` 的形式表示，它只用于限定作用范围，而不捕获任何文本

比如，要匹配 `abcabc` 这个字符，一般地，可以写为 `(abc){2}`，但由于并不需要捕获文本，只是限定了量词的作用范围，所以应该写为 `(?:abc){2}`

```js
console.log(/(abc){2}/.test('abcabc'));//true
console.log(/(?:abc){2}/.test('abcabc'));//true
```

由于非捕获分组不捕获文本，对应地，也就没有捕获组编号
```js
console.log(/(abc){2}/.test('abcabc'));//true
console.log(RegExp.$1);//'abc'
console.log(/(?:abc){2}/.test('abcabc'));//true
console.log(RegExp.$1);//''
```

非捕获分组也不可以使用反向引用
```js
/(?:123)\1/.test('123123');//false
/(123)\1/.test('123123');//true
```

捕获分组和非捕获分组可以在一个正则表达式中同时出现

```js
console.log(/(\d)(\d)(?:\d)(\d)(\d)/.exec('12345'));//["12345", "1", "2", "4", "5"]
```