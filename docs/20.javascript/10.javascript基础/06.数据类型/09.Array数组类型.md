---
title: Array 数组类型
date: 2021-01-10 15:03:03
permalink: /pages/sewrrjasweew
author: 
  name: jeffery
categories: 
  - javascript
  - 数据类型
tags: 
  - javascript
  - 数据类型
---

# Array 数组类型

## 数组方法

数组总共有20+个方法，将其分为对象继承方法、数组转换方法、栈和队列方法、数组排序方法、数组拼接方法、创建子数组方法、数组删改方法、数组位置方法、数组归并方法和数组迭代方法共10类

### 对象继承方法

继承了对象 `Object` 的 `toString()`、`toLocaleString()` 和 `valueOf()` 方法

- `toString()` 返回数组以逗号分隔的字符串
- `toLocaleString()` 是 `toString()` 方法的本地化版本，经常返回与 `toString()` 方法相同的值
- `valueOf()` 返回数组对象本身


```js
[1,2,3].toString();//'1,2,3'

var a = [1, 2, 3];
console.log(a.valueOf());// [1, 2, 3]
```

### 数组转换方法

#### join()

`join` 将数组转化为字符串，接收一个参数，用作分隔符的字符串，不改变原数组

```js
var a = [1,2,3];
console.log(a.join());//'1,2,3'
console.log(a.join(' '));//'1 2 3'
```



### 栈和队列方法

`push()` 和 `pop()` 方法允许将数组当作栈来使用，操作数组尾部进行添加或删除。

`unshift()`和 `shift()` 操作数组的头部进行添加或删除。

以上四个方法都会改变原数组


### 数组排序方法

#### reverse()

`reverse()` 方法用于反转数组的顺序，返回经过排序之后的数组；而原数组顺序也发生改变

```js
var array = [1,2,4,3,5];
console.log(array,array.reverse());//[5,3,4,2,1] [5,3,4,2,1]
```

#### sort()

默认情况下，`sort()` 方法按字符串升序排列数组项，`sort` 方法会调用每个数组项的 `toString()` 方法，然后比较得到的字符串排序，返回经过排序之后的数组，而原数组顺序也发生改变

```js
var array = ['3str',3,2,'2'];
console.log(array,array.sort());//[2, "2", 3, "3str"] [2, "2", 3, "3str"]
```

`sort()` 方法可以接受一个比较函数作为参数，以便指定哪个值在哪个值的前面。比较函数接收两个参数，如果第一个参数应该位于第二个参数之前则返回一个负数，如果两个参数相等则返回0，如果第一个参数应该位于第二个参数之后则返回一个正数

```js
function compare(value1,value2){
    if(value1 < value2){
        return -1;
    }else if(value1 > value2){
        return 1;
    }else{
        return 0;
    }
}
var array = ['5px',50,1,10];
//当数字与字符串比较大小时，字符串'5px'会被转换成NaN，这样结果就是false
console.log(array.sort(compare));//["5px",1, 10, 50]
```

### 数组拼接方法

#### concat()

`concat()` 方法基于当前数组中的所有项创建一个新数组，先创建当前数组一个副本，然后将接收到的参数添加到这个副本的末尾，最后返回新构建的数组。所以 `concat()` 不影响原数组

如果不提供参数，`concat()` 方法返回当前数组的一个浅拷贝

```js
var numbers = [1,2];
console.log(numbers,numbers.concat(3,4));//[1,2] [1,2,3,4]
```

### 创建子数组方法

#### slice()

`slice()` 方法基于当前数组中的一个或多个项创建一个新数组，接受一个或两个参数，即要返回项的起始和结束位置，最后返回新数组，所以 `slice()` 不影响原数组

`slice(start,end)` 方法需要两个参数 `start` 和 `end` ，返回这个数组中从 `start` 位置到(但不包含) `end`位置的一个子数组；

- `end` 为 `undefined` 或不存在，则返回从 `start`位置到数组结尾的所有项

- `start` 是负数，则 `start = max(length + start,0)`

- `end` 是负数，则 `end = max(length + end,0)`

- `start` 和 `end` 无法交换位置

- 如果没有参数，则返回原数组，实现浅拷贝

```js
var numbers = [1,2,3,4,5];
console.log(numbers.slice(2));//[3,4,5]
console.log(numbers.slice(2,undefined));//[3,4,5]
console.log(numbers.slice(2,3));//[3]
console.log(numbers.slice(2,1));//[]
console.log(numbers.slice(-3));//-3+5=2 -> [3,4,5]
console.log(numbers.slice(-8));//max(5 + -8,0)=0 -> [1,2,3,4,5]
console.log(numbers.slice(0,-3));//-3+5=2 -> [1,2]
console.log(numbers.slice(-2,-1));//-2+5=3;-1+5=4; -> [4]
```

### 数组删改方法

#### splice()

`splice()` 方法用于删除原数组的一部分成员，并可以在被删除的位置添加入新的数组成员，该方法会改变原数组

- `splice()` 返回一个由删除元素组成的数组，或者如果没有删除元素就返回一个空数组

- `splice()` 的第一个参数 `start` 指定了插入或删除的起始位置。如果 `start` 是负数，则 `start = max(length + start,0)` ；如果 `start` 是 `NaN` ，则相当于 `start = 0`

- 如果只提供一个元素，相当于将原数组在指定位置拆分成两个数组

```js
var a = [1,2,3,4,5,6,7,8];
console.log(a,a.splice());// [1,2,3,4,5,6,7,8] []
var a = [1,2,3,4,5,6,7,8];
console.log(a,a.splice(4));// [1,2,3,4] [5,6,7,8]
var a = [1,2,3,4,5,6,7,8];
console.log(a,a.splice(-4));//-4+8=4; [1,2,3,4] [5,6,7,8]
var a = [1,2,3,4,5,6,7,8];
console.log(a,a.splice(-9));//max(-9+8,0)=0 [] [1,2,3,4,5,6,7,8]
var a = [1,2,3,4,5,6,7,8];
console.log(a,a.splice(NaN));//[] [1,2,3,4,5,6,7,8]
```

### 数组位置方法

`ES5` 为数组实例添加了两个位置方法：`indexOf()`、`lastIndexOf()`

#### indexOf()

`indexOf(search,start)` 方法接收 `search` 和 `start` 两个参数，返回 `search` 首次出现的位置，如果没有找到则返回 `-1`

```js
var arr = [1,2,3,'1','2','3'];
console.log(arr.indexOf('2'));//4
console.log(arr.indexOf(0));//-1
```

`indexOf` 方法实现

```js
if (typeof Array.prototype.indexOf != "function") {
  Array.prototype.indexOf = function (searchElement, fromIndex) {
    var index = -1;
    fromIndex = fromIndex * 1 || 0;
    for (var k = 0, length = this.length; k < length; k++) {
      if (k >= fromIndex && this[k] === searchElement) {
          index = k;
          break;
      }
    }
    return index;
  };
}
```

#### lastIndexOf()

**lastIndexOf()** 查找和 `indexOf` 查找方向相反，从右向左查找，接收 `search` 和 `start` 两个参数，返回`search` 第一次出现的位置，如果没有找到则返回 `-1`

`lastIndexOf` 方法实现
```js
if (typeof Array.prototype.lastIndexOf != "function") {
  Array.prototype.lastIndexOf = function (searchElement, fromIndex) {
    var index = -1, length = this.length;
    fromIndex = fromIndex * 1 || length - 1;
    for (var k = length - 1; k > -1; k-=1) {
        if (k <= fromIndex && this[k] === searchElement) {
            index = k;
            break;
        }
    }
    return index;
  };
}
```

### 数组归并方法

数组归并方法包括 `reduce()`和 `reduceRight()` 方法两种，它们使用指定的函数将数组元素进行组合，生成单个值。

#### reduce()

`reduce()` 方法需要两个参数。第一个是执行化简操作的函数。第二个是初始化的值

  化简函数接受四个参数，分别是：

  【1】初始变量，默认为数组的第一个元素值。函数第一次执行后的返回值作为函数第二次执行的初始变量，依次类推

  【2】当前变量，如果指定了第二个参数，则该变量为数组的第一个元素的值，否则，为第二个元素的值

  【3】当前变量对应的元素在数组中的索引(从0开始)

  【4】原数组对象

  化简函数的这四个参数之中，只有前两个是必须的，后两个则是可选的

```js
var a = [1,2,3,4,5];
var sum = a.reduce(function(x,y){return x+y},0);//数组求和
var product = a.reduce(function(x,y){return x*y},1);//数组求积
var max = a.reduce(function(x,y){return (x>y)?x:y;});//求最大值
```

实现 `reduce` 方法

```js
if (typeof Array.prototype.reduce != "function") {
  Array.prototype.reduce = function (callback, initialValue ) {
     var previous = initialValue, k = 0, length = this.length;
     if (typeof initialValue === "undefined") {
        previous = this[0];
        k = 1;
     }
    if (typeof callback === "function") {
      for (k; k < length; k++) {
         this.hasOwnProperty(k) && (previous = callback(previous, this[k], k, this));
      }
    }
    return previous;
  };
}
```


#### reduceRight

`reduceRight()` 的工作原理和 `reduce()` 一样，不同的是它按照数组索引从高到低（从右到左）处理数组，而不是从低到高

```js
var values = [1,2,3,4,5];
var sum = values.reduceRight(function(prev, cur, index, array){
    console.log(prev,cur);
    return prev + cur;
});
console.log(sum);
//5 4
//9 3
//12 2
//14 1
//15
```

`reduceRight` 实现

```js
if (typeof Array.prototype.reduceRight != "function") {
  Array.prototype.reduceRight = function (callback, initialValue ) {
    var length = this.length, k = length - 1, previous = initialValue;
    if (typeof initialValue === "undefined") {
        previous = this[length - 1];
        k--;
    }
    if (typeof callback === "function") {
       for (k; k > -1; k-=1) {          
          this.hasOwnProperty(k) && (previous = callback(previous, this[k], k, this));
       }
    }
    return previous;
  };
}
```

### 数组迭代方法

数据迭代方法接收两个参数：第一个回调执行函数，第二个改变执行上下文this的值。而函数会接收三个参数：数组项的值、该项在数组中的位置和数组对象本身

#### map()

`map()` 方法对数组的每一项运行给定函数，返回每次函数调用的结果组成的数组

```js
[1,2,3].map(function(item,index,arr){return item*item});//[1,4,9]
```

`map()` 方法还可以接受第二个参数，表示回调函数执行时this所指向的对象

```js
var arr = ['a','b','c'];
[1,2].map(function(item,index,arr){return this[item]},arr);//['b','c']
```

实现一个 `map` 函数

```js
if (typeof Array.prototype.map != "function") {
  Array.prototype.map = function (fn, context) {
    var arr = [];
    if (typeof fn === "function") {
      for (var k = 0, length = this.length; k < length; k++) {      
         arr.push(fn.call(context, this[k], k, this));
      }
    }
    return arr;
  };
}
```

#### forEach()

`forEach()` 方法对数组中的每一项运行给定函数，这个方法没有返回值。本质上与 `for` 循环迭代数组一样。如果需要有返回值，一般使用 `map` 方法

`forEach()` 方法无法在所有元素都传递给调用的函数之前终止遍历。也就是说，没有像 `for` 循环中使用的相应的`break` 语句。如果要提前终止，必须把 `forEach()` 方法放在一个 `try` 块中，并能抛出一个异常

```js
var a = [1,2,3,4,5];
a.forEach(function(item,index,arr){
    try{
      if(item == 2) throw new Error;    
    }catch(e){
        console.log(item);
    }
});
```

`forEach()`方法实现

```js
if(typeof Array.prototype.forEach != 'function'){
    Array.prototype.forEach = function(fn,context){
        for(var k = 0,length = this.length; k < length; k++){
            if(typeof fn === 'function' && Object.prototype.hasOwnProperty.call(this,k)){
                fn.call(context,this[k],k,this);
            }
        }
    }
}
```

#### filter()

`filter()` 方法对数组中的每一项运行给定函数，该函数会返回 `true` 的项组成的数组。该方法常用于查询符合条件的所有数组项

```js
[1, 2, 3, 4, 5].filter(function (elem) {
  return (elem > 3);
});// [4, 5]    

[0, 1, 'a', false].filter(Boolean);// [1, "a"]


[1, 2, 3, 4, 5].filter(function (elem, index, arr) {
  return index % 2 === 0;
});// [1, 3, 5]
```

`filter()` 方法实现

```js
if (typeof Array.prototype.filter != "function") {
  Array.prototype.filter = function (fn, context) {
    var arr = [];
    if (typeof fn === "function") {
       for (var k = 0, length = this.length; k < length; k++) {
          fn.call(context, this[k], k, this) && arr.push(this[k]);
       }
    }
    return arr;
  };
}
```

#### some()

`some()` 方法对数组中的每一项运行给定函数，如果该函数对任一项返回 `true`，则返回 `true`, 终止循环。并且当且仅当数值中的所有元素调用判定函数都返回`false`，它才返回`false`

```js
a = [1,2,3,4,5];
a.some(function(elem, index, arr){return elem%2===0;})//true
a.some(isNaN);//false
```

`some` 方法实现

```js
if (typeof Array.prototype.some != "function") {
  Array.prototype.some = function (fn, context) {
    var passed = false;
    if (typeof fn === "function") {
         for (var k = 0, length = this.length; k < length; k++) {
          if (passed === true) break;
          passed = !!fn.call(context, this[k], k, this);
      }
    }
    return passed;
  };
}
```

#### every()

`every()` 方法对数组中的每一项运行给定函数，如果该函数对每一项都返回`true`，则返回 `true`；只要有一项返回`false`，则返回`false`, 并终止循环

```js
a = [1,2,3,4,5];
a.every(function(elem, index, arr){elem < 10;})//true
a.every(function(elem, index, arr){return elem%2 ===0;});//false
```

`every()` 方法实现

```js
if (typeof Array.prototype.every != "function") {
  Array.prototype.every = function (fn, context) {
    var passed = true;
    if (typeof fn === "function") {
       for (var k = 0, length = this.length; k < length; k++) {
          if (passed === false) break;
          passed = !!fn.call(context, this[k], k, this);
      }
    }
    return passed;
  };
}
```
### 数组方法总结

可以改变原数组的方法总共有7种：包括 `unshift()`、`shift()`、`push()`、`pop()` 4种栈和队列方法，`reverse()`和`sort()` 2种数组排列方法，数组删改方法`splice()`

## ESS6 数组扩展

### Array.of()

`Array.of() 与 `Array` 构造函数的工作机制类似，只是不存在单一数值型参数值的特例，无论有多少参数，无论参数是什么类型的，`Array.of()` 方法总会创建一个包含所有参数的数组

```js
let items = Array.of(1, 2);
console.log(items.length); // 2
console.log(items[0]); // 1
console.log(items[1]); // 2

items = Array.of(2);
console.log(items.length); // 1
console.log(items[0]); // 2
```

### Array.from()

`Array.from()` 方法可以接受可迭代对象或类数组对象作为第一个参数，最终返回一个数组

```js
function doSomething() {
    var args = Array.from(arguments);
    // 使用 args
}
```

如果想要进一步转化数组，可以提供一个映射函数作为 `Array.from()` 的第二个参数，这个函数用来将类数组对象中的每一个值转换成其他形式，最后将这些结果储存在结果数组的相应索引中

```js
function translate() {
    return Array.from(arguments, (value) => value + 1);
}
let numbers = translate(1, 2, 3);
console.log(numbers); // 2,3,4
```

### includes()

`Array.prototype.includes` 方法返回一个布尔值，表示某个数组是否包含给定的值

```js
[1, 2, 3].includes(2)     // true
[1, 2, 3].includes(4)     // false
[1, 2, NaN].includes(NaN) // true
```

该方法的第二个参数表示搜索的起始位置，默认为0。如果第二个参数为负数，则表示倒数的位置，如果这时它大于数组长度（比如第二个参数为-4，但数组长度为3），则会重置为从0开始

```js
[1, 2, 3].includes(3, 3);  // false
[1, 2, 3].includes(3, -1); // true
```

### find()和findIndex()

`find()` 方法和 `findIndex()` 方法都接受两个参数：一个是回调函数；另一个是可选参数，用于指定回调函数中 `this` 的值。二者间唯一的区别是，`find()` 方法返回查找到的值，`findIndex()` 方法返回查找到的值的索引


```js
let numbers = [25, 30, 35, 40, 45];
console.log(numbers.find(n => n > 33)); // 35
console.log(numbers.findIndex(n => n > 33)); // 2
```

### fill()

`fill()` 方法可以用指定的值填充一至多个数组元素。当传入一个值时，`fill()` 方法会用这个值重写数组中的所有值

```js
let numbers = [1, 2, 3, 4];
numbers.fill(1);
console.log(numbers.toString()); // 1,1,1,1
```

可以传入第二个和第三个参数，表示开始索引和不包含结束索引这两个可选参数

```js
let numbers = [1, 2, 3, 4];
numbers.fill(1, 2);
console.log(numbers.toString()); // 1,2,1,1
numbers.fill(0, 1, 3);
console.log(numbers.toString()); // 1,0,0,1
```

::: tip
如果开始索引或结束索引为负值，那么这些值会与数组的length属性相加来作为最终位置。例如，如果开始位置为-1，那么索引的值实际为array.length-1，array为调用fill()方法的数组
:::

### copyWithin()

`copyWithin()` 方法与 `fill()` 方法相似，其也可以同时改变数组中的多个元素。`fill()` 方法是将数组元素赋值为一个指定的值，而 `copyWithin()` 方法则是从数组中复制元素的值。调用 `copyWithin()`方法时需要传入两个参数：一个是该方法开始填充值的索引位置，另一个是开始复制值的索引位置

```js
let numbers = [1, 2, 3, 4];
// 从索引 2 的位置开始粘贴
// 从数组索引 0 的位置开始复制数据
numbers.copyWithin(2, 0);
console.log(numbers.toString()); // 1,2,1,2
```

这段代码从 `numbers` 的索引2开始粘贴值，所以索引2和3将被重写。给 `CopyWithin()` 传入第二个参数0表示，从索引0开始复制值并持续到没有更多可复制的值

第三个参数是不包含结束索引，用于指定停止复制值的位置
```js
let numbers = [1, 2, 3, 4];
// 从索引 2 的位置开始粘贴
// 从数组索引 0 的位置开始复制数据
// 在遇到索引 1 时停止复制
numbers.copyWithin(2, 0, 1);
console.log(numbers.toString()); // 1,2,1,4
```

正如 `fill()` 方法一样，`copyWithin()` 方法的所有参数都接受负数值，并且会自动与数组长度相加来作为最终使用的索引

