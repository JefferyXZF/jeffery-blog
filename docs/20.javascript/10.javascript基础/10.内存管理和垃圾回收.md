---
title: JavaScript 内存管理
date: 2020-12-27 10:20:10
permalink: /pages/eecssdeweew
author: 
  name: jeffery
categories: 
  - javascript
tags: 
  - javascript
---

## 内存管理

内存管理生命周期包括三个阶段：
- 分配需要的内存；
- 使用分配到的内存；
- 释放内存。

那何时释放内存及释放哪些变量的内存，则需要使用垃圾回收机制

### 分配内存

`JavaScrpt` 是自动分配内存的，在定义变量时就完成了内存分配

```js
var n = 123; // 给数值变量分配内存
var s = "azerty"; // 给字符串分配内存
var o = {a: 1,b: null}; // 给对象及其包含的值分配内存
```

有些函数调用结果是分配对象内存
```js
var d = new Date(); // 分配一个 Date 对象
var e = document.createElement('div'); // 分配一个 DOM 元素
```

有些方法分配新变量或者新对象
```js
var a = ["ouais ouais", "nan nan"];
var a2 = ["generation", "nan nan"];
var a3 = a.concat(a2); 
// 新数组有四个元素，是 a 连接 a2 的结果
```

**【内存存储方式】**

**栈**：原始值占据固定的空间大小，是简单的数据段，为了便于提升变量查询速度，将其存储在栈(stack)中

**堆**：引用值的大小会改变，所以不能将其存放在栈中，否则会降低变量查询速度，因此存储在堆(heap)中，变量的值是存储一个指针，指向存储对象的内存处

## 使用内存

使用值的过程实际上是对分配内存进行读取与写入的操作。读取与写入可能是写入一个变量或者一个对象的属性值，甚至传递函数的参数

```js
var a = 1;
console.log(a);// 读取内存中的值
a = 2; // 写入内存
```

## 释放内存

`Javascript` 内嵌了垃圾收集器，用来跟踪内存的分配和使用，以便当分配的内存不再使用时，自动释放它。垃圾收集器会按照固定的时间间隔，或代码执行中预定的收集时间，周期性地执行这一操作

局部变量只在函数执行的过程中存在。当函数执行结束，释放它们的内存以供将来使用。但也有特殊的情况不会释放内存，比如闭包。这时候需要手动去管理内存在什么时候释放，否则会造成内存泄漏

### 引用计数

引用计数是最简单的垃圾收集算法。此算法把“对象是否不再需要”简化定义为“对象有没有其他对象引用到它”。如果没有引用指向该对象（零引用），对象将被垃圾回收机制回收

两个对象a、b被创建，一个作为另一个的属性被引用，另一个被分配给变量o
```js
var o ={ a: {b:2}}
```

**循环引用**

引用计数算法有个限制：无法处理循环引用。

在下面的例子中，两个对象被创建，并互相引用，形成了一个循环。它们被调用之后不会离开函数作用域，所以它们已经没有用了，可以被回收了。然而，引用计数算法考虑到它们互相都有至少一次引用，所以它们不会被回收

```js
function f(){
  var o = {};
  var o2 = {};
  o.a = o2; // o 引用 o2
  o2.a = o; // o2 引用 o
  return "azerty";
}
f();
```

::: tip 手动释放内存
将变量设置为null意,切断变量与它此前引用的值之间的连接。当垃圾收集器下次运行时，就会删除这些值并回收它们占用的内存
:::


### 标记清除

`javascript` 中最常用的垃圾回收算法是 **标记清除(mark-and-sweep)** ，这个算法把“对象是否不再需要”简化定义为“对象是否可以到达”。如果对象不可到达，对象将被垃圾回收机制回收

大多数浏览器实现使用的都是标记清除式的垃圾收集策略，只不过垃圾收集的时间互有不同

这个算法假定设置一个叫做根（root）的对象（在`Javascript` 里，根是全局对象）。定期的，垃圾回收器将从根开始，找所有从根开始引用的对象，然后找这些对象引用的对象……从根开始，垃圾回收器将找到所有可以到达的对象和所有不能到达的对象

标记清除算法为分为标记(mark)和清除(sweep)两个阶段

- 在标记阶段，垃圾回收器会从根对象开始遍历，每一个可以从根对象访问到的对象都会被添加一个标识，于是这个对象就被标识为可到达对象

- 在清除阶段，垃圾回收器会对内存从头到尾进行线性遍历，如果发现有对象没有被标识为可到达对象，那么就将此对象占用的内存回收，并且将原来标记为可到达对象的标识清除，以便进行下一次垃圾回收操作

## 优化内存占用

 使用具备垃圾收集机制的 `javascript` 的主要问题在于：分配给web浏览器的可用内存数量通常要比分配给桌面应用程序的少，目的是防止运行 `javascript` 的网页耗尽全部系统内存而导致系统崩溃。内存限制问题不仅会影响给变量分配内存，同时还会影响调用栈以及在一个线程中能够同时执行的语句数量

因此，确保占用最少的内存可以让页面获得更好的性能。而优化内存占用的最佳方式是：为执行中的代码只保存必要的数据。一旦数据不再有用，最好通过将其值设置为 `null` 来释放其引用，这种做法叫 **解除引用(dereferencing)**。这一做法适用于大多数全局变量和全局对象的属性，局部变量会在它们离开执行环境时自动被解除引用

```js
function createPerson(name){
    var localPerson = new Object();
    localPerson.name = name;
    return localPerson;
}

var globalPerson = createPerson('test');
globalPerson = null;
```

