---
title: JavaScript 优化技术《二》
date: 2021-05-02 14:27:01
permalink: /pages/sseseweweb
author: 
  name: jeffery
categories: 
  - javascript
tags: 
  - javascript
---

# JavaScript 优化技术《二》

### 删除未使用的js代码

应用程序包含的代码越多，需要传输到客户端的数据就越多，浏览器解析代码所需时间也越长。有时有些功能可能根本没有用到，最好只在开发环境中保留这些额外的代码，而不要将其用于生产环境，这样就不会给客户端的浏览器带来无用代码的负担。

不断询问自己某个功能、特性或代码是否必要。可以手动或使用 `Uglify` 或 `google’s closurecompiler` 等工具移除不用的代码，甚至可以用一种名为摇树优化(tree shaking)的技术，从应用程序中移除不用的代码。

那什么样的代码我们应该删除呢？

- 未使用的功能性代码以及与之相关的代码

- 多余的依赖库

- 被滥用的 `npm` 包

- 公共模版代码（什么是公共模版代码？就比如我们的脚手架里，又或者咱们从其他项目 `copy` 过来的公共方法文件，就会有很多与项目可能无关的代码，那这些东西，就是需要我们删除掉的）

### 数组和对象操作避免使用构造函数

什么是构造函数？

就比如**new Array(), new Object()**之类的

不推荐的写法：

```js
testArr = () => {
	let arr = new Array()
	arr[0] = '大叔'
	arr[1] = '二叔'
	arr[2] = '随便是什么都行'
	……
	return arr
}
testObj = () => {
	let obj = new Object()
	obj.name = '大叔'
	obj.age = 18
	obj.sex = '男'
	return obj
}
```

推荐写法：

```js
testArr = () => {
	let arr = ['大叔', '二叔', '随便是什么都行']
	return arr
}
testObj = () => {
	let obj = {
		name: '大叔',
		age: 18,
		sex: '男'
	}
	return obj
}
```

### 尽量避免使用非必要的全局变量

尤其是像 `document` 这类的全局变量，我们如果一定要用，就必须要考虑作用域的问题， 如下实例：

不推荐的写法：

```js
test = () => {
	var imgs = document.getElementByTagName("img");
    for(var i = 0, len = imgs.length; i < len; i++) {
        imgs[i].title = document.title + " image " + i;
    }
}
```

推荐的写法:

```js
test = () => {
	var doc = document;
    var imgs = doc.getElementByTagName("img");
    for(var i = 0, len = imgs.length; i < len; i++) {
        imgs[i].title = doc.title + " image " + i;
    }
}
```

### 合理使用缓存机制

缓存通过减少延迟和网络流量来提高网站的速度和性能，从而缩短显示资源所需的时间，利用空间换时间的策略，可以通过缓存应用程序接口(Cache API)或超文本传输协议缓存(HTTPcaching)来实现。

缓存技术：`cookie`, `localStorage`, `sessionStorage`


哪些内容适合缓存？

1、实时性要求不严格的内容

2、经常访问但改动不频繁的内容

### 减少循环中的活动

请看如下简单实例： 不推荐：

```js
test = () => {
	var i
	var arr = [1, 2, 3, 4, 5, 6, 7, 8]
	for (i = 0, i < arr.length; i++) {
		return i
	}
}
```

推荐：

```js
    test = () => {
    	var i
    	var arr = [1, 2, 3, 4, 5, 6, 7, 8]
		var l = arr.length
    	for (i = 0, i < l; i++) {
    		return i
    	}
    }
```

### 减少不必要的变量

下面的实例： 不推荐

```js
test = () => {
	let a = 1, b = 2
	return a + b
}
```

推荐

```js
test = () => {
	return 1 + 2
}
```

### 最小化语句数

`JS` 代码中的语句数量也会影响所执行的操作的速度

完成多个操作的单个语句要比完成单个操作的多个语句块快。

所以要找出可以组合在一起的语句，以减少整体的执行时间

比如下面的例子：

不推荐

```js
test = () => {
	var a = 1
	var b = 2
	var c = 3
	return a + b + c
}
```

推荐

```js
test = () => {
	var a = 1,
	b = 2,
	c = 3
	return a + b + c
}
```

### 原生方法更快

只要有可能，我们尽量使用原生方法，而不是自己用 `js` 去重写业务逻辑。 原生方法是用C或者C++之类的编译型语言写出来的，要比JS快很多。 举个例子： 用 `switch…case` 代替一系列复杂的 `if…else` 并按照可能出现的几率最大—>最小的顺序组织逻辑，可以得到进一步的优化

### 小心使用闭包

什么是闭包？闭包有三大特性： 
- 1、函数嵌套函数。 
- 2、函数内部可以引用外部的参数和变量。 
- 3、参数和变量不会被垃圾回收机制回收。 

闭包有些什么好处呢？ 
- 变量长期存储在内存中 
- 避免全局变量的污染 

闭包的缺点，恰恰也就是由这些优点带来的 
- 常驻内存必然增加内存的使用量。 
- 使用不当很容易造成内存泄漏。

### 避免内存泄漏

高级语言 `JS` 负责几个底层管理，比如内存管理。垃圾回收机制在大多数编程语言中十分常见。通俗来说，垃圾回收机制就是简单地收集和释放已经分配给目标对象的内存，而这些内存并没有在程序的任何部分使用。C语言之类的编程语言中，开发人员必须使用 `malloc()` 和 `dealloc()` 函数来分配和释放内存。

尽管 `JavaScript` 自动执行垃圾回收，但有时它并不完美。`JavaScript ES6` 中，映射 `Map` 和集合 `Set` 和它们的“较弱”的同胞一起引入。这种“较弱”的同类被称为 `WeakMap` 和 `WeakSet` ，它们对对象的引用“较弱”，允许对未引用的值进行垃圾回收，从而防止内存泄漏。

### 尽早跳出循环

大周期循环必然会消耗大量宝贵时间，因此要尽早跳出循环。关键字 `break` 和 `continue` 可以做到这一点。编写最高效的代码是你的责任。在下面的例子中，如果没有跳出 `break` 循环，代码将运行循环 `1000000000` 次，这显然导致了重载。

```js
let arr = new Array(1000000000).fill('----');
arr[970] = 'found'; 
for (let i = 0; i < arr.length; i++) {   
	if (arr[i] === 'found') {         
		console.log("Found");         
		break;     
		} 
	} 
```

在下面的例子中，若循环与条件不匹配时没有使用继续 `continue` 关键字，该函数将持续运行1000000000次。我们仅处理处于偶数位置的数组元素，这将循环执行减少了近一半。

```js
let arr = new Array(1000000000).fill('----'); 
arr[970] = 'found'; 
for (let i = 0; i < arr.length; i++) {   
	if(i%2!=0){         
		continue;     
		};     
	process(arr[i]); 
} 
```

### 最小化变量计算次数

可使用闭包减少变量的计算次数。通俗来说，`JavaScript` 中的闭包可以从内部函数访问外部函数。每次创建函数时都会创建闭包，而不是调用。即使外部函数已经返回，内部函数也可以访问外部作用域的变量。

通过以下两个实例来解释这一点：

```js
function findCustomerCity(name) {   
	const texasCustomers = ['John','Ludwig', 'Kate'];   
	const californiaCustomers = ['Wade','Lucie','Kylie'];

	return texasCustomers.includes(name) 
	? 'Texas' 
	:  californiaCustomers.includes(name) 
		?'California' 
		: 'Unknown'; 
	}; 
```

多次调用上述函数，每次都会创建一个新对象。每次调用中，内存都被画蛇添足地重新分配给变量 `texasCustometrs` 和 `californiaCustomers`

使用带有闭包的解决方案可仅实例化变量一次。看看下面的例子：

```js
function findCustomerCity() {   
	const texasCustomers = ['John','Ludwig', 'Kate'];   
	const californiaCustomers = ['Wade','Lucie','Kylie'];     
	return name =>texasCustomers.includes(name) 
	? 'Texas' 
	: californiaCustomers.includes(name) 
		?'California' 
		: 'Unknown'; 
};
let cityOfCustomer = findCustomerCity();
cityOfCustomer('John');//Texas cityOfCustomer('Wade');//California cityOfCustomer('Max');//Unknown 
```

上例中，在闭包的辅助下，返回到变量 `cityOfCustomer` 的内部函数可以访问外部函数 `findCustomerCity()` 的常量。每当内部函数被调用，其名称作为参数传递，不需要再次实例化常数。

### 避免使用delete关键字

`delete` 关键字用于从对象中移除属性。对于 `delete` 关键字的性能，用户已颇有微词，不足之处预计在未来的更新中得到修复。你可以选择简单地将不需要的属性设置为 `undefined`。

```js
const object = {name:"Jane Doe", age:43}; 
object.age = undefined; 
```

也可以使用地图 `Map` 对象，据布雷特所说，此种方式更为快捷。

### 最小化DOM访问

与其他 `JavaScript` 语句相比，访问 `DOM` 的速度很慢。对 `DOM` 进行更改会触发布局的重新绘制，网站运行愈加缓慢。一次性访问单个 `DOM` 元素并将其用作局部变量以减少访问次数。任务完成后，务必将变量设置为 `null` 以移除该变量的值。这将触发垃圾回收机制以防止内存泄漏。

### 压缩文件


使用诸如 `Gzip` 之类的压缩方法可缩小 `JavaScript` 文件的大小。鉴于浏览器所需下载资料缩小，网站性能也随之提高。压缩可将文件大小减少80%。

### 缩减最终代码

有人认为缩减和压缩是一样的，事实并不是这样。压缩使用特殊算法来改变文件的输出大小，缩减则需删除 `JavaScript` 文件中的注释和多余空格。这一过程可以在许多工具和包的帮助下完成，这些工具和包都可以在网上找到。缩减已成为页面优化的标准做法，也是前端优化的主要组成部分。

缩减可将文件大小减少60%。

### 使用节流(throtte)和去抖动(debounce)

节流和去抖动可严格控制代码处理事件的次数。

节流指定函数可以超时的最大次数。例如，“每1000毫秒最多执行一次onkeyup事件函数。”这意味着如果每秒输入20个键，事件每秒只会触发一次，这将减少代码的负载。

去抖动指定函数最小的持续时间，该时间是该函数自上一次执行后再次运行的时间。换句话说，“只有在经过600毫秒而没有调用该函数的情况下，才会执行这个函数。”这就意味着自最后一次执行该函数起600毫秒内，该函数不会被调用。

### 使用异步和延迟


现代网站中，脚本比超文本标记语言(HTML)更密集，大小更大，处理时间更长。默认情况下，浏览器必须等待脚本下载并执行后，再处理页面的其余部分。这可能会导致庞大的脚本阻止网页加载。为避免这种情况，`JavaScript` 提供了两种名为异步和延迟的技术，您只需将这些属性添加到 `<script>` 标签中。

异步是告诉浏览器在不影响渲染的情况下加载脚本。换句话说，页面不等待异步脚本，而是处理和显示内容。延迟是在渲染完成后告诉浏览器加载脚本。如果两者都有指定，异步在现代浏览器上处于优先地位，而支持延迟但不支持异步的旧浏览器将回退到延迟。

这两个属性可以极大地减少页面加载时间。

### 使用异步代码防止线程阻塞

`JavaScript` 默认是同步的，也是单线程的。但有时代码需要大量时间来计算。从本质上讲，同步意味着一段代码会阻止其他代码语句运行，直到执行结束。这会降低网站整体性能。但是我们可以通过实施异步代码避免这种情况。异步代码曾以回调形式编写，但 `ES6` 引入了一种处理异步代码的新风格，名为 `promise`

但如何在单线程上运行的同时还能运行异步代码?这是很多人困惑的地方。一切因运行在浏览器后台的 `JavaScript` 引擎而成为可能。`JavaScript` 引擎是执行 `JavaScript` 代码的计算机程序或解释器。`JavaScript` 引擎可以用多种语言编写。例如，支持谷歌浏览器的V8引擎是用 `C++` 编写的，而支持火狐浏览器的蜘蛛猴引擎是用C和C++编写的。

这些 `JavaScript` 引擎可以在后台处理任务。据布莱恩所说，调用栈识别网络应用程序界面(Web API)的功能，并递交至浏览器处理。一旦浏览器完成了这些任务，它们就会返回并作为回调被压入堆栈。

在没有浏览器的情况下，Node.js如何运行?事实上，驱动谷歌浏览器的V8引擎也支持 `Node.js`。

### 使用代码拆分


如果你有过谷歌灯塔(Light House)的经验，必然会熟悉一个名为“初始内容渲染(first contentful paint)”的指标。这是灯塔报告性能部分跟踪的六个指标之一。

初始内容渲染(FCP)测量的是用户导航到页面后，浏览器渲染第一个 `DOM` 内容所需的时间。页面上的图像、非白色(画布)元素和可缩放矢量图形(SVG)被视为DOM内容，`iframe` 中的任何内容都不含在内。

获得更高 `FCP` 分数的最佳方式之一是使用代码拆分。代码拆分是一种在开始时只向用户发送必要模块的技术。通过减小最初传输的有效载荷的大小而极大影响 `FCP` 分数。热门的模块管理器，如 `webpack` ，提供代码拆分功能。也可在本机 `ES` 模块的帮助下加载单个模块。

### 使用Web Workers在后台运行CPU密集型任务

`Web Workers` 允许在后台线程中运行脚本。如果你有一些高强度的任务，可以把它们分配给 `Web Workers`，`Web Workers` 可以在不干扰用户界面的情况下运行这些任务。创建之后，`Web Workers` 可以向 `JavaScript` 代码指定的事件处理程序发送消息来与该代码进行通信，反之亦然。