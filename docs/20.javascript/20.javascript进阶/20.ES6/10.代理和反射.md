---
title: 代理（Proxy)和反射(Reflect)
date: 2020-02-18 18:27:01
permalink: /pages/ssewedf257cb
author: 
  name: jeffery
categories: 
  - javascript
tags: 
  - javascript
---

# 代理（Proxy)和反射(Reflect)

ES5和ES6致力于为开发者提供 `JS` 已有却不可调用的功能。例如在ES5出现以前，`JS` 环境中的对象包含许多不可枚举和不可写的属性，但开发者不能定义自己的不可枚举或不可写属性，于是ES5引入了 `Object.defineProperty()` 方法来支持开发者去做`JS` 引擎早就可以实现的事情

ES6添加了一些内建对象，赋予开发者更多访问 `JS` 引擎的能力。代理(Proxy)是一种可以拦截并改变底层 `JS` 引擎操作的包装器，在新语言中通过它暴露内部运作的对象，从而让开发者可以创建内建的对象

## 代理和反射

调用 `new Proxy()` 可创建代替其他目标(target)对象的代理，它虚拟化了目标，所以二者看起来功能一致

**代理** 可以拦截 `JS` 引擎内部目标的底层对象操作，这些底层操作被拦截后会触发响应特定操作的陷阱函数

**反射** API以 `Reflect` 对象的形式出现，对象中方法的默认特性与相同的底层操作一致，而代理可以覆写这些操作，每个代理陷阱对应一个命名和参数都相同的 `Reflect` 方法。下表总结了代理陷阱的特性

![proxy](https://gitee.com/FIF/pic-beg/raw/master/images/javascript/ES6_proxy.png)

每个陷阱覆写 `JS` 对象的一些内建特性，可以用它们拦截并修改这些特性。如果仍需使用内建特性，则可以使用相应的反射 `API` 方法

【创建简单代理】

用 `Proxy` 构造函数创建代理需要传入两个参数：目标(target)和处理程序(handler)。处理程序用于定义一个或多个陷阱的对象，在代理中，除了专门为操作定义的陷阱外，其余操作均使用默认特性。不使用任何陷阱的处理程序等价于简单的转发代理

```js
let target = {};
let proxy = new Proxy(target, {});
proxy.name = "proxy";
console.log(proxy.name); // "proxy"
console.log(target.name); // "proxy"
target.name = "target";
console.log(proxy.name); // "target"
console.log(target.name); // "target"
```
## 陷阱代理

### set

`set` 陷阱接受4个参数

```
trapTaqget 用于接收属性(代理的目标)的对象
key 要写入的属性键(字符串或Symbol类型)
value 被写入属性的值
receiver 操作发生的对象(通常是代理)
```

`Reflect.set()` 是 `set` 陷阱对应的反射方法和默认特性，它和 `set` 代理陷阱一样也接受相同的4个参数，以方便在陷阱中使用。如果属性已设置陷阱应该返回true，如果未设置则返回false。(Reflect.set()方法基于操作是否成功来返回恰当的值)
 
可以使用 `set` 陷阱并检查传入的值来验证属性值

```js
let target = {
    name: "target"
};
let proxy = new Proxy(target, {
    set(trapTarget, key, value, receiver) {
        // 忽略已有属性，避免影响它们
        if (!trapTarget.hasOwnProperty(key)) {
            if (isNaN(value)) {
                throw new TypeError("Property must be a number.");
            }
        }
        // 添加属性
        return Reflect.set(trapTarget, key, value, receiver);
    }
});
// 添加一个新属性
proxy.count = 1;
console.log(proxy.count); // 1
console.log(target.count); // 1
// 你可以为 name 赋一个非数值类型的值，因为该属性已经存在
proxy.name = "proxy";
console.log(proxy.name); // "proxy"
console.log(target.name); // "proxy"
// 抛出错误
proxy.anotherName = "proxy";
```

`set` 代理陷阱可以拦截写入属性的操作，`get` 代理陷阱可以拦截读取属性的操作

### get

读取属性时才会检验属性，所以无论对象中是否存在某个属性，都可以通过 `get` 陷阱来检测，它接受3个参数
```
trapTarget 被读取属性的源对象(代理的目标)
key 要读取的属性键(字符串或Symbol)
receiver 操作发生的对象(通常是代理)
```

如果属性在目标上不存在，则使用 `get` 陷阱和 `Reflect.get()` 时会抛出错误

```js
let proxy = new Proxy({}, {
    get(trapTarget, key, receiver) {
        if (!(key in receiver)) {
            throw new TypeError("Property " + key + " doesn't exist.");
        }
        return Reflect.get(trapTarget, key, receiver);
    }
});
// 添加属性的功能正常
proxy.name = "proxy";
console.log(proxy.name); // "proxy"
// 读取不存在属性会抛出错误
console.log(proxy.nme); // 抛出错误
```

### has

每当使用 `in操作符` 时都会调用 `has` 陷阱，并传入两个参数

```
trapTaqget读取属性的对象(代理的目标)
key要检查的属性键(字符串或Symbol)
```

`Reflect.has()` 方法也接受这些参数并返回 `in操作符` 的默认响应，同时使用 `has` 陷阱和 `Reflect.has()` 可以改变一部分属性被 `in` 检测时的行为，并恢复另外一些属性的默认行为。例如，可以像这样隐藏之前示例中的 `value` 属性

```js
let target = {
    name: "target",
    value: 42
};
let proxy = new Proxy(target, {
    has(trapTarget, key) {
        if (key === "value") {
            return false;
        } else {
            return Reflect.has(trapTarget, key);
        }
    }
});
console.log("value" in proxy); // false
console.log("name" in proxy); // true
console.log("toString" in proxy); // true
```

### deleteProperty

`delete` 操作符可以从对象中移除属性，如果成功则返回 `true` ，不成功则返回`false` 。在严格模式下，如果尝试删除一个不可配置(nonconfigurable)属性则会导致程序抛出错误，而在非严格模式下只是返回 `false`

每当通过 `delete` 操作符删除对象属性时，`deleteProperty` 陷阱都会被调用，它接受两个参数

```
trapTarget 要删除属性的对象(代理的目标)
key 要删除的属性键(字符串或Symbol)
```

`Reflect.deleteProperty()` 方法为 `deleteProperty` 陷阱提供默认实现，并且接受同样的两个参数。结合二者可以改变 `delete` 的具体表现行为，例如，可以像这样来确保 `value` 属性不会被删除

```js
let target = {
    name: "target",
    value: 42
};
let proxy = new Proxy(target, {
    deleteProperty(trapTarget, key) {
        if (key === "value") {
            return false;
        } else {
            return Reflect.deleteProperty(trapTarget, key);
        }
    }
});
// 尝试删除 proxy.value
console.log("value" in proxy); // true
let result1 = delete proxy.value;
console.log(result1); // false
console.log("value" in proxy); // true
// 尝试删除 proxy.name
console.log("name" in proxy); // true
let result2 = delete proxy.name;
console.log(result2); // true
console.log("name" in proxy); // false
```

### 原型代理

`getPrototypeOf` 和 `setPrototypeOf`

```js
let target = {};
let proxy = new Proxy(target, {
    getPrototypeOf(trapTarget) {
        return Reflect.getPrototypeOf(trapTarget);
    },
    setPrototypeOf(trapTarget, proto) {
        return Reflect.setPrototypeOf(trapTarget, proto);
    }
});
let targetProto = Object.getPrototypeOf(target);
let proxyProto = Object.getPrototypeOf(proxy);
console.log(targetProto === Object.prototype); // true
console.log(proxyProto === Object.prototype); // true
// 成功
Object.setPrototypeOf(target, {});
// 同样成功
Object.setPrototypeOf(proxy, {});
```

### 对象可扩展性

ES5已经通过 `Object.preventExtensions()` 方法和 `Object.isExtensible()` 方法修正了对象的可扩展性，ES6可以通过代理中的 `preventExtensions` 和`isExtensible`陷阱拦截这两个方法并调用底层对象

```js
let target = {};
let proxy = new Proxy(target, {
    isExtensible(trapTarget) {
        return Reflect.isExtensible(trapTarget);
    },
    preventExtensions(trapTarget) {
        return Reflect.preventExtensions(trapTarget);
    }
});
console.log(Object.isExtensible(target)); // true
console.log(Object.isExtensible(proxy)); // true
Object.preventExtensions(proxy);
console.log(Object.isExtensible(target)); // false
console.log(Object.isExtensible(proxy)); // false
```

### 属性描述符

`defineProperty` 陷阱需要在操作成功后返回 `true`，否则返回 `false`。`getOwnPropertyDescriptor` 陷阱只接受 `trapTarget`和`key`两个参数，最终返回描述符。`Reflect.defineProperty()`方法和`Reflect.getOwnPropertyDescriptor()`方法与对应的陷阱接受相同参数

```js
let proxy = new Proxy({}, {
    defineProperty(trapTarget, key, descriptor) {
        return Reflect.defineProperty(trapTarget, key, descriptor);
    },
    getOwnPropertyDescriptor(trapTarget, key) {
        return Reflect.getOwnPropertyDescriptor(trapTarget, key);
    }
});
Object.defineProperty(proxy, "name", {
    value: "proxy"
});
console.log(proxy.name); // "proxy"
let descriptor = Object.getOwnPropertyDescriptor(proxy, "name");
console.log(descriptor.value); // "proxy"
```

### ownKeys

通过 `Reflect.ownKeys()` 方法实现默认的行为，返回的数组中包含所有自有属性的键名，字符串类型和 `Symbol` 类型的都包含在内

`ownKeys`陷阱唯一接受的参数是操作的目标，返回值必须是一个数组或类数组对象，否则就抛出错误。当调用 `Object.keys()`、`Object.getOwnPropertyNames()`、`Object.getOwnPropertySymbols()` 或` Object.assign()` 方法时，可以用`ownKeys`陷阱来过滤掉不想使用的属性键


```js
let proxy = new Proxy({}, {
    ownKeys(trapTarget) {
        return Reflect.ownKeys(trapTarget).filter(key => {
            return typeof key !== "string" || key[0] !== "_";
        });
    }
});
let nameSymbol = Symbol("name");
proxy.name = "proxy";
proxy._name = "private";
proxy[nameSymbol] = "symbol";

let names = Object.getOwnPropertyNames(proxy),
keys = Object.keys(proxy);
symbols = Object.getOwnPropertySymbols(proxy);
console.log(names.length); // 1
console.log(names[0]); // "name"
console.log(keys.length); // 1
console.log(keys[0]); // "name"
console.log(symbols.length); // 1
console.log(symbols[0]); // "Symbol(name)"
```

### 函数代理中的apply和construct

`Reflect.construct()` 方法也接受这两个参数，其还有一个可选的第三个参数`newTarget`。若给定这个参数，则该参数用于指定函数内部 `new.target` 的值, 有了 `apply` 和 `construct` 陷阱，可以完全控制任何代理目标函数的行为

```js
let target = function() { return 42 },
proxy = new Proxy(target, {
    apply: function(trapTarget, thisArg, argumentList) {
        return Reflect.apply(trapTarget, thisArg, argumentList);
    },
    construct: function(trapTarget, argumentList) {
        return Reflect.construct(trapTarget, argumentList);
    }
});
// 使用了函数的代理，其目标对象会被视为函数
console.log(typeof proxy); // "function"
console.log(proxy()); // 42
var instance = new proxy();
console.log(instance instanceof proxy); // true
console.log(instance instanceof target); // true
```

## 撤销代理

使用 `proxy.revocable()` 方法创建可撤销的代理，该方法采用与 `Proxy` 构造函数相同的参数：目标对象和代理处理程序，返回值是具有以下属性的对象

```
proxy 可被撤销的代理对象
revoke 撤销代理要调用的函数
```

当调用 `revoke()` 函数时，不能通过 `proxy` 执行进一步的操作。任何与代理对象交互的尝试都会触发代理陷阱抛出错误

```js
let target = {
    name: "target"
};
let { proxy, revoke } = Proxy.revocable(target, {});
console.log(proxy.name); // "target"
revoke();
// 抛出错误
console.log(proxy.name);
```