---
title: ES5 实现模块化
date: 2020-03-02 18:27:01
permalink: /pages/slwesdf257cb
author: 
  name: jeffery
categories: 
  - javascript
tags: 
  - javascript
---

# ES5 实现模块化

在 `ES5` 中，`javascript` 通过 `script` 标签引入`js`代码，导致命名容易冲突，杂乱无章，语言自身毫无组织和约束能力，人们不得不用命令空间等方式人为地约束代码，以求达到安全和易用的目的

### 字面量

　　为了解决命名冲突的问题，可以把模块写成一个字面量，所有的模块成员都放到这个对象里面

```js
　　var module1 = new Object({
　　　　_count : 0,
　　　　m1 : function (){
　　　　　　//...
　　　　},
　　　　m2 : function (){
　　　　　　//...
　　　　}
　　});
```

上面的函数 `m1()` 和 `m2(）` ，都封装在 `module1` 对象里。使用的时候，就是调用这个对象的属性

```js
module1.m1();
```

但这种写法会暴露所有模块成员，内部状态可被外部改写。比如，外部代码可以直接改变内部计数器的值

```js
module1._count = 5;
```


## IIFE

使用"立即执行函数"（Immediately-Invoked Function Expression，IIFE）可以达到不暴露私有成员的目的

```js
　　var module1 = (function(){
　　　　var _count = 0;
　　　　var m1 = function(){
　　　　　　//...
　　　　};
　　　　var m2 = function(){
　　　　　　//...
　　　　};
　　　　return {
　　　　　　m1 : m1,
　　　　　　m2 : m2
　　　　};
　　})();
```

使用上面的写法，外部代码无法读取内部的 `_count` 变量

```js
console.info(module1._count); //undefined
```

 

### IIFE传参

如果一个模块需要继承另一个模块，则需要 `IIFE` 传参

```js
　　var module1 = ( function (mod){
　　　　mod.m3 = function () {
　　　　　　//...
　　　　};
　　　　return mod;
　　})(window.module1 || {});
```

 

## 命名空间

如果采用 `IIFE` 的方法，随着模块的增多，仍然污染了全局环境。

而命名空间(Namespace)可以通过只暴露类似于一个 `'namespace'` 的全局变量，来实现所有模块的声明，进而解决全局环境的污染问题

```js
//math.js
namespace('math', [], function(){
  function add(a, b) { return a + b; }
  function sub(a, b) { return a - b; }
  return {
    add: add,
    sub: sub
  }
})
//calculator.js
namespace('calculator', ['math'], function(m){
  var action = 'add';
  function compute(a,b) {
    return m[action](a, b);
  }
  return {
    compute: compute
  }
})
var namespace = (function(){
    //缓存所有模块
    var cache = {};
    function createModule(name/*模块名*/,deps/*依赖列表*/,definition/*定义*/){
        //如果只有模块名，则直接输出
        if(arguments.length === 1){
            return cache[name];
        }
        //取得所有模块的依赖
        deps = deps.map(function(depName){
            return namespace(depName); 
        })
        //初始化模块并返回
        cache[name] = definition.apply(null,deps);
        return cache[name];
    }
    return createModule;
})()
```

 

## 最后

　　虽然，使用命名空间可以解决全局环境污染的问题，但是却无法解决模块依赖管理的问题

　　如下图所示，`module2` 依赖于 `module1` 和 `module3` ，则代码如下

![moduleOrganization1](https://gitee.com/FIF/pic-beg/raw/master/images/javascript/JS_modular_moduleOrganization1.png)

```js
<script src="module1.js"></script>
<script src="module3.js"></script>
<script src="module2.js"></script>
```

　　但，如果模块组织如下所示

![moduleOrganization2](https://gitee.com/FIF/pic-beg/raw/master/images/javascript/JS_modular_moduleOrganization2.png)

　　甚至，如下所示

![moduleOrganization3](https://gitee.com/FIF/pic-beg/raw/master/images/javascript/JS_modular_moduleOrganization3.png)

　　这时，手动地处理模块之间的依赖关系就不现实了，需要使用 `AMD`、`CMD`、`ES6 MODULE` 等来处理