---
title: 闭包
date: 2020-01-21 14:27:01
permalink: /pages/wessseadse
author: 
  name: jeffery
categories: 
  - javascript
tags: 
  - javascript
---


# 闭包

闭包有各种解释

- 1、闭包是指可以访问其所在作用域的函数，`foo` 函数可以访问作用域连的变量

```js
var n = 0;
function foo() {
    console.log(n)//0
}
foo();
```

- 2、闭包是指有权访问另一个函数作用域中的变量的函数，`bar` 函数可以访问 `foo` 函数作用域的变量

```js
function foo(){
    var a = 2;
    function bar(){
        console.log(a); // 2
    }
    bar();
}
foo();
```

- 3、闭包是指在函数声明时的作用域以外的地方被调用的函数，外部函数可以访问另一个函数的变量

```js
function foo(){
    var a = 2;
    function bar(){
        console.log(a); //2
    }
    return bar;
}
foo()();
```

严格来说，闭包需要满足三个条件：
【1】访问所在作用域；
【2】函数嵌套；
【3】在所在作用域外被调用

 有些人觉得只满足条件1就可以，所以 `IIFE` 是闭包；有些人觉得满足条件1和2才可以，所以被嵌套的函数才是闭包；有些人觉得3个条件都满足才可以，所以在作用域以外的地方被调用的函数才是闭包

 ## 闭包的形式

 ### 返回值

函数作为返回值被返回
 ```js
var F = function(){
    var b = 'local';
    var N = function(){
        return b;
    }
    return N;
}
console.log(F()());
 ```

 ### 函数赋值

 内部函数赋值给一个外部变量

 ```js
var inner;
var F = function(){
    var b = 'local';
    var N = function(){
        return b;
    };
    inner = N;
};
F();
console.log(inner());
 ```

 ### 函数参数

 通过函数参数传递函数的形式来实现

 ```js
var Inner = function(fn){
    console.log(fn());
}
var F = function(){
    var b = 'local';
    var N = function(){
        return b;
    }
    Inner(N);
}
F();
 ```

 ### IIFE

 函数 `F()` 都是在声明后立即被调用，因此可以使用 `IIFE` 来替代。但是，要注意的是，这里的 `Inner()` 只能使用函数声明语句的形式，而不能使用函数表达式

 ```js
function Inner(fn){
    console.log(fn());
}
(function(){
    var b = 'local';
    var N = function(){
        return b;
    }
    Inner(N);
})();
 ```

 ### 循环赋值

 在闭包问题上，最常见的一个错误就是循环赋值的错误

 ```js
// 错误写法
function foo(){
    var arr = [];
    for(var i = 0; i < 2; i++){
        arr[i] = function(){
            return i;
        }
    }
    return arr;
}
var bar = foo();
console.log(bar[0]());//2   

// 正确写法
function foo(){
    var arr = [];
    for(var i = 0; i < 2; i++){
        arr[i] = (function fn(j){
            return function test(){
                return j;
            }
        })(i);
    }
    return arr;
}
var bar = foo();
console.log(bar[0]());//0    

 ```

 ### getter 和 setter

 通过提供 `getter()` 和 `setter()` 函数来将要操作的变量保存在函数内部，防止其暴露在外部

 ```js
var getValue,setValue;
(function(){
    var secret = 0;
    getValue = function(){
        return secret;
    }
    setValue = function(v){
        if(typeof v === 'number'){
            secret = v;
        }
    }
})();
console.log(getValue());//0
setValue(1);
console.log(getValue());//1
 ```

### 迭代器

经常使用闭包来实现一个累加器

```js
var add = (function(){
    var counter = 0;
    return function(){
        return ++counter; 
    }
})();
console.log(add())//1
console.log(add())//2  
```

类似地，使用闭包可以很方便的实现一个迭代器

```js
function setup(x){
    var i = 0;
    return function(){
        return x[i++];
    }
}
var next = setup(['a','b','c']);
console.log(next());//'a'
console.log(next());//'b'
console.log(next());//'c'
```

### 区分首次

```js
var firstLoad = (function(){
  var _list = [];
  return function(id){
    if(_list.indexOf(id) >= 0){
      return false;
    }else{
      _list.push(id);
      return true;
    }
  }
})();

firstLoad(10);//true
firstLoad(10);//false
firstLoad(20);//true
firstLoad(20);//false
```

### 缓存机制

通过闭包加入缓存机制，使得相同的参数不用重复计算，来提高函数的性能

未加入缓存机制前的代码如下
```js
var mult = function(){
  var a = 1;
  for(var i = 0,len = arguments.length; i<len; i++){
    a = a * arguments[i];
  }
  return a;
}
```

加入缓存机制后，代码如下
```js
var mult = function(){
  var cache = {};
  var calculate = function(){
    var a = 1;
    for(var i = 0,len = arguments.length; i<len; i++){
      a = a * arguments[i];
    }
    return a;
  };
  return function(){
    var args = Array.prototype.join.call(arguments,',');
    if(args in cache){
      return cache[args];
    }

    return cache[args] = calculate.apply(null,arguments);
  }
}()
```

### img对象

img对象经常用于数据上报

```js
var report = function(src){
  var img = new Image();
  img.src = src;
}
report('http://xx.com/getUserInfo');
```

但是，在一些低版本浏览器中，使用 `report` 函数进行数据上报会丢失 `30%` 左右的数据，也就是说，`report` 函数并不是每一次都成功地发起了 `HTTP` 请求

原因是 `img` 是 `report` 函数中的局部变量，当 `report` 函数的调用结束后，`img` 局部变量随即被销毁，而此时或许还没来得及发出 `HTTP` 请求，所以此次请求就会丢失掉

现在把 `img` 变量用闭包封闭起来，就能解决请求丢失的问题

```js
var report = (function(){
  var imgs = [];
  return function(src){
    var img = new Image();
    imgs.push(img);
    img.src = src;
  }
})()
report('http://xx.com/getUserInfo');
```

## 从执行环境角度看闭包



### 图示

![closure1](https://gitee.com/FIF/pic-beg/raw/master/images/javascript/JS_ECMA_grammer_closure1.png)

 

### 说明

下面按照代码执行流的顺序对该图示进行详细说明

```
function foo(){
    var a = 2;
    function bar(){
        console.log(a);
    }
    return bar;
}
var baz = foo();
baz();
```

【1】代码执行流进入全局执行环境，并对全局执行环境中的代码进行声明提升(hoisting)

![closure2](https://gitee.com/FIF/pic-beg/raw/master/images/javascript/JS_ECMA_grammer_closure2.jpg)

【2】执行流执行第9行代码 `var baz = foo()` ;，调用 `foo()` 函数，此时执行流进入 `foo()` 函数执行环境中，对该执行环境中的代码进行声明提升过程。此时执行环境栈中存在两个执行环境，`foo()` 函数为当前执行流所在执行环境

![closure3](https://gitee.com/FIF/pic-beg/raw/master/images/javascript/JS_ECMA_grammer_closure3.jpg)

【3】执行流执行第2行代码 `var a = 2`;，对a进行 `LHS` 查询，给 `a` 赋值2

![closure4](https://gitee.com/FIF/pic-beg/raw/master/images/javascript/JS_ECMA_grammer_closure4.jpg)

【4】执行流执行第7行代码 `return bar;`，将 `bar()` 函数作为返回值返回。按理说，这时 `foo()` 函数已经执行完毕，应该销毁其执行环境，等待垃圾回收。但因为其返回值是 `bar` 函数。`bar` 函数中存在[自由变量] `a` ，需要通过作用域链到 `foo()` 函数的执行环境中找到变量 `a` 的值，所以虽然 `foo` 函数的执行环境被销毁了，但其变量对象不能被销毁，只是从活动状态变成非活动状态；而全局执行环境的变量对象则变成活动状态；执行流继续执行第9行代码 `var baz = foo();`，把`foo()` 函数的返回值 `bar` 函数赋值给 `baz`

![closure5](https://gitee.com/FIF/pic-beg/raw/master/images/javascript/JS_ECMA_grammer_closure5.jpg)

【5】执行流执行第10行代码 `baz()`;，通过在全局执行环境中查找 `baz` 的值，`baz` 保存着 `foo()` 函数的返回值 `bar`。所以这时执行 `baz()`，会调用`bar()` 函数，此时执行流进入 `bar()` 函数执行环境中，对该执行环境中的代码进行声明提升过程。此时执行环境栈中存在三个执行环境，`bar()` 函数为当前执行流所在执行环境

　　在声明提升的过程中，由于 `a` 是个自由变量，需要通过 `bar()` 函数的作用域链 `bar() -> foo() -> 全局作用域` 进行查找，最终在 `foo()` 函数中也就是代码第2行找到 `var a = 2;` ，然后在 `foo()` 函数的执行环境中找到`a`的值是2，所以给 `a` 赋值2

![closure6](https://gitee.com/FIF/pic-beg/raw/master/images/javascript/JS_ECMA_grammer_closure6.jpg)

【6】执行流执行第5行代码 `console.log(a)`;，调用内部对象`console`，并从`console`对象中 `log` 方法，将 `a` 作为参数传递进入。从 `bar()` 函数的执行环境中找到 `a` 的值是2，所以，最终在控制台显示2

![closure7](https://gitee.com/FIF/pic-beg/raw/master/images/javascript/JS_ECMA_grammer_closure7.jpg)

【7】执行流执行第6行代码}，`bar()`执行环境被弹出执行环境栈，并被销毁，等待垃圾回收，控制权交还给全局执行环境

![closure8](https://gitee.com/FIF/pic-beg/raw/master/images/javascript/JS_ECMA_grammer_closure8.jpg)

【8】当页面关闭时，所有的执行环境都被销毁

### 总结



从上述说明的第5步可以看出，由于闭包 `bar()` 函数的原因，虽然 `foo()` 函数的执行环境销毁了，但其变量对象一直存在于内存中，就是为了能够使得调用 `bar()`函数时，可以通过作用域链访问到父函数 `foo()`，并得到其变量对象中储存的变量值。直到页面关闭，`foo()` 函数的变量对象才会和全局的变量对象一起被销毁，从而释放内存空间

由于闭包占用内存空间，所以要谨慎使用闭包。尽量在使用完闭包后，及时解除引用，以便更早释放内存

```js
//通过将baz置为null，解除引用
function foo(){
    var a = 2;
    function bar(){
        console.log(a);//2
    }
    return bar;
}
var baz = foo();
baz();        
baz = null;
/*后续代码*/
```