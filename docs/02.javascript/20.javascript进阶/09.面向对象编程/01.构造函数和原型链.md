---
title: 构造函数和原型链
date: 2020-02-02 18:27:01
permalink: /pages/waa334eadse
author: 
  name: jeffery
categories: 
  - javascript
tags: 
  - javascript
---


# 构造函数和原型链

`javascript` 使用构造函数和原型对象来进行面向对象编程

## 构造函数和原型对象

构造函数是用 `new` 创建对象时调用的函数，与普通唯一的区别是构造函数名应该首字母大写

```js
function Person(){
    this.age = 30;
}
var person1 = new Person();
console.log(person1.age);//30
```

### 原型对象及prototype

每个函数都有一个 `prototype` 属性，该属性指向一个引用对象，这个对象叫原型对象。

### constructor

原型对象 `prototype` 有一个构造函数属性 `constructor`，其中包含了一个指向其构造函数的引用。

```js
function Person(){
    //
}
var person1 = new Person;
console.log(person1.constructor === Person);//true    
console.log(person1.__proto__.constructor === Person);//true
```

### proto

实例对象内部包含一个proto属性(IE10-浏览器不支持该属性)，指向该实例对象对应的原型对象

```js
function Foo(){};
var f1 = new Foo;
console.log(f1.__proto__ === Foo.prototype);//true
```

**isPrototypeOf()**

通过 `isPrototypeOf()` 方法来确定对象之间是否是实例对象和原型对象的关系

```js
function Foo(){};
var f1 = new Foo;
console.log(f1.__proto__ === Foo.prototype);//true
console.log(Foo.prototype.isPrototypeOf(f1));//true
```

**Object.getPrototypeOf()**

ES5新增了 `Object.getPrototypeOf()` 方法，该方法返回实例对象对应的原型对象　

```js
function Foo(){};
var f1 = new Foo;
console.log(Object.getPrototypeOf(f1) === Foo.prototype);//true
```

### 属性查找

当读取一个对象的属性时，`javascript` 引擎首先在该对象的自有属性中查找属性名字。如果找到则返回。如果自有属性不包含该名字，则` javascript会` 搜索 `proto` 中的对象。如果找到则返回。如果找不到，则返回 `undefined`

```js
var o = {};
console.log(o.toString());//'[object Object]'
o.toString = function(){
    return 'o';
}
console.log(o.toString());//'o'
delete o.toString;
console.log(o.toString());//'[objet Object]'
```

**in 操作符**

`in` 操作符可以判断属性在不在该对象上，但无法区别自有还是继承属性

```js
var o = {a:1};
var obj = Object.create(o);
obj.b = 2;
console.log('a' in obj);//true
console.log('b' in obj);//true
console.log('b' in o);//false
```

**hasOwnProperty()**

通过 `hasOwnProperty()` 方法可以确定该属性是自有属性还是继承属性

```js
var o = {a:1};
var obj = Object.create(o);
obj.b = 2;
console.log(obj.hasOwnProperty('a'));//false
console.log(obj.hasOwnProperty('b'));//true
```

将 `hasOwnProperty`方法和 `in` 运算符结合起来使用，用来鉴别原型属性

```js
function hasPrototypeProperty(object,name){
    return name in object && !object.hasOwnProperty(name);
}
```
## prototype、proto和constructor关系

以下面的代码为事例

```js
function Foo(){};
var f1 = new Foo;
```

**关系图**

### 定义的构造函数

![proto](https://gitee.com/FIF/pic-beg/raw/master/images/javascript/JS_ECMA_grammer_proto.png)

实例对象 `f1` 是通过构造函数 `Foo()` 的 `new` 操作创建的。构造函数 `Foo()` 的原型对象是 `Foo.prototype` ；实例对象 `f1` 通过 `__proto__` 属性也指向原型对象 `Foo.prototype`

实例对象 `f1` 本身并没有 `constructor` 属性，但它可以继承原型对象 `Foo.prototype` 的 `constructor` 属性

```js
function Foo(){};
var f1 = new Foo;
console.log(Foo.prototype.constructor === Foo);//true
console.log(f1.constructor === Foo);//true
console.log(f1.hasOwnProperty('constructor'));//false
```

### Object 函数

`Foo.prototype` 作为实例对象，它的构造函数是 `Object()`，原型对象是 `Object.prototype` 。相应地，构造函数 `Object()` 的`prototype`属性指向原型对象 `Object.prototype`；实例对象 `Foo.prototype` 的 `proto` 属性同样指向原型对象 `Object.prototype`



![proto3](https://gitee.com/FIF/pic-beg/raw/master/images/javascript/JS_ECMA_grammer_proto3.jpg)

### Function 函数

函数也是对象，任何函数都可以看做是通过 `Function()` 构造函数的 `new` 操作实例化的结果

![proto5](https://gitee.com/FIF/pic-beg/raw/master/images/javascript/JS_ECMA_grammer_proto5.jpg)



如果把函数 `Foo` 当成实例对象的话，其构造函数是 `Function()`，其原型对象是 `Function.prototype`；类似地，函数`Object` 的构造函数也是 `Function()`，其原型对象是`Function.prototype`

```js
function Foo(){};
var f1 = new Foo;
console.log(Foo.__proto__ === Function.prototype);//true
console.log(Object.__proto__ === Function.prototype);//true
```

原型对象 `Function.prototype` 的 `constructor` 属性指向构造函数 `Function()`；实例对象 `Object` 和 `Foo` 本身没有 `constructor` 属性，需要继承原型对象 `Function.prototype` 的 `constructor` 属性

```js
function Foo(){};
var f1 = new Foo;
console.log(Function.prototype.constructor === Function);//true
console.log(Foo.constructor === Function);//true
console.log(Foo.hasOwnProperty('constructor'));//false
console.log(Object.constructor === Function);//true
console.log(Object.hasOwnProperty('constructor'));//false
```

所有的函数都可以看成是构造函数 `Function()` 的 `new` 操作的实例化对象。那么，`Function` 可以看成是调用其自身的 `new` 操作的实例化的结果

所以，如果 `Function` 作为实例对象，其构造函数是 `Function` ，其原型对象是 `Function.prototype`

```js
console.log(Function.__proto__ === Function.prototype);//true
console.log(Function.prototype.constructor === Function);//true
console.log(Function.prototype === Function.prototype);//true
```
`
所有的对象都可以看成是 `Object()` 构造函数的 `new` 操作的实例化结果。所以，`Function.prototype` 的原型对象是 `Object.prototype`，其原型函数是`Object()`

```js
console.log(Function.prototype.__proto__ === Object.prototype);//true
```

`Object.prototype` 的原型对象是 `null`

```js
console.log(Object.prototype.__proto__ === null);//true

```

## 总结

【1】函数(`Function`也是函数)是 `new Function` 的结果，所以函数可以作为实例对象，其构造函数是`Function()`，原型对象是`Function.prototype`

【2】对象(函数也是对象)是 `new Object` 的结果，所以对象可以作为实例对象，其构造函数是 `Object()`，原型对象是 `Object.prototype`

【3】`Object.prototype` 的原型对象是 `null`