---
title: 创建对象模式
date: 2020-02-04 18:37:01
permalink: /pages/aewewssdeadse
author: 
  name: jeffery
categories: 
  - javascript
tags: 
  - javascript
---


# 创建对象模式


## 对象字面量

有三种方式来创建对象，包括 `new` 构造函数、对象直接量和 `Object.create()` 函数

```js
var person1 = {
    name: "bai",
    age : 29,
    job: "Software Engineer",
    sayName: function(){
        alert(this.name);
    }
};
```

**缺点**：对象字面量可以用来创建单个对象，但如果要创建多个对象，会产生大量的重复代码

## 工厂模式

为了解决上述问题，开始使用工厂模式。该模式抽象了创建具体对象的过程，用函数来封装以特定接口创建对象的细节

```js
function createPerson(name,age,job){
    var o = new Object();
    o.name = name;
    o.age = age;
    o.job = job;
    o.sayname = function(){
        alert(this.name);
    }
    return o;
}
var person1 = createPerson('bai',29,'software Engineer');
```

**缺点**：工厂模式虽然解决了创建多个相似对象的问题，但没有解决对象识别的问题，因为使用该模式并没有给出对象的类型


## 构造函数模式

创建自定义的构造函数，来自定义对象类型的属性和方法。该模式没有显式地创建对象，直接将属性和方法赋给了 `this` 对象，且没有 `return` 语句

```js
function Person(name,age,job){
    this.name = name;
    this.age = age;
    this.jog = job;
    this.sayName = function(){
        alert(this.name);
    };
}
```

**缺点**：使用构造函数的主要问题是每个方法都要在每个实例上重新创建一遍，创建多个完成相同任务的方法完全没有必要，浪费内存空间


## 寄生构造函数模式

该模式的基本思想是创建一个函数，该函数的作用仅仅是封装创建对象的代码，然后再返回新创建的对象。该模式是工厂模式和构造函数模式的结合

```js
function Person(name,age,job){
    var o = new Object();
    o.name = name;
    o.age = age;
    o.job = job;
    o.sayName = function(){
        console.log(this.name);
    };
    return o;
}
```

**缺点**：寄生构造函数模式与构造函数模式有相同的问题，每个方法都要在每个实例上重新创建一遍，创建多个完成相同任务的方法完全没有必要，浪费内存空间


## 原型模式

使用原型对象，可以让所有实例共享它的属性和方法。换句话说，不必在构造函数中定义对象实例的信息，而是可以将这些信息直接添加到原型对象中

```js
function Person(){};
Person.prototype = {
    name: "bai",
    age: 29,
    job: "software Engineer",
    sayName : function(){
        console.log(this.name);
    }
};
Object.defineProperty(Person.prototype,'constructor',{
    enumerable: false,
    value: Person
});
```

**缺点**：原型模式问题在于引用类型值属性会被所有的实例对象共享并修改

## 组合模式

组合使用构造函数模式和原型模式是创建自定义类型的最常见方式。构造函数模式用于定义实例属性，而原型模式用于定义方法和共享的属性，这种组合模式还支持向构造函数传递参数。实例对象都有自己的一份实例属性的副本，同时又共享对方法的引用，最大限度地节省了内存。该模式是目前使用最广泛、认同度最高的一种创建自定义对象的模式

```js
nction Person(name,age,job){
    this.name = name;
    this.age = age;
    this.job = job;
    this.friends = ["shelby","Court"];
}
Person.prototype = {
    constructor: Person,
    sayName : function(){
        console.log(this.name);
    }    
}
```



## 总结

- 使用对象字面量形式创建一个对象，创建多个对象会造成代码冗余；

- 使用工厂模式可以解决该问题，但存在对象识别的问题；
- 构造函数模式，该模式解决了对象识别的问题，但存在关于方法的重复创建问题；
- 原型模式，该模式的特点就在于共享，但引出了引用类型值属性会被所有的实例对象共享并修改的问题；
- 构造函数和原型组合模式，构造函数模式用于定义实例属性，而原型模式用于定义方法和共享的属性，这种组合模式还支持向构造函数传递参数，该模式是目前使用最广泛的一种模式