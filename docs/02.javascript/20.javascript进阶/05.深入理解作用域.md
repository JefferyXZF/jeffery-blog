---
title: 深入理解javascript作用域
date: 2020-01-20 14:27:01
permalink: /pages/wewweseadse
author: 
  name: jeffery
categories: 
  - javascript
tags: 
  - javascript
---

# 作用域、作用域链、执行上下文

![scope1](https://gitee.com/FIF/pic-beg/raw/master/images/javascript/JS_ECMA_grammer_scope1.png)

[查看大图](https://www.processon.com/view/link/599efadee4b0920e4be0c186)


## 作用域

作用域是指程序源代码中定义变量的区域。

作用域是一套规则，用于确定在何处以及如何查找标识符（变量），查询分为 `RHS` 查询 和 `LHS` 查询


### 词法作用域和动态作用域

作用域分为词法作用域和动态作用域。`javascript` 使用的是词法作用域，词法作用域就是定义在词法阶段的作用域，是由写代码时将变量和函数写在哪里来决定的。

它们两者的区别，在词法作用域中函数的作用域在**函数定义**的时候就决定了；而动态作用域是在**函数执行**的时候才确定函数的作用域。

举例子，请看下面代码:
```js
var value = 1;

function foo() {
    console.log(value);
}

function bar() {
    var value = 2;
    foo();
} 

bar();

// 结果是 ???
```

假设 `JavaScript` 采用词法作用域，让我们分析下执行过程：

执行 `foo` 函数，先从 `foo` 函数内部查找是否有局部变量 `value`，如果没有，就根据书写的位置，查找上面一层的代码，也就是 `value` 等于 1，所以结果会打印 1。

假设 `JavaScript` 采用动态作用域，让我们分析下执行过程：

执行 `foo` 函数，依然是从 `foo` 函数内部查找是否有局部变量 `value`。如果没有，就从调用函数的作用域，也就是 `bar` 函数内部查找 `value` 变量，所以结果会打印 2。

前面我们已经说了，`JavaScript` 采用的是静态作用域，所以这个例子的结果是 1。


**作用域分为全局作用域和函数作用域，函数作用域可以互相嵌套**

在下面的例子中，存在着全局作用域，`fn` 作用域和 `bar` 作用域，它们相互嵌套

![scope2](https://gitee.com/FIF/pic-beg/raw/master/images/css/JS_ECMA_grammer_scope2.jpg)


## 执行环境

执行环境(execution context)，有时也称为执行上下文、执行上下文环境或环境，定义了变量或函数有权访问的其他数据。每个执行环境都有一个与之关联的 **变量对象**(variable object)，环境中定义的所有变量和函数都保存在这个对象中

一定要区分执行环境和变量对象。执行环境会随着函数的调用和返回，不断的重建和销毁。但变量对象在有变量引用(如闭包)的情况下，将留在内存中不被销毁

![scope2](https://gitee.com/FIF/pic-beg/raw/master/images/css/JS_ECMA_grammer_scope2.jpg)

`JavaScript` 在执行前会做“准备工作”，这个过程会创建“执行上下文”，执行上下文分为全局执行上下文、函数执行上下文、`eval` 执行上下文。

当程序开始执行时，会创建一个全局执行上下文，如果遇到函数则创建函数执行上下文，每个执行函数都会创建一个不同的执行上下文，嵌套函数也不例外，那么这么多执行上下文是通过什么管理的呢？

**执行环境栈**

有那么多执行环境，那么 `JavaScript` 是怎么知道哪个是先执行，哪个是后执行。答案是通过执行环境栈

执行环境栈是后进先出的数据结构，类型浏览器的前进后退，有序地保存着当前程序中存在的执行环境。当执行流进入一个函数时，函数的环境就会被推入一个环境栈中。而在函数执行之后，栈将其环境弹出，把控制权返回给之前的执行环境。`javascript` 程序中的执行流正是由这个机制控制着

在例子中，当执行流进入 `bar(20)` 函数时，当前程序的执行环境栈如下图所示，其中黄色的`bar(20)`执行环境表示当前程序正处此执行环境中

![scope6](https://gitee.com/FIF/pic-beg/raw/master/images/javascript/JS_ECMA_grammer_scope6.jpg)



当 `bar(20)` 函数执行完成后，当前程序的执行环境栈如下图所示，`bar(20)` 函数的执行环境被销毁，等待垃圾回收，控制权交还给黄色背景的 `fn(0)` 执行环境

![scope7](https://gitee.com/FIF/pic-beg/raw/master/images/javascript/JS_ECMA_grammer_scope7.jpg)

## 创建执行上下文

创建执行上下文，会同时创建三个重要属性：

- 变量对象(Variable object，VO)
- 作用域链(Scope chain)
- this

首先介绍变量对象。

### 变量对象


变量对象是与执行上下文相关的数据作用域，存储了在上下文中定义的变量和函数声明。

变量对象包括：

- 函数的所有形参 (如果是函数上下文)
   - 由名称和对应值组成的一个变量对象的属性被创建
   - 没有实参，属性值设为 `undefined`
- 函数声明
   - 由名称和对应值（函数对象(function-object)）组成一个变量对象的属性被创建
   - 如果变量对象已经存在相同名称的属性，则完全替换这个属性
- 变量声明
   - 由名称和对应值（undefined）组成一个变量对象的属性被创建；
   - 如果变量名称跟已经声明的形式参数或函数相同，则变量声明不会干扰已经存在的这类属性


举个例子：

```js
function foo(a) {
  var b = 2;
  function c() {}
  var d = function() {};

  b = 3;

}

foo(1);
```

在进入执行上下文后，这时候的 AO 是：

```js
AO = {
    arguments: {
        0: 1,
        length: 1
    },
    a: 1,
    b: undefined,
    c: reference to function c(){},
    d: undefined
}
```



**代码执行**

在代码执行阶段，会顺序执行代码，根据代码，修改变量对象的值

还是上面的例子，当代码执行完后，这时候的 AO 是：

```
AO = {
    arguments: {
        0: 1,
        length: 1
    },
    a: 1,
    b: 3,
    c: reference to function c(){},
    d: reference to FunctionExpression "d"
}
```

到这里变量对象的创建过程就完了，总结上面的过程：

1. 全局上下文的变量对象初始化是全局对象
2. 函数上下文的变量对象初始化只包括 `Arguments` 对象
3. 在进入执行上下文时会给变量对象添加形参、函数声明、变量声明等初始的属性值
4. 在代码执行阶段，会再次修改变量对象的属性值


作用域分为全局作用域和函数作用域，函数作用域可以互相嵌套

在下面的例子中，存在着全局作用域，`fn` 作用域和 `bar` 作用域，它们相互嵌套


### 作用域链

各个作用域的嵌套关系组成了一条作用域链。上面 `bar` 函数保存的作用域链是 `bar -> fn -> 全局`，`fn` 函数保存的作用域链是 `fn -> 全局`

使用作用域链主要是进行标识符的查询，标识符解析就是沿着作用域链一级一级地搜索标识符的过程，而作用域链就是要保证对变量和函数的有序访问

【1】如果自身作用域中声明了该变量，则无需使用作用域链

在下面的例子中，如果要在 `bar` 函数中查询变量 `a`，则赋值为100即可

```js
var a = 1;
function fn(x){
    var a = 10;
}
fn(0);
```

【2】如果自身作用域中未声明该变量，则需要使用作用域链进行查找

这时，就引出了另一个概念——**自由变量**。在当前作用域中存在但未在当前作用域中声明的变量叫自由变量

如果要在 `bar` 函数中查询变量 `b`，由于 `b` 并没有在当前作用域中声明，所以 `b` 是自由变量。`bar` 函数的作用域链是 `bar -> fn -> 全局`。到上一级 `fn` 作用域中查找 `b` 没有找到，继续到再上一级全局作用域中查找`b`，找到了 `b`

```js
var a = 1;
var b = 2;
function fn(x){
    var a = 10;
    function bar(x){
        var a = 100;
        b = x + a;
        return b;
    }
    bar(20);
    bar(200);
}
fn(0);
```

如果标识符没有找到，则需要分为 `RHS` 和 `LHS` 查询进行分析，若进行的是 `LHS` 查询，则在全局环境中声明该变量，若是严格模式下的 `LHS` 查询，则抛出 `ReferenceError` (引用错误)异常；若进行的是 `RHS` 查询，则抛出ReferenceError(引用错误)异常

### 确定 this 的指向

在 `JavaScript` 中，`this` 指向执行当前代码对象的所有者，可简单理解为 `this` 指向最后调用当前代码的那个对象。相信大家都很熟悉 `this`，因此这里我就进行结论性的简单总结。

根据 `JavaScript` 中函数的调用方式不同，this的指向分为以下情况。


![img](https://gitee.com/FIF/pic-beg/raw/master/images/javascript/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_16267850442886.png)

- 在全局环境中，`this` 指向全局对象（在浏览器中为 `window`）

- 在函数内部，`this` 的值取决于函数被调用的方式

  - 函数作为对象的方法被调用，`this` 指向调用这个方法的对象

  - 函数用作构造函数时（使用`new` 关键字），它的 `this` 被绑定到正在构造的新对象

  - 在类的构造函数中，`this` 是一个常规对象，类中所有非静态的方法都会被添加到 `this` 的原型中

- 在箭头函数中，`this` 指向它被创建时的环境

- 使用 `apply`、`call`、`bind` 等方式调用：根据 `API` 不同，可切换函数执行的上下文环境，即 `this` 绑定的对象

可以看到，`this` 在不同的情况下会有不同的指向，在 `ES6` 箭头函数还没出现之前，为了能正确获取某个运行环境下 `this` 对象，我们常常会使用 `var that = this;、var self = this;` 这样的代码将变量分配给 `this`，便于使用。这种方式降低了代码可读性，因此如今这种做法不再被提倡，通过正确使用箭头函数，我们可以更好地管理作用域。


## 执行流程分析


下面按照代码执行流的顺序对该图示进行详细说明

![scope8](https://gitee.com/FIF/pic-beg/raw/master/images/javascript/JS_ECMA_grammer_scope2.jpg)

【1】代码执行流进入全局执行环境，并对全局执行环境中的代码进入声明提升(hoisting)

![scope9](https://gitee.com/FIF/pic-beg/raw/master/images/javascript/JS_ECMA_grammer_scope9.jpg)

【2】执行流执行第1行代码 `var a = 1;`，对 `a` 进行 `LHS` 查询，给 `a` 赋值1；执行流执行第2行代码 `var b = 2`;，对 `b` 进行 `LHS` 查询，给 `b` 赋值2

![scope10](https://gitee.com/FIF/pic-beg/raw/master/images/javascript/JS_ECMA_grammer_scope10.jpg)

【3】执行流执行第15行代码 `fn(0)`;，调用 `fn(0)` 函数，此时执行流进入 `fn(0)` 函数执行环境中，对该执行环境中的代码进行声明提升过程，并将实参 `0` 赋值给形参 `x` 中。此时执行环境栈中存在两个执行环境，`fn(0)` 函数为当前执行流所在执行环境

![scope11](https://gitee.com/FIF/pic-beg/raw/master/images/javascript/JS_ECMA_grammer_scope11.jpg)

　　【4】执行流执行第5行代码 `var a = 10;`，对 `a` 进行 `LHS` 查询，给 `a` 赋值10

![scope12](https://gitee.com/FIF/pic-beg/raw/master/images/javascript/JS_ECMA_grammer_scope12.jpg)

　　【5】执行流执行第12行代码 `bar(20)`;，调用 `bar(20)` 函数，此时执行流进入 `bar(20)` 函数执行环境中，对该执行环境中的代码进行声明提升过程，并将实参 20 赋值给形参 `x` 中。此时执行环境栈中存在三个执行环境，`bar(20)` 函数为当前执行流所在执行环境

在声明提升的过程中，由于 `b` 是个自由变量，需要通过 `bar()` 函数的作用域链 `bar() -> fn() -> 全局作用域` 进行查找，最终在全局作用域中也就是代码第2行找到 `var b = 2`;，然后在全局执行环境中找到`b` 的值是2，所以给 `b` 赋值2

![scope13](https://gitee.com/FIF/pic-beg/raw/master/images/javascript/JS_ECMA_grammer_scope13.png)

　　【6】执行流执行第8行代码 `var a = 100;`，给 `a` 赋值100；执行流执行第9行 `b = x + a;`，对 `x` 进行 `RHS` 查询，找到 `x` 的值是 20，对 `a` 进行 `RHS` 查询，找到 `a` 的值是100，所以通过计算 `b` 的值是120，给 `b` 赋值120；执行第10行代码 `return b;`，对 `b` 进行 `RHS` 查询，找到 `b` 的值是120，所以函数返回值为120

![scope14](https://gitee.com/FIF/pic-beg/raw/master/images/javascript/JS_ECMA_grammer_scope14.png)

　　【7】执行流执行完第10行代码后，`bar(20)` 的执行环境被弹出执行环境栈，并被销毁，等待垃圾回收，控制权交还给 `fn(0)` 函数的执行环境

![scope15](https://gitee.com/FIF/pic-beg/raw/master/images/javascript/JS_ECMA_grammer_scope15.png)

【8】执行流执行第13行代码 `bar(200)`;，调用 `bar(200)` 函数，此时执行流进入 `bar(200)` 函数执行环境中，对该执行环境中的代码进行声明提升过程，并将实参200赋值给形参 `x` 中。此时执行环境栈中存在三个执行环境，`bar(200)` 函数为当前执行流所在执行环境

与第5步相同，在声明提升的过程中，由于b是个自由变量，需要通过`bar()` 函数的作用域链 `bar() -> fn() -> 全局作用域` 进行查找，最终在全局作用域中也就是代码第2行找到 `var b = 2;`，然后在全局执行环境中找到 `b` 的值是2，所以给 `b` 赋值 2

![scope16](https://gitee.com/FIF/pic-beg/raw/master/images/javascript/JS_ECMA_grammer_scope16.png)

【9】与第6步相同，执行流执行第8行代码 `var a = 100;`，给 `a` 赋值 `100`；执行流执行第9行 `b = x + a;`，对 `x` 进行 `RHS` 查询，找到 `x` 的值是 20，对 `a` 进行 `RHS` 查询，找到 `a` 的值是100，所以通过计算 `b` 的值是120，给 `b` 赋值120；执行第10行代码`return b;`，对 `b` 进行 `RHS` 查询，找到 `b` 的值是120，所以函数返回值为120

![scope17](https://gitee.com/FIF/pic-beg/raw/master/images/javascript/JS_ECMA_grammer_scope17.png)

【10】执行流执行完第10行代码后，`bar(200)` 的执行环境被弹出执行环境栈，并被销毁，等待垃圾回收，控制权交还给 `fn(0)` 函数的执行环境

![scope18](https://gitee.com/FIF/pic-beg/raw/master/images/javascript/JS_ECMA_grammer_scope18.png)

【11】执行流执行第14行代码}，`fn(0)` 的执行环境被弹出执行环境栈，并被销毁，等待垃圾回收，控制权交还给全局执行环境

![scope19](https://gitee.com/FIF/pic-beg/raw/master/images/javascript/JS_ECMA_grammer_scope19.png)

【12】当页面关闭时，全局执行环境被销毁，页面再无执行环境

![scope20](https://gitee.com/FIF/pic-beg/raw/master/images/javascript/JS_ECMA_grammer_scope20.jpg)

