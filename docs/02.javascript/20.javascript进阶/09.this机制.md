---
title: this 机制
date: 2020-01-24 18:27:01
permalink: /pages/waaeadse
author: 
  name: jeffery
categories: 
  - javascript
tags: 
  - javascript
---


# this 机制

在`JavaScript`执行的时候，会创建执行上下文确定 `this` 的指向，`this` 的指向与它调用的位置无关，这时候 `this` 不遵守 `JavaScript` 词法作用域，遵循的是动态作用域，谁调用它，它就指向谁。

## this 的4种绑定规则

### 默认绑定

全局环境中，`this` 默认绑定到 `window`

```js
console.log(this === window);//true
```

函数独立调用时，`this` 默认绑定到 `window`

```js
function foo(){
    console.log(this === window);
}
foo(); //true
```

被嵌套的函数独立调用时，`this` 默认绑定到 `window`

```js
//虽然test()函数被嵌套在obj.foo()函数中，但test()函数是独立调用，而不是方法调用。所以this默认绑定到window
var a = 0;
var obj = {
    a : 2,
    foo:function(){
            function test(){
                console.log(this.a);
            }
            test();
    }
}
obj.foo();//0
```

`IIFE` 立即执行函数实际上是函数声明后直接调用执行

```js
var a = 0;
var obj = {
    a : 2,
    foo:function(){
            function test(){
                console.log(this.a);
            }
            test();
    }
}
obj.foo();//0
```

闭包

`test()` 函数是独立调用，而不是方法调用，所以 `this` 默认绑定到 `window`

```js
var a = 0;
function foo(){
    function test(){
        console.log(this.a);
    }
    return test;
};
var obj = {
    a : 2,
    foo:foo
}
obj.foo()();//0
```

由于闭包的 `this` 默认绑定到 `window` 对象，但又常常需要访问嵌套函数的`this`，所以常常在嵌套函数中使用 `var that = this`，然后在闭包中使用 `that` 替代 `this`，使用作用域查找的方法来找到嵌套函数的 `this` 值

```js
var a = 0;
function foo(){
    var that = this;
    function test(){
        console.log(that.a);
    }
    return test;
};
var obj = {
    a : 2,
    foo:foo
}
obj.foo()();//2
```

### 隐式绑定

被直接对象所包含的函数调用时，也称为方法调用，`this` 隐式绑定到该直接对象

```js
function foo(){
    console.log(this.a);
};
var obj1 = {
    a:1,
    foo:foo,
    obj2:{
        a:2,
        foo:foo
    }
}

//foo()函数的直接对象是obj1，this隐式绑定到obj1
obj1.foo();//1

//foo()函数的直接对象是obj2，this隐式绑定到obj2
obj1.obj2.foo();//2
```

**隐式丢失**

隐式丢失是指被隐式绑定的函数丢失绑定对象，从而默认绑定到 `window`。这种情况容易出错却又常见

【函数别名】

```js
var a = 0;
function foo(){
    console.log(this.a);
};
var obj = {
    a : 2,
    foo:foo
}
//把obj.foo赋予别名bar，造成了隐式丢失，因为只是把foo()函数赋给了bar，而bar与obj对象则毫无关系
var bar = obj.foo;
bar();//0
```

【内置函数】

```js
var a = 0;
function foo(){
    console.log(this.a);
};
var obj = {
    a : 2,
    foo:foo
}
setTimeout(obj.foo,100);//0
```

【间接引用】

 函数的"间接引用"一般都在无意间创建，最容易在赋值时发生，会造成隐式丢失

```js
function foo() {
    console.log( this.a );
}
var a = 2;
var o = { a: 3, foo: foo };
var p = { a: 4 };
o.foo(); // 3
//将o.foo函数赋值给p.foo函数，然后立即执行。相当于仅仅是foo()函数的立即执行
(p.foo = o.foo)(); // 2
```

【其他情况】

在 `javascript` 引擎内部，`obj` 和 `obj.foo` 储存在两个内存地址，简称为M1和M2。只有 `obj.foo()` 这样调用时，是从M1调用M2，因此 `this` 指向`obj`。但是，下面三种情况，都是直接取出M2进行运算，然后就在全局环境执行运算结果（还是M2），因此 `this` 指向全局环境

```js
var a = 0;
var obj = {
    a : 2,
    foo:foo
};
function foo() {
    console.log( this.a );
};

(obj.foo = obj.foo)();//0

(false || obj.foo)();//0

(1, obj.foo)();//0

```

### 显式绑定

通过 `call()`、`apply()`、`bind()` 方法把对象绑定到 `this` 上，叫做显式绑定。对于被调用的函数来说，叫做间接调用

```js
var a = 0;
function foo(){
    console.log(this.a);
}
var obj = {
    a:2
};
foo();//0
foo.call(obj);//2
```

【API】

`javascript` 中新增了许多内置函数，具有显式绑定的功能，如数组的5个迭代方法：`map()`、`forEach()`、`filter()`、`some()`、`every()`

```js
var id = 'window';
function foo(el){
    console.log(el,this.id);
}
var obj = {
    id: 'fn'
};
[1,2,3].forEach(foo);//1 "window" 2 "window" 3 "window"
[1,2,3].forEach(foo,obj);//1 "fn" 2 "fn" 3 "fn"
```

### new绑定

如果函数或者方法调用之前带有关键字 `new`，它就构成构造函数调用。对于 `this` 绑定来说，称为 `new` 绑定

【1】构造函数通常不使用 `return` 关键字，它们通常初始化新对象，当构造函数的函数体执行完毕时，它会显式返回。在这种情况下，构造函数调用表达式的计算结果就是这个新对象的值

```js
function fn(){
    this.a = 2;
}
var test = new fn();
console.log(test);//{a:2}
```

【2】如果构造函数使用 `return` 语句但没有指定返回值，或者返回一个原始值，那么这时将忽略返回值，同时使用这个新对象作为调用结果

```js
function fn(){
    this.a = 2;
    return;
}
var test = new fn();
console.log(test);//{a:2}
```

【3】如果构造函数显式地使用return语句返回一个对象，那么调用表达式的值就是这个对象

```js
var obj = {a:1};
function fn(){
    this.a = 2;
    return obj;
}
var test = new fn();
console.log(test);//{a:1}

```

::: warning
尽管有时候构造函数看起来像一个方法调用，它依然会使用这个新对象作为 `this`。也就是说，在表达式`new o.m()`中，`this` 并不是 `o`
:::

```js
var o = {
    m: function(){
        return this;
    }
}
var obj = new o.m();
console.log(obj,obj === o);//{} false
console.log(obj.constructor === o.m);//true
```

### 严格模式

【1】严格模式下，独立调用的函数的 `this` 指向 `undefined`

```js
function fn(){
    'use strict';
    console.log(this);//undefined
}
fn();

function fn(){
    console.log(this);//window
}
fn();
```

2】在非严格模式下，使用函数的 `call()` 或 `apply()` 方法时，`null` 或`undefined` 值会被转换为全局对象。而在严格模式下，函数的 `this` 值始终是指定的值

```js
var color = 'red';
function displayColor(){
    console.log(this.color);
}
displayColor.call(null);//red

var color = 'red';
function displayColor(){
    'use strict';
    console.log(this.color);
}
displayColor.call(null);//TypeError: Cannot read property 'color' of null
```

总结：`this` 的四种绑定规则：默认绑定、隐式绑定、显式绑定和 `new` 绑定，分别对应函数的四种调用方式：独立调用、方法调用、间接调用和构造函数调用。

## this 绑定优先级

### 显式绑定 vs 隐式绑定

显式绑定优先级高

```js
function foo() {
    console.log( this.a );
}
var obj1 = {
    a: 2,
    foo: foo
};
var obj2 = {
    a: 3,
    foo: foo
};
obj1.foo(); // 2
obj2.foo(); // 3
//在该语句中，显式绑定call(obj2)和隐式绑定obj1.foo同时出现，最终结果为3，说明被绑定到了obj2中
obj1.foo.call( obj2 ); // 3
obj2.foo.call( obj1 ); // 2
```

### new绑定 vs 隐式绑定

`new` 绑定优先级高

```js
function foo(something) {
    this.a = something;
}
var obj1 = {foo: foo};
var obj2 = {};
obj1.foo( 2 );
console.log( obj1.a ); // 2
obj1.foo.call(obj2,3);
console.log( obj2.a ); // 3
//在下列代码中，隐式绑定obj1.foo和new绑定同时出现。最终obj1.a结果是2，而bar.a结果是4，说明this被绑定在bar上
var bar = new obj1.foo( 4 );
console.log( obj1.a ); // 2
console.log( bar.a ); // 4
```


### new绑定 vs 显式绑定

`new` 绑定优先级高

```js
function foo(something) {
    this.a = something;
}
var obj1 = {};
//先将obj1绑定到foo函数中，此时this值为obj1
var bar = foo.bind( obj1 );
bar( 2 );
console.log(obj1.a); // 2
//通过new绑定，此时this值为baz
var baz = new bar( 3 );
console.log( obj1.a ); // 2
//说明使用new绑定时，在bar函数内，无论this指向obj1有没有生效，最终this都指向新创建的对象baz
console.log( baz.a ); // 3
```

绑定优先级顺序

【1】是否是new绑定？如果是，`this` 绑定的是新创建的对象
【2】是否是显式绑定？如果是，`this` 绑定的是指定的对象
【3】是否是隐式绑定？如果是，`this` 绑定的是属于的对象
【4】如果都不是，则使用默认绑定

## 箭头函数

箭头函数根据当前的词法作用域而不是根据 `this` 机制顺序来决定 `this`，所以，上面4种绑定规则对箭头函数都不生效，箭头函数会继承外层函数调用的 `this` 绑定，而无论 `this` 绑定到什么

```js
function foo() {
    setTimeout(() => {
        console.log( this.a );
    },100);
}
var obj = {
    a: 2
};
foo.call( obj ); // 2
```

### 箭头函数使用陷阱

　【1】`this` 在箭头函数中被绑定，4种绑定规则中的无论哪种都无法改变其绑定

```js
var a = 0;
function foo(){
    var test = () => {
        console.log(this.a);
    }
    return test;
};
var obj1 = {
    a : 1,
    foo:foo
}
var obj2 = {
    a : 2,
    foo:foo    
}
obj1.foo()();//1
var bar = foo.call(obj1);
//由于上一条语句已经把this绑定到obj1上，且无法修改。所以本条语句call(obj2)无效，返回的值是obj1.a的值1
bar.call(obj2);//1
```

【2】箭头函数不可以当作构造函数，也就是不可以使用 `new` 命令，否则会报错

```js
var foo = () =>{return 1;}
foo();//1
var obj = new foo();//Uncaught TypeError: foo is not a constructor
```

【3】箭头函数中不存在 `arguments` 对象

```js
var foo = () =>{
    console.log(arguments);//Uncaught ReferenceError: arguments is not defined
    return 1;
}
foo();

```

**总结**

箭头函数可以把作用域和 `this` 机制联系起来，但是却容易混淆，使代码难以维护。应该在作用域和 `this` 机制中二选一，否则它们就真的汇成一锅粥了。或者只使用词法作用域，或者只使用 `this` 机制，必要时使用 `bind()`。尽量避免使用 `that=this` 和箭头函数