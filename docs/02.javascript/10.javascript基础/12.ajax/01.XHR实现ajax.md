---
title: XHR 实现 Ajax
date: 2020-03-14 14:27:01
permalink: /pages/23aseedasweew
author: 
  name: jeffery
categories: 
  - javascript
tags: 
  - javascript
---


# XHR 实现 Ajax


## XHR对象

`ajax` 通过原生的 `XMLHttpRequest` 对象发送 `HTTP` 请求，得到服务器响应数据后，无刷新更新页面

`ajax` 发送和响应包括以下几步骤：
1、创建 `AJAX` 对象；
2、发出 `HTTP` 请求；
3、接收服务器传回的数据；
4、更新网页数据

### 创建

创建一个 `XHR` 对象，也叫实例化一个 `XHR` 对象，因为`XMLHTTPRequest()`是一个构造函数。下面是创建 `XHR` 对象的兼容写法
```js
var xhr;
if(window.XMLHttpRequest){
    xhr = new XMLHttpRequest();
}else{
    xhr = new ActiveXObject('Microsoft.XMLHTTP');
}
```

### 发送请求

**open**

在使用 `XHR` 对象时，要调用的第一个方法是 `open()`，如下所示，该方法接受3个参数

```js
xhr.open("get","example.do", false);
```

- 1、`open()` 方法的第一个参数用于指定发送请求的方式，这个字符串，不区分大小写，但通常使用大写字母。例如 `GET` 和` POST`
- 2、`open()` 方法的第二个参数是 `URL` ，该 `URL` 相对于执行代码的当前页面，且只能向同一个域中使用相同端口和协议的 `URL` 发送请求。如果`URL`与启动请求的页面有任何差别，都会引发安全错误
- 3、`open()`方法的第三个参数是表示是否异步发送请求的布尔值，如果不填写，默认为`true`，表示异步发送
- 4、如果请求一个受密码保护的`URL`，把用于认证的用户名和密码作为第4和第5个参数传递给 `open()` `法


**send()**

`send()` 方法接收一个参数，即要作为请求主体发送的数据。调用 `send()`方法后，请求被分派到服务器

如果是 `GET` 方法，`send()` 方法无参数，或参数为 `null`；如果是`POST`方法，`send()`方法的参数为要发送的数据

```js
xhr.open("get", "example.txt", false);
xhr.send(null);
```

### 接收响应

一个完整的 `HTTP` 响应由状态码、响应头集合和响应主体组成。在收到响应后，这些都可以通过 `XHR` 对象的属性和方法使用，主要有以下4个属性

```
responseText: 作为响应主体被返回的文本(文本形式)
responseXML: 如果响应的内容类型是'text/xml'或'application/xml'，这个属性中将保存着响应数据的XML DOM文档(document形式)
status: HTTP状态码(数字形式)
statusText: HTTP状态说明(文本形式)
```

在接收到响应后，第一步是检查 `status` 属性，以确定响应已经成功返回。一般来说，可以将 `HTTP` 状态码为 `200` 作为成功的标志。此时，`responseText` 属性的内容已经就绪，而且在内容类型正确的情况下，`responseXML` 也可以访问了。此外，状态码为 `304` 表示请求的资源并没有被修改，可以直接使用浏览器中缓存的版本；当然，也意味着响应是有效的

无论内容类型是什么，响应主体的内容都会保存到`responseText`属性中，而对于非`XML`数据而言，`responseXML`属性的值将为`null`

```js
if((xhr.status >=200 && xhr.status < 300) || xhr.status == 304){
    alert(xhr.responseText);
}else{
    alert('request was unsuccessful:' + xhr.status);
}
```

#### 同步

如果接受的是同步响应，则需要将 `open()` 方法的第三个参数设置为`false`，那么 `send()` 方法将阻塞直到请求完成。一旦 `send()` 返回，仅需要检查 `XHR` 对象的 `status` 和 `responseText` 属性即可

```html
<button id="btn">获取信息</button>
<div id="result"></div>
<script>
btn.onclick = function(){
    //创建xhr对象
    var xhr;
    if(window.XMLHttpRequest){
        xhr = new XMLHttpRequest();
    }else{
        xhr = new ActiveXObject('Microsoft.XMLHTTP');
    }
    //发送请求
    xhr.open('get','/uploads/rs/26/ddzmgynp/message.xml',false);
    xhr.send();
    //同步接受响应
    if(xhr.readyState == 4){
        if(xhr.status == 200){
            //实际操作
            result.innerHTML += xhr.responseText;
        }
    }
}
</script>
```

缺点：客户端 `javascript` 是单线程的，当 `send()` 方法阻塞时，它通常会导致整个浏览器 `UI` 冻结。如果连接的服务器响应慢，那么用户的浏览器将冻结

#### 异步

如果需要接收的是异步响应，这就需要检测 `XHR` 对象的 `readyState` 属性，该属性表示请求/响应过程的当前活动阶段。这个属性可取的值如下：

```
0(UNSENT):未初始化。尚未调用open()方法
1(OPENED):启动。已经调用open()方法，但尚未调用send()方法
2(HEADERS_RECEIVED):发送。己经调用send()方法，且接收到头信息
3(LOADING):接收。已经接收到部分响应主体信息
4(DONE):完成。已经接收到全部响应数据，而且已经可以在客户端使用了
```

::: warning
必须在调用open()之前指定onreadystatechange 事件处理程序才能确保跨浏览器兼容性，否则将无法接收readyState属性为0和1的情况
:::

```html
<button id="btn">获取信息</button>
<div id="result"></div>
<script>
btn.onclick = function(){
    //创建xhr对象
    var xhr;
    if(window.XMLHttpRequest){
        xhr = new XMLHttpRequest();
    }else{
        xhr = new ActiveXObject('Microsoft.XMLHTTP');
    }
    //异步接受响应
    xhr.onreadystatechange = function(){
        if(xhr.readyState == 4){
            if(xhr.status == 200){
                //实际操作
                result.innerHTML += xhr.responseText;
            }
        }
    }
    //发送请求
    xhr.open('get','message.xml',true);
    xhr.send();
}
</script>  
```

#### 超时

`XHR` 对象的 `timeout` 属性等于一个整数，表示多少毫秒后，如果请求仍然没有得到结果，就会自动终止。该属性默认等于0，表示没有时间限制

如果请求超时，将触发 `ontimeout` 事件

[注意]IE8-浏览器不支持该属性

```js
xhr.open('post','test.php',true);
xhr.ontimeout = function(){
    console.log('The request timed out.');
}
xhr.timeout = 1000;
xhr.send();

```

#### 优化

使用 `AJAX` 接收数据时，由于网络和数据大小的原因，并不是立刻就可以在页面中显示出来。所以，更好的做法是，在接受数据的过程中，显示一个类似  loading  的小图片，并且禁用按钮；当数据完全接收后，再隐藏该图片，并启用按钮

## 请求方式


### GET

GET是最常见的请求类型，最常用于向服务器查询某些信息，它适用于当URL完全指定请求资源，当请求对服务器没有任何副作用以及当服务器的响应是可缓存的情况下

```js
xhr.open("get","example.do?name1=value1&name2=value2",true)
```

【编码】

由于 `URL` 无法识别特殊字符，所以如果数据中包含特殊字符(如中文)，则需要使用 `encodeURIComponent()` 进行编码

【缓存】　

在GET请求中，为了避免缓存的影响，可以向URL添加一个随机数或时间戳

```js
xhr.open('get',url+'&'+Number(new Date()),true);
xhr.open('get',url+'&'+Math.random(),true);
```


### POST

"POST" 方法常用于HTML表单。它在请求主体中包含额外数据且这些数据常存储到服务器上的数据库中。相同 `URL` 的重复 `POST` 请求从服务器得到的响应可能不同，同时不应该缓存使用这个方法的请求

```js
 xhr.open("post","example.php",true);
```

 【设置请求头】

将 `Content-Type` 头部信息设置为`application/x-www-form-urlencoded`，也就是表单提交时的内容类型

```js
xhr.setRequestHeader("content-type","application/x-www-form-urlencoded");
```

【发送主体】

`POST` 数据的格式与查询字符串格式相同，名和值之间用等号链接，名值对之间用和号(&)分隔，如下所示

```js
xhr.send('name="abc"&num=123');
```


## 响应解码

接收到的响应主体类型可以是多种形式的，包括字符串 `String`、`ArrayBuffer`对象、二进制 `Blob` 对象、`JSON` 对象、`javascirpt`文件及表示 `XML` 文档的 `Document`对象等

### 属性

【responseText】

`responseText` 属性返回从服务器接收到的字符串，该属性为只读。如果本次请求没有成功或者数据不完整，该属性就会等于 `null`。

如果服务器返回的数据格式是 `JSON`、字符串、`javascript`或`XML`，都可以使用`responseText`属性

【response】

`response` 属性为只读，返回接收到的数据体。它的类型可以是`ArrayBuffer`、`Blob`、`Document`、`JSON`对象、或者一个字符串，这由 `XMLHttpRequest.responseType` 属性的值决定

如果本次请求没有成功或者数据不完整，该属性就会等于 `null`

[注意]IE9-浏览器不支持

【responseType】

`responseType` 属性用来指定服务器返回数据(xhr.response)的类型

```
“”：字符串(默认值)
“arraybuffer”：ArrayBuffer对象
“blob”：Blob对象
“document”：Document对象
“json”：JSON对象
“text”：字符串
```

【responseXML】

`responseXML` 属性返回从服务器接收到的 `Document` 对象，该属性为只读。如果本次请求没有成功，或者数据不完整，或者不能被解析为 `XML`或`HTML`，该属性等于 `null`

【overrideMimeType()】

该方法用来指定服务器返回数据的 `MIME` 类型。该方法必须在 `send()` 之前调用

传统上，如果希望从服务器取回二进制数据，就要使用这个方法，人为将数据类型伪装成文本数据

但是，这种方法很麻烦，在 `XMLHttpRequest` 版本升级以后，一般采用指定 `responseType` 的方法

### 字符串

如果服务器返回的结果是一个字符串，则直接使用 `responseText` 属性解析即可

### JSON

`JSON` 是一种数据交换的文本格式，用于存储和读取结构化数据

JSON 存储格式规则

- 不支持 `undefined`, 函数，`Symbol`, 特殊对象例如 `Map`、`Set`


**方法**

- stringify()：将一个 `JSON` 对象值转为字符串。接收三个参数，第二个参数是个过滤器，可以是一个数组，也可以是一个函数；第三个参数是一个选项，表示是否在JSON字符串中保留缩进
- toJSON()：用法和 `stringify` 一样
- parse()：将一个 `JSON` 字符串转化为对象


使用 `ajax` 最常用的传输方式就是使用 `JSON` 字符串，直接使用`responseText` 属性解析即可

```html
<button id="btn">取得响应</button>
<div id="result"></div>
<script>
btn.onclick = function(){
    ajax({
        url:'xxx.do',
        callback:function(data){
            var obj = JSON.parse(data);
            var html = '';
            for(var i = 0; i < obj.length; i++){
                html+= '<div>' + obj[i].title + ':' + obj[i].data + '</div>';
            }
            result.innerHTML = html;
            html = null;
        }
    })
}
</script>
```

### blob

`Blob` 通常表示二进制数据。但在实际 `Web` 应用中，`Blob` 更多是图片二进制形式的上传与下载，虽然其可以实现几乎任意文件的二进制传输

使用 `ajax `接收 `blob` 数据，需要使用 `response` 来接收，并且将`responseType` 设置为 `'blob'`

### arraybuffer

`arraybuffer` 代表储存二进制数据的一段内存，而 `blob` 则用于表示二进制数据。通过 `ajax` 接收 `arraybuffer` ，然后将其转换为 `blob` 数据，从而进行进一步的操作

`responseType` 设置为 `arraybuffer` ，然后将 `response` 作为`new Blob()` 构造函数的参数传递，生成 `blob`对象


## FormData 类型

`XMLHttpRequest 2` 定义了 `FormData` 类型。`FormData`为序列化表单以及创建与表单格式相同的数据(用于通过XHR传输)提供了便利

[注意]IE9-浏览器不支持

【构造函数】

```js
new FormData (form? : HTMLFormElement)
```

【append()】

`append()`方法用于给当前 `FormData` 对象添加一个键/值对

```js
void append(DOMString name, Blob value, optional DOMString filename);
void append(DOMString name, DOMString value);
```

参数值 `name` 表示字段名称；参数值 `value` 表示字段值；参数值`filename`(可选)用于指定文件的文件名，当 `value` 参数被指定为一个`Blob`对象或者一个`File`对象时，该文件名会被发送到服务器上，对于`Blob`对象来说，这个值默认为 `"blob"`

【其他不常用方法】

 - get()：通过 `get(key)/getAll(key)` 来获取对应的 `value`

 - set()：通过 `set(key,value)` 修改数据，如果指定的 `key` 不存在则新增一条，如果存在，则修改对应的value值

 - has()：通过 `has(key)` 来判断是否对应的 `key` 值

 - delete()：通过 `delete(key)`来删除数据

[注意]以上4个不常用方法，IE浏览器都不支持


## 进度事件

有以下6个进度事件

- loadstart:在接收到响应数据的第一个字节时触发

- progress:在接收响应期间持续不断地触

- error:在请求发生错误时触发

- abort:在因为调用abort()方法而终止连接时触发

- load:在接收到完整的响应数据时触发

- loadend:在通信完成或者触发error、abort或load事件后触发

- timeout:超时发生时触发

[注意]IE9-浏览器不支持以上事件(IE9浏览器仅支持load事件)

每个请求都从触发 `loadstart` 事件开始，接下来，通常每隔50毫秒左右触发一次 `progress` 事件，然后触发 `load`、`error`、`abort`或`timeout` 事件中的一个，最后以触发 `loadend` 事件结束

对于任何具体请求，浏览器将只会触发`load`、`abort`、`timeout`和`error`事件中的一个。`XHR2` 规范草案指出一旦这些事件中的一个发生后，浏览器应该触发 `loadend` 事件

### load

响应接收完毕后将触发 `load` 事件，因此也就没有必要去检查 `readyState` 属性了。但一个完成的请求不一定是成功的请求，例如，`load` 事件的处理程序应该检查 `XMLHttpRequest` 对象的 `status` 状态码来确定收到的是 `“200 OK”` 而不是 `“404 Not Found”` 的 `HTTP` 响应

```js
//创建xhr对象
var xhr;
if(window.XMLHttpRequest){
    xhr = new XMLHttpRequest();
}else{
    xhr = new ActiveXObject('Microsoft.XMLHTTP');
}
//进度事件
xhr.onload = function(){
    if(xhr.status == 200){
        result.innerHTML += xhr.responseText;
    }
}
//发送请求
xhr.open('get','message.xml',true);
xhr.send();
```

### progress

`progress` 事件会在浏览器接收新数据期间周期性地触发。而 `onprogress` 事件处理程序会接收到一个 `event` 对象，其 `target` 属性是 `XHR` 对象，但包含着三个额外的属性：`lengthComputable`、`loaded`和`total`。

其中，`lengthComputable`是一个表示进度信息是否可用的布尔值，`loaded` 表示已经接收的字节数，`total` 表示根据 `Content-Length`响应头部确定的预期字节数。有了这些信息，就可以为用户创建一个进度指示器了

**上传进度**

`XMLHttpRequest` 对象将有 `upload` 属性。`upload` 属性值是一个对象，它定义了 `addEventListener()` 方法和整个 `progress` 事件集合，比如 `onprogress` 和 `onload` (但upload对象没有定义onreadystatechange属性，upload仅能触发新的事件类型)

对于 `XMLHttpRequest` 对象，设置 `XHR.onprogress` 以监控响应的下载进度，并且设置 `XHR.upload.onprogress` 以监控请求的上传进度

```js
//进度事件
xhr.onprogress = function(e){
    e = e || event;
    if (e.lengthComputable){
        result.innerHTML = "Received " + e.loaded + " of " + e.total + " bytes";
    }
};

//上传事件
xhr.upload.onprogress = function(e){
    e = e || event;
    if (e.lengthComputable){
        pro.innerHTML = "上传进度为：" + e.loaded + " of " + e.total + " bytes" + '；百分比为：' + e.loaded/e.total;
    }
}
```

### 其他事件

`HTTP` 请求无法完成有3种情况，对应3种事件。如果请求超时，会触发`timeout` 事件。如果请求中止，会触发 `abort` 事件。最后，像太多重定向这样的网络错误会阻止请求完成，但这些情况发生时会触发 `error` 事件

可以通过调用 `XMLHttpRequest` 对象的 `abort()` 方法来取消正在进行的HTTP请求。调用 `abort()` 方法在这个对象上触发 `abort` 事件

调用`abort()`的主要原因是完成取消或超时请求消耗的时间太长或当响应变得无关时。假如使用 `XMLHttpRequest` 为文本输入域请求自动完成推荐。如果用户在服务器的建议达到之前输入了新字符，这时等待请求不再有用，应该中止

`XHR` 对象的 `timeout` 属性等于一个整数，表示多少毫秒后，如果请求仍然没有得到结果，就会自动终止。该属性默认等于0，表示没有时间限制

如果请求超时，将触发`ontimeout`事件

```js
var xhr = new XMLHttpRequest();
btn.onclick = function(){
    xhr.abort();
};
xhr.ontimeout = function(){
    console.log('The request timed out.');
}
xhr.timeout = 100;
xhr.onabort = function(){
    console.log("The transfer has been canceled by the user.");
}
xhr.onerror = function(){
    console.log("An error occurred while transferring the file.");    
}
xhr.onloadend = function(){
    console.log("请求结束");    
}
```

## 头部信息

每个 `HTTP` 请求和响应都会带有相应的头部信息，其中有的对开发人员有用。`XHR` 对象提供了操作头部信息的方法。本文将详细介绍 `HTTP` 的头部信息


### 默认信息

默认情况下，在发送 `XHR` 请求的同时，还会发送下列头部信息

```
Accept: 浏览器能够处理的内容类型
Accept-Charset: 浏览器能够显示的字符集
Accept-Encoding: 浏览器能够处理的压缩编码
Accept-Language: 浏览器当前设置的语言
Connection: 浏览器与服务器之间连接的类型
Cookie: 当前页面设置的任何Cookie
Host: 发出请求的页面所在的域
User-Agent: 浏览器的用户代理字符串
Referer: 发出请求的页面的URI
```

　[注意]HTTP规范将这个头部字段拼错了，而为保证与规范一致，也只能将错就错(正确拼写应该是referrer)

![header](https://gitee.com/FIF/pic-beg/raw/master/images/javascript/js_ajax_header.png)

### 设置头部

使用 `setRequestHeader()` 方法可以设置自定义的请求头部信息。这个方法接受两个参数：头部字段的名称头部字段的值。要成功发送请求头部信息，必须在调用 `open()` 方法之后且调用 `send()` 方法之前调用 `setRequestHeader()`方法 

`setRequestHeader()` 方法的一个常用用途是使用POST请求时，将Content-Type的头部信息设置为表单提交的内容类型

```js
xhr.open('post','service.do',true);
xhr.setRequestHeader('Content-Type','application/x-www-form-urlencoded');
xhr.send('data=test123');
```


[注意]尽量使用自定义头部字段名称，不要使用浏览器正常发送的字段名称，否则可能会影响服务器的响应


### 获取头部

调用 `XHR` 对象的 `getResponseHeader()` 方法并传入头部字段名称，可以取得相应的响应头部信息。而调用 `getAllResponseHeaders()` 方法则可以取得一个包含所有头部信息的长字符串

