---
title: 跨域
date: 2020-03-16 14:27:01
permalink: /pages/2wweedasweew
author: 
  name: jeffery
categories: 
  - javascript
tags: 
  - javascript
---


# 跨域

由于浏览器的同源策略，当我们请求在不同源的资源时会出现跨域，资源被浏览器拦截，以下介绍几种跨域的实现方式

所谓“同源”指的是”三个相同“：1、协议相同；2、域名相同；3、端口相同

同源政策的目的，是为了保证用户信息的安全，防止恶意的网站窃取数据。

设想这样一种情况：A 网站是一家银行，用户登录以后，又去浏览其他网站。如果其他网站可以读取 A 网站的 `Cookie`，会发生什么？很显然，如果 `Cookie` 包含隐私（比如存款总额），这些信息就会泄漏。更可怕的是，`Cookie` 往往用来保存用户的登录状态，如果用户没有退出登录，其他网站就可以冒充用户，为所欲为。因为浏览器同时还规定，提交表单不受同源政策的限制。

由此可见，“同源政策”是必需的，否则 `Cookie` 可以共享，互联网就毫无安全可言了

随着互联网的发展，“同源政策”越来越严格。目前，如果非同源，共有三种行为受到限制

1、`Cookie`、`LocalStorage` 和 `IndexedDB` 无法读取

2、`DOM` 无法获得

3、`AJAX` 请求无效（可以发送，但浏览器会拒绝接受响应）

## 图片 Ping

图像Ping跨域请求技术是使用 `<img>` 标签。一个网页可以从任何网页中加载图像，不用担心跨域不跨域。这也是在线广告跟踪浏览量的主要方式。也可以动态地创建图像，使用它们的 `onload` 和 `onerror` 事件处理程序来确定是否接收到了响应

```js
var img = new Image();
img.onload = img.onerror = function(){
    alert("Done!");
};
img.src = "test.html?sum=a";
```

图像Ping有两个主要的缺点:
- 只能发送 `GET` 请求
- 无法访问服务器的响应文本，只能用于浏览器与服务器间的单向通信

## JSONP

`JSONP` 的基本思想是，网页通过添加一个 `<script>` 元素，向服务器请求 `JSON` 数据，这种做法不受同源政策限制；服务器收到请求后，将数据放在一个指定名字的回调函数里传回来

`JSONP` 由两部分组成：回调函数和数据。回调函数是当响应到来时应该在页面中调用的函数。回调函数的名字一般是在请求中指定的。而数据就是传入回调函数中的JSON数据
```
http://baidu.com/json/?callback=handleResponse
```

JSONP是通过动态 `<script>` 元素来使用的，使用时可以为 `src` 属性指定一个跨域 `URL` 。这里的 `<script>` 元素与 `<img>` 元素类似，都有能力不受限制地从其他域加载资源。因为 `JSONP` 是有效的 `javascript` 代码，所以在请求完成后，即在JSONP响应加载到页面中以后，就会立即执行

```js
function handleResponse(response){
    alert ("You're at IP address " + response.ip + ", which is in " + response.city + ", "+ response.region_name);
}
var script = document.createElement("script");
script.src = "http://freegeoip.net/json/?callback=handLeResponse"; document.body.insertBefore(script, document.body.firstChild);
```

::: tip
callback 回调函数是一个全局函数
:::

优点：
- 非常简单易用，老式浏览器全部支持，服务器改造非常小
- 能够直接访问响应文本，支持在浏览器与服务器之间双向通信

缺点：
- JSONP是从其他域中加载代码执行。如果其他域不安全，很可能会在响应中夹带一些恶意代码
- 确定 `JSONP` 请求是否失败并不容易，虽然 `HTML5`给 `<script>` 元素新增了一个 `onerror` 事件处理程序，但浏览器有兼容性问题。为此，开发人员不得不使用计时器检测指定时间内是否接收到了响应。但就算这样也不能尽如人意，毕竟不是每个用户上网的速度和带宽都一样


封装回调函数
```js
function loadScript(url){
    loadScript.mark = 'load';
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src = url;
    script.onload = function(){
        img.style.display = 'none';
        btn.removeAttribute('disabled');
    }
    document.body.appendChild(script);
}
```

## iframe 跨域

`iframe` 元素可以在当前网页之中，嵌入其他网页。每个 `iframe` 元素形成自己的窗口，即有自己的 `window` 对象。`iframe` 窗口之中的脚本，可以获得父窗口和子窗口。但是，只有在同源的情况下，父窗口和子窗口才能通信；如果跨域，就无法拿到对方的 `DOM`

### domain属性

如果两个窗口一级域名相同，只是二级域名不同，可以通过设置 `document.domain` 来使其通信

父窗口地址为`https://static.xiaohuochai.site/test/test.html`

子窗口地址为`https://demo.xiaohuochai.site/test/iframe.html`

代码如下：
```html
<!-- 父窗口test.html-->
<body>
  <iframe id="myIFrame" src="https://demo.xiaohuochai.site/test/iframe.html"></iframe>
  <script>
    var iframe = document.getElementById("myIFrame");
    iframe.onload = function(){
      var doc = iframe.contentWindow.document;
      console.log(doc.getElementById('test').innerHTML);//'xiaohuochai'
      console.log(document.cookie);
    }
  </script>
</body>
<!-- 子窗口iframe.html-->
<body>
  <div id="test">xiaohuochai</div>
  <script>
  document.cookie = 'name=match';
  </script>
</body>
```
由结果所示，通过设置 `document.domain` 只能获取 `DOM`，而`Cookie`、`LocalStorage` 和 `IndexedDB`无法读取


### postMessage

`postMessage()` 方法接收两个参数：一条消息和一个表示消息接收方来自哪个域的字符串。第二个参数对保障安全通信非常重要，可以防止浏览器把消息发送到不安全的地方

```js
//注意：所有支持XDM的浏览器也支持ifraaie的contentWindow属性
var iframeWindow = document.getElementById("rayframe").contentWindow,
iframeWindow.postMessage( "A secret', "http://www.wrox.com")；
```

最后一行代码尝试向内嵌框架中发送一条消息，并指定框架中的文档必须来源于`"http://www.wrox.com"` 域。如果来源匹配，消息会传递到内嵌框架中；否则，`postMessage()` 什么也不做。 

接收到消息时，会触发 `window` 对象的 `message` 事件。这个事件是以异步形式触发的。因此从发送消息到接收消息可能要经过一段时间的延迟。触发`message`事件后，传递给 `onmessage` 处理程序的事件对象包含以下三方面的重要信息

```
data:作为postMessage()第一个参数传入的字符串数据
origin:发送消息的文档所在的域，例如"http://www.wrox.com"。 
source:发送消息的文档的window对象的代理。这个代理对象主要用于在发送上一条消息的窗口中调用postMessage()方法。如果发送消息的窗口来自同一个域，那这个对象就是window
```

```js
window.onmessage = function(e){
  if(e.origin == 'http://www.wrox.com'){
    //处理接收到的数据
    processMessage(e.data);
    //可选：向来源窗口发送回执
    e.source.postMessage("Received!", "http//p2p.wrox.com");
  }
}
```


## CORS

`CORS` 背后的基本思想，就是使用自定义的 `HTTP` 头部让浏览器与服务器进行沟通，从而决定请求或响应是应该成功，还是应该失败

`CORS` 主要需要在后端进行设置响应头 `Access-Control-Allow-Origin` ，允许任何域向服务端提交请求

```js
header( " Access-Control-Allow-Origin: * " );
header( " Access-Control-Allow-Origin: https://www.webhuochai.com" ); // 指定的域名

```

跨域 `XHR` 对象也有一些限制，但为了安全这些限制是必需的

1、不能使用 `setRequestHeader()` 设置自定义头部

2、不能发送和接收 `cookie`

3、调用 `getAllResponseHeaders()` 方法总会返回空字符串

### 凭据请求

默认情况下，跨源请求不提供凭据(cookie、HTTP认证及客户端SSL证明等)。通过将 `withCredentials` 属性设置为 `true` ，可以指定某个请求应该发送凭据

如果服务器接受带凭据的请求，会用下面的 `HTTP` 头部来响应

```js
Access-Control-Allow-Credentials: true
```

开发者必须在 `AJAX` 请求中打开 `withCredentials` 属性

```js
var xhr = new XMLHttpRequest();
xhr.withCredentials = true;
```

否则，即使服务器同意发送 `Cookie`，浏览器也不会发送。或者，服务器要求设置 `Cookie`，浏览器也不会处理

但是，如果省略 `withCredentials`设置，有的浏览器还是会一起发送`Cookie`。这时，可以显式关闭 `withCredentials`

```js
xhr.withCredentials = false;
```

::: tip
如果要发送Cookie，Access-Control-Allow-Origin就不能设为星号，必须指定明确的、与请求网页一致的域名。同时，Cookie依然遵循同源政策，只有用服务器域名设置的Cookie才会上传，其他域名的Cookie并不会上传，且(跨源)原网页代码中的document.cookie也无法读取服务器域名下的Cookie
:::