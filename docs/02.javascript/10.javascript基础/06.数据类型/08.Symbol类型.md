---
title: Symbol 类型
date: 2021-01-09 15:03:03
permalink: /pages/ssdeewasweew
author: 
  name: jeffery
categories: 
  - javascript
tags: 
  - javascript
---

# Symbol 类型

## 概述

`ES5` 的对象属性名都是字符串，很容易造成属性名冲突。比如，使用了一个他人提供的对象，想为这个对象添加新的方法，新方法的名字就有可能与现有方法产生冲突，这时 `ES6` 引入 `Symbol` ，它会创建一个唯一的值，解决上面命名冲突的问题

## 创建

Symbol 值通过`Symbol`函数生成。这就是说，对象的属性名可以有两种类型：一种是字符串，另一种是 `Symbol`类型。凡是属性名属于 `Symbol` 类型，就都是独一无二的，可以保证不会与其他属性名产生冲突



```js
let firstName = Symbol();
let person = {};
person[firstName] = "huochai";
console.log(person[firstName]); // "huochai"
```

::: warning

`Symbol`函数前不能使用`new`命令，否则会报错。因为生成的 `Symbol` 是一个原始类型的值，不是对象

:::

```js
//Uncaught TypeError: Symbol is not a constructor
let firstName = new Symbol();
```

`Symbol` 函数接受一个可选参数，可以添加一段文本来描述即将创建的 `Symbol`，这段描述不可用于属性访问，但是建议在每次创建 `Symbol` 时都添加这样一段描述，以便于阅读代码和调试 `Symbol` 程序

【类型检测】

`Symbol` 是原始值，ES6扩展了 `typeof` 操作符，返回 `"symbol"`。所以可以用 `typeof` 来检测变量是否为 `symbol` 类型

```js
let symbol = Symbol("test symbol");
console.log(typeof symbol); // "symbol"
```



Symbol 值作为对象属性名时，不能用点运算符

```js
var mySymbol = Symbol();
var a = {};

a.mySymbol = 'Hello!';
a[mySymbol] // undefined
a['mySymbol'] // "Hello!"
```

## 共享体系

有时希望在不同的代码中共享同一个 `Symbol`，例如，在应用中有两种不同的对象类型，但是希望它们使用同一个 `Symbol` 属性来表示一个独特的标识符。一般而言，在很大的代码库中或跨文件追踪 `Symbol` 非常困难而且容易出错，出于这些原因，ES6提供了一个可以随时访问的全局 `Symbol` 注册表

### Symbol.for()

如果想创建一个可共享的 `Symbol`，要使用 `Symbol.for()` 方法。它只接受一个参数，也就是即将创建的 `Symbol` 的字符串标识符，这个参数同样也被用作 `Symbol` 的描述

```js
let uid = Symbol.for("uid");
let object = {};
object[uid] = "12345";
console.log(object[uid]); // "12345"
console.log(uid); // "Symbol(uid)
```

`Symbol.for()` 方法首先在全局 `Symbol` 注册表中搜索键为 `"uid"` 的 `Symbol` 是否存在。如果存在，直接返回已有的 `Symbol`，否则，创建一个新的 `Symbol`，并使用这个键在 `Symbol` 全局注册表中注册，随即返回新创建的 `Symbol`



### Symbol.keyFor()

还有一个与 `Symbol` 共享有关的特性：可以使用 `Symbol.keyFor()` 方法在 `Symbol` 全局注册表中检索与 `Symbol` 有关的键

```js
let uid = Symbol.for("uid");
console.log(Symbol.keyFor(uid)); // "uid"
let uid2 = Symbol.for("uid");
console.log(Symbol.keyFor(uid2)); // "uid"
let uid3 = Symbol("uid");
console.log(Symbol.keyFor(uid3)); // undefined
```

`Symbol.for`为 	`Symbol` 值登记的名字，是全局环境的，可以在不同的 `iframe` 或 `service worker` 中取到同一个值

```js
let iframe = document.createElement('iframe');
iframe.src = String(window.location);
document.body.appendChild(iframe);

console.log(iframe.contentWindow.Symbol.for('foo') === Symbol.for('foo'));// true
```



## 属性检索

`Symbol` 作为属性名，该属性不会出现在 `for...in`、`for...of` 循环中，也不会被 `Object.getOwnPropertyNames()`、`Object.keys()`、`JSON.stringify()` 返回。于是，在ES6中添加了一个`Object.getOwnpropertySymbols()` 方法来检索对象中的 `Symbol` 属性



`Object.getOwnPropertySymbols()` 方法的返回值是一个包含所有 `Symbol` 自有属性的数组

```js
let uid = Symbol.for("uid");
let object = {
    [uid]: "12345"
};
let symbols = Object.getOwnPropertySymbols(object);
console.log(symbols.length); // 1
console.log(symbols[0]); // "Symbol(uid)"
console.log(object[symbols[0]]); // "12345"
```

在这段代码中，`object` 对象有一个名为 `uid` 的 `Symbol` 属性，`object.getOwnPropertySymbols()` 方法返回了包含这个属性的数组

另一个新的API——`Reflect.ownKeys()`方法可以返回所有类型的键名，包括常规键名和` Symbol` 键名

```js
let obj = {
  [Symbol('my_key')]: 1,
  enum: 2,
  nonEnum: 3
};
console.log(Reflect.ownKeys(obj));//  ["enum", "nonEnum", Symbol(my_key)]
```



## 内置Symbol

除了定义自己使用的 `Symbol` 值以外，ES6还提供了11个内置的 `Symbol` 值，指向语言内部使用的方法

### Symbol.haslnstance

一个在执行 `instanceof` 时调用的内部方法，用于检测对象的继承信息

每个函数都有一个 `Symbol.haslnstance` 方法，用于确定对象是否为函数的实例。该方法在 `Function.prototype` 中定义，所有函数都继承了 `instanceof` 属性的默认行为。为了确保 `Symbol.haslnstance` 不会被意外重写，该方法被定义为不可写、不可配置并且不可枚举

`Symbol.haslnstance` 方法只接受一个参数，即要检查的值。如果传入的值是函数的实例，则返回 `true`

```js
obj instanceof Array;
```

以上这行代码等价于下面这行

```js
Array[Symbol.hasInstance](obj);
```

本质上，ES6只是将 `instanceof` 操作符重新定义为此方法的简写语法。现在引入方法调用后，就可以随意改变 `instanceof` 的运行方式了

```js
class MyClass {
  [Symbol.hasInstance](foo) {
    return foo instanceof Array;
  }
}
console.log([1, 2, 3] instanceof new MyClass()); // true
```

假设定义一个无实例的函数，就可以将 `Symbol.haslnstance` 的返回值硬编码为 `false`

```js
function MyObject() {
    // ...
}
Object.defineProperty(MyObject, Symbol.hasInstance, {
    value: function(v) {
        return false;
    }
});
let obj = new MyObject();
console.log(obj instanceof MyObject); // false
```

只有通过 `Object.defineProperty()` 方法才能够改写一个不可写属性，上面的示例调用这个方法来改写 `symbol.haslnstance`，为其定义一个总是返回 `false` 的新函数，即使 `obj` 实际上确实是 `Myobject` 类的实例，在调用过 `object.defineProperty()` 方法之后，`instanceof` 运算符返回的也是 `false`

当然，也可以基于任意条件，通过值检查来确定被检测的是否为实例。例如，可以将1～100的数字定义为一个特殊数字类型的实例，具体实现的代码如下

```js
function SpecialNumber() {
　　// empty
}
Object.defineProperty(SpecialNumber, Symbol.hasInstance, {
    value: function(v) {
        return (v instanceof Number) && (v >=1 && v <= 100);
    }
});
let two = new Number(2),
zero = new Number(0);
console.log(two instanceof SpecialNumber); // true
console.log(zero instanceof SpecialNumber); // false
```

在这段代码中定义了一个 `symbol.hasInstance` 方法，当值为 Number的实例且其值在1～100之间时返回true。所以即使`SpecialNumber` 函数和变量 `two` 之间没有直接关系，变量 `two` 也被确认为 `specialNumber` 的实例

如果要触发 `Symbol.haslnstance` 调用，`instanceof` 的左操作数必须是一个对象，如果左操作数为非对象会导致 `instanceof` 总是返回 `false　　`

　　当然，可以重写所有内建函数(如 `Date` 和 `Error` 函数)默认的 `symbol.haslnstance` 属性。但是这样做的后果是代码的运行结果变得不可预期且有可能令人感到困惑，所以不推荐这样做，最好的做法是，只在必要情况下改写自己声明的函数的 `Symbol.haslnstance` 属性

### Symbol.isConcatSpreadable

一个布尔值，用于表示当传递一个集合作为 `Array.prototype.concat()` 方法的参数时，是否应该将集合内的元素规整到同一层级

对象的 `Symbol.isConcatSpreadable` 属性是布尔值，表示该对象使用 `Array.prototype.concat()`时，是否可以展开

```js
let arr1 = ['c', 'd'];
['a', 'b'].concat(arr1, 'e') // ['a', 'b', 'c', 'd', 'e']
arr1[Symbol.isConcatSpreadable] // undefined

let arr2 = ['c', 'd'];
arr2[Symbol.isConcatSpreadable] = false;
['a', 'b'].concat(arr2, 'e') // ['a', 'b', ['c','d'], 'e']
```

上面代码说明，数组的默认行为是可以展开。`Symbol.isConcatSpreadable`属性等于 `undefined` 或`true`，都有这个效果

类数组对象也可以展开，但它的`Symbol.isConcatSpreadable`属性默认为`false`，必须手动打开

```js
let obj = {length: 2, 0: 'c', 1: 'd'};
['a', 'b'].concat(obj, 'e') // ['a', 'b', obj, 'e']

obj[Symbol.isConcatSpreadable] = true;
['a', 'b'].concat(obj, 'e') // ['a', 'b', 'c', 'd', 'e']
```

　　对于一个类来说，`Symbol.isConcatSpreadable`属性必须写成实例的属性

```js
class A1 extends Array {
  constructor(args) {
    super(args);
    this[Symbol.isConcatSpreadable] = true;
  }
}
class A2 extends Array {
  constructor(args) {
    super(args);
    this[Symbol.isConcatSpreadable] = false;
  }
}
let a1 = new A1();
a1[0] = 3;
a1[1] = 4;
let a2 = new A2();
a2[0] = 5;
a2[1] = 6;
[1, 2].concat(a1).concat(a2)
// [1, 2, 3, 4, [5, 6]]
```

　　上面代码中，类`A1`是可展开的，类`A2`是不可展开的，所以使用`concat`时有不一样的结果

### Symbol.species

用于创建派生类的构造函数

对象的`Symbol.species`属性，指向当前对象的构造函数。创造实例时，默认会调用这个方法，即使用这个属性返回的函数当作构造函数，来创造新的实例对象

```js
class MyArray extends Array {
  // 覆盖父类 Array 的构造函数
  static get [Symbol.species]() { return Array; }
}
```

上面代码中，子类`MyArray`继承了父类`Array`。创建`MyArray`的实例对象时，本来会调用它自己的构造函数，但是由于定义了`Symbol.species`属性，所以会使用这个属性返回的的函数，创建`MyArray`的实例

这个例子也说明，定义`Symbol.species`属性要采用`get`读取器。默认的`Symbol.species`属性等同于下面的写法

```js
static get [Symbol.species]() {
  return this;
}
```

下面是一个例子

```js
class MyArray extends Array {
  static get [Symbol.species]() { return Array; }
}
var a = new MyArray(1,2,3);
var mapped = a.map(x => x * x);

mapped instanceof MyArray // false
mapped instanceof Array // true
```

上面代码中，由于构造函数被替换成了`Array`。所以，`mapped`对象不是`MyArray`的实例，而是`Array`的实例

### Symbol.match

一个在调用 `String.prototype.match()` 方法时调用的方法，用于比较字符串

对象的`Symbol.match`属性，指向一个函数。当执行`str.match(myObject)`时，如果该属性存在，会调用它，返回该方法的返回值

```js
String.prototype.match(regexp)
// 等同于
regexp[Symbol.match](this)
class MyMatcher {
  [Symbol.match](string) {
    return 'hello world'.indexOf(string);
  }
}
'e'.match(new MyMatcher()) // 1
```

### Symbol.replace

一个在调用 `String.prototype.replace()` 方法时调用的方法，用于替换字符串的子串

对象的`Symbol.replace`属性，指向一个方法，当该对象被`String.prototype.replace`方法调用时，会返回该方法的返回值

```js
String.prototype.replace(searchValue, replaceValue)
// 等同于
searchValue[Symbol.replace](this, replaceValue)
```

下面是一个例子

```js
const x = {};
x[Symbol.replace] = (...s) => console.log(s);

'Hello'.replace(x, 'World') // ["Hello", "World"]
Symbol.replace`方法会收到两个参数，第一个参数是`replace`方法正在作用的对象，上面例子是`Hello`，第二个参数是替换后的值，上面例子是`World
```

### Symbol.search

一个在调用 `String.prototype.search()` 方法时调用的方法，用于在字符串中定位子串

对象的`Symbol.search`属性，指向一个方法，当该对象被`String.prototype.search`方法调用时，会返回该方法的返回值

```js
String.prototype.search(regexp)
// 等同于
regexp[Symbol.search](this)

class MySearch {
  constructor(value) {
    this.value = value;
  }
  [Symbol.search](string) {
    return string.indexOf(this.value);
  }
}
'foobar'.search(new MySearch('foo')) // 0
```

### Symbol.split

一个在调用 `String.prototype.split()` 方法时调用的方法，用于分割字符串

对象的`Symbol.split`属性，指向一个方法，当该对象被`String.prototype.split`方法调用时，会返回该方法的返回值

```js
String.prototype.split(separator, limit)
// 等同于
separator[Symbol.split](this, limit)
```

下面是一个例子

```js
class MySplitter {
  constructor(value) {
    this.value = value;
  }
  [Symbol.split](string) {
    var index = string.indexOf(this.value);
    if (index === -1) {
      return string;
    }
    return [
      string.substr(0, index),
      string.substr(index + this.value.length)
    ];
  }
}
'foobar'.split(new MySplitter('foo'))// ['', 'bar']
'foobar'.split(new MySplitter('bar'))// ['foo', '']
'foobar'.split(new MySplitter('baz'))// 'foobar'
```

上面方法使用`Symbol.split`方法，重新定义了字符串对象的`split`方法的行为

### Symbol.iterator

对象的`Symbol.iterator`属性，指向该对象的默认遍历器方法

```js
var myIterable = {};
myIterable[Symbol.iterator] = function* () {
  yield 1;
  yield 2;
  yield 3;
};

[...myIterable] // [1, 2, 3]
```

对象进行`for...of`循环时，会调用`Symbol.iterator`方法，返回该对象的默认遍历器

```js
class Collection {
  *[Symbol.iterator]() {
    let i = 0;
    while(this[i] !== undefined) {
      yield this[i];
      ++i;
    }
  }
}

let myCollection = new Collection();
myCollection[0] = 1;
myCollection[1] = 2;

for(let value of myCollection) {
  console.log(value);
}
// 1
// 2
```

### Symbol.toPrimitive

对象的`Symbol.toPrimitive`属性，指向一个方法。该对象被转为原始类型的值时，会调用这个方法，返回该对象对应的原始类型值

`Symbol.toPrimitive`被调用时，会接受一个字符串参数，表示当前运算的模式，一共有三种模式

- Number：该场合需要转成数值

- String：该场合需要转成字符串

- Default：该场合可以转成数值，也可以转成字符串

```js
let obj = {
  [Symbol.toPrimitive](hint) {
    switch (hint) {
      case 'number':
        return 123;
      case 'string':
        return 'str';
      case 'default':
        return 'default';
      default:
        throw new Error();
     }
   }
};

2 * obj // 246
3 + obj // '3default'
obj == 'default' // true
String(obj) // 'str'
```

### String.toStringTag

对象的`Symbol.toStringTag`属性，指向一个方法。在该对象上面调用`Object.prototype.toString`方法时，如果这个属性存在，它的返回值会出现在`toString`方法返回的字符串之中，表示对象的类型。也就是说，这个属性可以用来定制`[object Object]`或`[object Array]`中`object`后面的那个字符串

```js
// 例一
({[Symbol.toStringTag]: 'Foo'}.toString())
// "[object Foo]"

// 例二
class Collection {
  get [Symbol.toStringTag]() {
    return 'xxx';
  }
}
var x = new Collection();
Object.prototype.toString.call(x) // "[object xxx]"
```

ES6新增内置对象的`Symbol.toStringTag`属性值如下、

```
    JSON[Symbol.toStringTag]：'JSON'
    Math[Symbol.toStringTag]：'Math'
    Module[Symbol.toStringTag]：'Module'
    ArrayBuffer.prototype[Symbol.toStringTag]：'ArrayBuffer'
    DataView.prototype[Symbol.toStringTag]：'DataView'
    Map.prototype[Symbol.toStringTag]：'Map'
    Promise.prototype[Symbol.toStringTag]：'Promise'
    Set.prototype[Symbol.toStringTag]：'Set'
    %TypedArray%.prototype[Symbol.toStringTag]：'Uint8Array'
    WeakMap.prototype[Symbol.toStringTag]：'WeakMap'
    WeakSet.prototype[Symbol.toStringTag]：'WeakSet'
    %MapIteratorPrototype%[Symbol.toStringTag]：'Map Iterator'
    %SetIteratorPrototype%[Symbol.toStringTag]：'Set Iterator'
    %StringIteratorPrototype%[Symbol.toStringTag]：'String Iterator'
    Symbol.prototype[Symbol.toStringTag]：'Symbol'
    Generator.prototype[Symbol.toStringTag]：'Generator'
    GeneratorFunction.prototype[Symbol.toStringTag]：'GeneratorFunction'
```

### Symbol.unscopables

对象的`Symbol.unscopables`属性，指向一个对象。该对象指定了使用`with`关键字时，哪些属性会被`with`环境排除。

```js
Array.prototype[Symbol.unscopables]
// {
//   copyWithin: true,
//   entries: true,
//   fill: true,
//   find: true,
//   findIndex: true,
//   includes: true,
//   keys: true
// }

Object.keys(Array.prototype[Symbol.unscopables])
// ['copyWithin', 'entries', 'fill', 'find', 'findIndex', 'includes', 'keys']
```

　　上面代码说明，数组有7个属性，会被`with`命令排除

```js
// 没有 unscopables 时
class MyClass {
  foo() { return 1; }
}
var foo = function () { return 2; };
with (MyClass.prototype) {
  foo(); // 1
}
// 有 unscopables 时
class MyClass {
  foo() { return 1; }
  get [Symbol.unscopables]() {
    return { foo: true };
  }
}
var foo = function () { return 2; };

with (MyClass.prototype) {
  foo(); // 2
}
```

上面代码通过指定`Symbol.unscopables`属性，使得`with`语法块不会在当前作用域寻找`foo`属性，即`foo`将指向外层作用域的变量