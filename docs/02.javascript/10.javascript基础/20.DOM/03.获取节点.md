---
title: 获取节点
date: 2021-04-06 19:57:01
permalink: /pages/seeswewesesweew
author: 
  name: jeffery
categories: 
  - javascript
tags: 
  - javascript
---

# 获取节点

## 动态集合

### NodeList

`NodeList` 实例对象是一个类数组对象，它的成员是节点对象，包括 `childNodes` 和 `querySelectorAll()` 方法返回值

```html
<div id="test"></div>
<script>
console.log(test.childNodes);//[]
//IE7-浏览器并未定义NodeList对象，会报错，其他浏览器返回true
console.log(test.childNodes instanceof NodeList)
</script>

<div id="test"></div>
<script>
console.log(document.querySelectorAll('div'));//[div#test]
//IE8-浏览器不支持querySelectorAll()方法，返回false，其他浏览器返回true
console.log(document.querySelectorAll('div') instanceof NodeList)
</script>
```

动态集合是指 `DOM` 结构的变化能够自动反映到所保存的对象中

```html
<div id="test"></div>
<script>
var childN = test.childNodes;
console.log(childN);//[]
test.appendChild(document.createElement('div'));
console.log(childN);//[div]
</script>
```

**静态**

`NodeLis` t并不都是动态集合，其中 `querySelectorAll()` 返回值就是静态集合 `NodeStaticList`

```html
<div id="test"></div>
<script>
var seles = test.querySelectorAll('div');
console.log(seles);//[]
test.appendChild(document.createElement('div'));
console.log(seles);//[]
console.log(test.querySelectorAll('div'));//[div]
</script>
```

**数组**

由于 `NodeList` 是类数组对象，并不是真正的数组对象，可以使用 `slice()`方法将其变成真正的数组

```html
<div id="test"></div>
<script>
var childN = test.childNodes;
console.log(childN instanceof Array);//false
var childNew = Array.prototype.slice.call(childN);
console.log(childNew instanceof Array);//true
</script>
```

但是，由于IE8-浏览器将 `NodeList` 实现为一个 `COM` 对象，不能使用`Array.prototype.slice()`方法，必须手动枚举所有成员

```html
<div id="test"></div>
<script>
var childN = test.childNodes;
console.log(childN instanceof Array);//false
function convertToArray(nodes){
    var array = null;
    try{
        array = Array.prototype.slice.call(nodes)
    }catch(ex){
        array = [];
        var len = nodes.length;
        for(var i = 0; i < len; i++){
            array.push(nodes[i]);
        }
    }
    return array;
}
var childNew = convertToArray(childN);
console.log(childNew instanceof Array);//true
</script>
```

 

### HTMLCollection

`HTMLCollection` 对象与 `NodeList` 对象类似，也是节点的集合，返回一个类数组对象。但二者有不同之处

`NodeList`集合主要是 `Node` 节点的集合，而 `HTMLCollection` 集合主要是 `Element` 元素节点的集合。`Node`节点共有12种，`Element`元素节点只是其中一种。

`HTMLCollection` 集合包括 `getElementsByTagName()`、`getElementsByClassName()`、`getElementsByName()`等方法的返回值，以及`children`、`document.links`、`document.forms`等元素集合

```html
<div id="test"></div>
<script>
var childN = test.children;
//IE7-浏览器并未定义HTMLCollection对象，会报错，其他浏览器返回true
console.log(childN instanceof HTMLCollection);
var tags =test.getElementsByTagName('div');
//IE7-浏览器并未定义HTMLCollection对象，会报错，其他浏览器返回true
console.log(tags instanceof HTMLCollection);
</script>    
```

**动态**

与`NodeList`对象不同，所有的`HTMLCollection`对象都是动态的

```html
<div id="test"></div>
<script>
var childN = test.children;
var tags =test.getElementsByTagName('div');
console.log(childN,tags);//[]、[]
test.innerHTML = '<div></div>';
console.log(childN,tags);//[div]、[div]
</script>    
```

::: tip
与NodeList对象类似，要想变成真正的数组Array对象，需要使用slice()方法，在IE8-浏览器中，则必须手动枚举所有成员
:::


### NamedNodeMap

该对象的常见实例对象是 `attributes` 属性

```html
<div id="test"></div>
<script>
var attrs = test.attributes;
console.log(attrs instanceof NamedNodeMap);//true
</script>
```

**动态**

该对象也是一个动态集合

```html
<div id="test"></div>
<script>
var attrs = test.attributes;
console.log(attrs);//NamedNodeMap {0: id, length: 1}
test.setAttribute('title','123');
console.log(attrs);//NamedNodeMap {0: id, 1: title, length: 2}
</script>
```

 

### 注意事项

动态集合是个很实用的概念，但在使用循环时一定要千万小心。可能会因为忽略集合的动态性，造成死循环

```js
var divs = document.getElementsByTagName("div");
for(var i = 0 ; i < divs.length; i++){
    document.body.appendChild(document.createElement("div"));
}
```

在上面代码中，由于 `divs` 是一个 `HTMLElement` 集合，`divs.length` 会随着 `appendChild()` 方法，而一直增加，于是变成一个死循环

为了避免此情况，一般地，可以写为下面形式

```html
var divs = document.getElementsByTagName("div");
for(var i = 0,len = divs.length; i < len; i++){
    document.body.appendChild(document.createElement("div"));
}
```

一般地，要尽量减少访问 `NodeLis`t、`HTMLCollection`、`NamedNodeMap`的次数。因为每次访问它们，都会运行一次基于文档的查询。所以，可以考虑将它们的值缓存起来

**小结**：`NodeList`是节点的集合，`HTMLCollection`是元素节点的集合，`NamedNodeMap`是特性节点的集合，它们都是类数组对象


## 元素选择器

`DOM` 定义了许多方式来选取元素，包括 `getElementById()`、`getElementsByTagName()`、`getElementsByName()`、`document.all`、

### getElementById()

任何 `HTML` 元素可以有一个 `id` 属性，在文档中该值必须唯一

::: tip
若浏览器中出现多个id名的情况，CSS样式对所有该id名的元素都生效，但javascript脚本仅对第一个出现该id名的元素生效
:::

`getElementById()` 该方法接收一个参数：要取得元素的 `id`，若找到则返回该元素，若不存在则返回 `null`

```html
<div id="myDiv"></div>
<script>
var div1 = document.getElementById('myDiv');
var div2 = document.getElementById('mydiv');
console.log(div1);//<div id="myDiv"></div>
console.log(div2);//null
</script>
```

**丢失的this**

`document.getElementById` 这个方法名实在有点过长，可以用一个短的函数来代替它

```js
var getId = function(id){
  return document.getElementById(id);
}
```

但是，为什么不能用下面这种更简单的形式呢？

```js
var getId =  document.getElementById;
getId('div1');
```

上面的这段代码中会抛出异常

![getElementById2](https://gitee.com/FIF/pic-beg/raw/master/images/javascript/JS_DOM_Node_getElementById2.png)

这是因为 `document.getElementById` 方法的内部实现需要用到 `this`，这个`this`本来被期望指向 `document`，当 `getElementById` 方法作为`document`对象的属性被调用时，方法内部的 `this` 确实指向 `document`。但当用 `getId` 来引用 `document.getElementById` 之后，再调用 `getId`，此时就成了普通函数调用，函数内部的 `this` 指向了 `window`，而不是`document`

代码修改如下，可以取得 `id` 为 `div1` 的元素

```html
<div id="div1"></div>
<script>
  var getId = document.getElementById;
  console.log(getId.call(document,'div1'));
</script>
```
或者，可以这样修改

```js
 var getId = document.getElementById.bind(document);
```

### getElementsByTagName()

`getElementsByTagName()` 方法接收一个参数，即要取得元素的标签名，而返回的是包含 `0` 或多个元素的类数组对象 `HTMLCollection`。可以使用方括号语法或 `item()` 方法来访问类数组对象中的项，`length` 属性表示对象中元素的数量

```html
<div>元素一</div>
<div>元素二</div>
<script>
var divs = document.getElementsByTagName('div');
divs[0].style.color = 'red';
divs.item(1).style.backgroundColor = 'pink';
</script>
```

::: tip
通过getElementsByTagName()方法取得的类数组对象有一个namedItem()方法，可以通过元素的name属性取得集合中的第一个值。safari和IE不支持该方法
:::

`getElementsByTagName()` 方法可以用于 `document` 对象，也可以用于`element` 元素对象，用于调用该方法的元素的后代元素

```html
<ul id='myUl'>
    <li>1</li>
    <li>2</li>
</ul>
<script>
var oUl = document.getElementById('myUl');
var lis = oUl.getElementsByTagName('li');
lis[0].style.color = 'red';
</script>
```

### getElementsByName()

`getElementsByName()` 方法会返回带有给定 `name` 特性的所有元素

```html
<button name='test'>按钮一</button>
<button name='test'>按钮二</button>
<script>
var button = document.getElementsByName('test');
button[0].style.color = 'red';
</script>
```

关于 `getElementsByName()` 方法，IE浏览器与其他浏览器相比，有三个不同之处

【1】IE9-浏览器只支持在表单元素上使用 `getElementsByName()` 方法


【2】IE9-浏览器中使用 `getElementsByName()` 方法也会返回 `id` 属性匹配的元素。因此，不要将 `name` 和 `id` 属性设置为相同的值

【3】如果对 `getElementsByName()` 方法取得的类数组对象使用 `namedItem()``方法，因为每一项的 `name` 属性都相同，所以只会返回第一项

::: warning
只有IE8——IE11浏览器支持
:::

### getElementsByClassName

`getElementsByClassName()` 方法接收一个参数，即一个包含一个或多个类名的字符串，返回带有指定类的所有元素的类数组对象 `HTMLCollection` 。传入多个类名时，类名的先后顺序不重要。与 ``getElementsByTagName()` 类似，该方法既可以用于 `HTML` 文档对象，也可以用于 `element` 元素对象

[注意]IE8-浏览器不支持

```html
<ul id="list">
    <li class="a ab c">1</li>
    <li class="a">2</li>
    <li class="ac">3</li>
    <li class="a b c">4</li>
    <li class="a b">5</li>
</ul>
<script>
//类名中存在a成立
Array.prototype.forEach.call(list.getElementsByClassName('a'),function(item,index,arr){
    item.style.fontWeight = 'bold';
});
//只有类名中同时存在a和c才成立
Array.prototype.forEach.call(list.getElementsByClassName('a c'),function(item,index,arr){
    item.style.color = 'red';
});
</script>
```

#### classList属性

`HTML5` 为所有元素添加了 `classList` 属性，这个 `classList` 属性是新集合类型 `DOMTokenList` 的实例，它有一个表示自己包含多少元素的 `length` 属性，而要取得每个元素可以使用 `item()` 方法，也可以使用方括号法

[注意]IE9-浏览器不支持

```html
<div id="test" class="a b c"></div>
<script>
console.log(test.classList);//["a", "b", "c", value: "a b c"]
console.log(test.classList[0]);//a
console.log(test.classList.item(1));//b
</script>
```

此外，这个新类型还定义如下方法：

```
add(value)             将给定的字符串值添加到列表中，如果值已存在，则不添加
contains(value)        表示列表中是否存在给定的值，如果存在则返回true,否则返回false
remove(value)          从列表中删除给定的字符串
toggle(value)          如果列表中已经存在给定的值，删除它；如果列表中没有给定的值，添加它
```

有了 `classList` 属性，`className` 属性基本没有什么用武之地了

```html
<style>
.cB{color: blue;}
</style>

<body>
<div id="test">测试文字</div>
<button id="btn1" onclick = "test.classList.add('cB')">add</button>
<button id="btn2" onclick = "test.classList.contains('cB')?alert(true):alert(false)">contains</button>
<button id="btn3" onclick = "test.classList.remove('cB')">remove</button>
<button id="btn4" onclick = "test.classList.toggle('cB')">toggle</button>
</body>
```

### querySelector()

`querySelector()` 方法接收一个 `CSS` 选择符，返回与该模式匹配的第一个元素，如果没有找到匹配的元素，返回 `null` 。该方法既可用于文档 `document` 类型，也可用于元素 `element` 类型。

[注意]IE7-浏览器不支持

```html
<body style="height: 100%;">
<div class="box" id="box" style="height: 200px;">
<ul class="list" style="height:100px">
        <li class="in" style="height: 30px;">1</li>
        <li class="in" style="height: 30px;" title="test">2</li>
        <li class="in" style="height: 30px;">3</li>
    </ul>    
</div>
<script>
//因为没有.null类名，所以返回null
var oNull = document.querySelector('.null');
console.log(oNull);//null
//通过<body>标签取得元素
var body = document.querySelector("body");
console.log(body.style.height);//100%
//通过id属性取得元素
var oBox = document.querySelector('#box');
console.log(oBox.style.height);//200px
//通过结合元素的类选择器取得元素
var oList = document.querySelector('ul.list');
console.log(oList.style.height);//100px
//通过类名取得元素
var oIn = document.querySelector('.in');
console.log(oIn.innerHTML);//1
//通过属性选择器取得元素
var oTest = body.querySelector('[title="test"]');
console.log(oTest.innerHTML);//2
</script>
</body> 
```

### querySelectorAll()

`querySelectorAll()` 接收一个 `CSS` 选择符，返回一个类数组对象`NodeList` 的实例。具体来说，返回的值实际上是带有所有属性和方法的`NodeList`，而其底层实现则类似于一组元素的快照，而非不断对文档进行搜索的动态查询。这样实现可以避免使用 `NodeList` 对象通常会引起的大多数性能问题。只要传给 `querySelectorAll()` 方法的 `CSS` 选择符有效，该方法都会返回一个`NodeList`对象，而不管找到多少匹配的元素

没有匹配元素时，返回空的类数组对象，而不是 `null`

[注意]IE7-浏览器不支持

```html
<body style="height: 100%;">
<div class="box" id="box" style="height: 200px;">
<ul class="list" style="height:100px">
        <li class="in" style="height: 30px;">1</li>
        <li class="in" style="height: 30px;" title="test">2</li>
        <li class="in" style="height: 30px;">3</li>
    </ul>    
</div>
<script>
//返回[]
var oNull = document.querySelectorAll('.null');
console.log(oNull);
//取得body元素
var body = document.querySelectorAll("body")[0];
console.log(body.style.height);//100%
//取得所有class为"in"的元素
var oIn = document.querySelectorAll('.in');
for(var i = 0 ; i < oIn.length; i++){
    console.log(oIn[i].innerHTML);//1,2,3    
}
//取得title属性为test的元素
var oTest = body.querySelectorAll('[title="test"]');
console.log(oTest);//[li.in]
</script>
</body>
```

### matchesSelector()

`matchesSelector()` 方法接收一个 `CSS` 选择符参数，如果调用元素与该选择符相匹配，返回 `true`；否则返回 `false`

```html
<body id="test">
<script>
    //Uncaught TypeError: document.body.matchesSelector is not a function
    console.log(document.body.matchesSelector('#test'));
</script>
</body>
```

由于兼容性问题，现在各个浏览器都只支持加前缀的方法。IE9+浏览器支持`msMatchesSelector()`方法，firefox支持`mozMatchesSelector()`方法，safari和chrome支持 `webkitMatchesSelector()`方法。所以兼容写法为:

```js
function matchesSelector(element,selector){
    if(element.matchesSelector){
        return element.matchesSelector(selector);
    }
    if(element.msMatchesSelector){
        return element.msMatchesSelector(selector);
    }
    if(element.mozMatchesSelector){
        return element.mozMatchesSelector(selector);
    }
    if(element.webkitMatchesSelector){
        return element.webkitMatchesSelector(selector);
    }            
}
<body id="test">
<script>
console.log(matchesSelector(document.body,'#test'));//true
</script>
</body>
```