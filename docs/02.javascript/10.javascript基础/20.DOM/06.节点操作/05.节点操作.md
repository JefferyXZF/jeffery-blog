---
title: 节点操作
date: 2021-04-08 19:30:01
permalink: /pages/aacsssweew
author: 
  name: jeffery
categories: 
  - javascript
tags: 
  - javascript
---

# 节点操作

## 节点关系

`DOM` 将 `HTML` 描绘成一个由多层节点构成的结构。节点分为 12 种不同类型，每种类型分别表示文档中不同的信息及标记。每个节点都拥有各自的特点、数据和方法，也与其他节点存在某种关系。节点之间的关系构成了层次，而所有页面标记则表现为一个以特定节点为根节点的树形结构。

![nodeRelation](https://gitee.com/FIF/pic-beg/raw/master/images/javascript/JS_DOM_node_nodeRelation.jpg)

节点中的各种关系可以用传统的家族关系来描述，相当于把文档树比喻成家谱。

### 属性
#### 父级属性

**parentNode**

每个节点都有一个 `parentNode` 属性，该属性指向文档树中的父节点。对于一个节点来说，它的父节点只可能是三种类型：`element`  节点、`document` 节点和`documentfragment` 节点。如果不存在，则返回 `null`

```html
<div id="myDiv"></div>
<script>
console.log(myDiv.parentNode);//body
console.log(document.body.parentNode);//html
console.log(document.documentElement.parentNode);//document
console.log(document.parentNode);//null
</script>

<div id="myDiv"></div>
<script>
var myDiv = document.getElementById('myDiv');
console.log(myDiv.parentNode);//body
var fragment = document.createDocumentFragment();
fragment.appendChild(myDiv);
console.log(myDiv.parentNode);//document-fragment
</script>
```

**parentElement**

与 `parentNode` 属性不同的是，`parentElement` 返回的是父元素节点

```html
<div id="myDiv"></div>
<script>
console.log(myDiv.parentElement);//body
console.log(document.body.parentElement);//html
console.log(document.documentElement.parentElement);//null
console.log(document.parentElement);//null
</script>
```
::: tip
在IE浏览器中，只有 `Element` 元素节点才有该属性，其他浏览器则是所有类型的节点都有该属性
:::

```html
<div id="test">123</div>
<script>
//IE浏览器返回undefined，其他浏览器返回<div id="test">123</div>
console.log(test.firstChild.parentElement);
//所有浏览器都返回<body>
console.log(test.parentElement);
</script>
```
#### 子级属性

**childNodes**

`childNodes` 是一个只读的类数组对象 `NodeList` 对象，它保存着该节点的第一层子节点

```html
<ul id="myUl"><li><div></div></li></ul>
<script>
var myUl = document.getElementById('myUl');
//结果是只包含一个li元素的类数组对象[li]
console.log(myUl.childNodes);
</script>
```

**children**

`children` 是一个只读的类数组对象 `HTMLCollection` 对象，但它保存的是该节点的第一层元素子节点

```html
<div id="myDiv">123</div>
<script>
var myDiv = document.getElementById('myDiv');
//childNodes包含所有类型的节点，所以输出[text]
console.log(myDiv.childNodes);
//children只包含元素节点，所以输出[]
console.log(myDiv.children);
</script>
```

**childElementCount**

返回子元素节点的个数，相当于 `children.length`

[注意]IE8-浏览器不支持

```html
<ul id="myUl">
    <li></li>
    <li></li>
</ul>
<script>
var myUl = document.getElementById('myUl');
console.log(myUl.childNodes.length);//5，IE8-浏览器返回2，因为不包括空文本节点
console.log(myUl.children.length);//2
console.log(myUl.childElementCount);//2，IE8-浏览器返回undefined
</script>
```

**firstChild**

第一个子节点

**lastChild**

最后一个子节点

**firstElementChild**

第一个元素子节点

**lastElementChild**

最后一个元素子节点　

上面四个属性，IE8-浏览器和标准浏览器的表现并不一致。IE8-浏览器不考虑空白文本节点，且不支持 `firstElementChild` 和 `lastElementChild`

```html
//ul标签和li标签之间有两个空白文本节点，所以按照标准来说，ul的子节点包括[空白文本节点、li元素节点、空白文本节点]。但在IE8-浏览器中，ul的子节点只包括[li元素节点]
<ul>
    <li></li>
</ul>
<ul id="list">
    <li>1</li>
    <li>2</li>
    <li>3</li>
</ul>
<script>
console.log(list.firstChild);//标准浏览器中返回空白文本节点，IE8-浏览器中返回<li>1</li>
console.log(list.lastChild);//标准浏览器中返回空白文本节点，IE8-浏览器中返回<li>3</li>
console.log(list.firstElementChild);//标准浏览器中<li>1</li>，IE8-浏览器中返回undefined
console.log(list.lastElementChild);//标准浏览器中<li>3</li>，IE8-浏览器中返回undefined
</script>
```
#### 同级属性

**nextSibling**

后一个节点

**previousSibling**

前一个节点

**nextElementSibling**

后一个元素节点

**previousElementSibling**

前一个元素节点

与子级属性类似，上面四个属性，IE8-浏览器和标准浏览器的表现并不一致。IE8-浏览器不考虑空白文本节点，且不支持 `nextElementSibling` 和`previousElementSibling`

```html
<ul>
    <li>1</li>
    <li id="myLi">2</li>
    <li>3</li>
</ul>
<script>
var myLi = document.getElementById('myLi');
console.log(myLi.nextSibling);//空白节点，IE8-浏览器返回<li>3</li>
console.log(myLi.nextElementSibling);//<li>3</li>，IE8-浏览器返回undefined
console.log(myLi.previousSibling);//空白节点，IE8-浏览器返回<li>1</li>
console.log(myLi.previousElementSibling);//<li>1</li>，IE8-浏览器返回undefined
</script>
```

 

### 方法
#### 包含方法

**hasChildNodes()**

`hasChildNodes()` 方法在包含一个或多个子节点时返回 `true`，比查询`childNodes` 列表的 `length` 属性更简单

```html
<div id="myDiv">123</div>
<script>
var myDiv = document.getElementById('myDiv');
console.log(myDiv.childNodes.length);//1
console.log(myDiv.hasChildNodes());//true
</script>

<div id="myDiv"></div>
<script>
var myDiv = document.getElementById('myDiv');
console.log(myDiv.childNodes.length);//0
console.log(myDiv.hasChildNodes());//false
</script>
```

**contains()**

`contains` 方法接受一个节点作为参数，返回一个布尔值，表示参数节点是否为当前节点的后代节点。参数为后代节点即可，不一定是第一层子节点　

```html
<div id="myDiv">
    <ul id="myUl">
        <li id="myLi"></li>
        <li></li>
    </ul>
</div>
<script>
console.log(myDiv.contains(myLi));//true
console.log(myDiv.contains(myUl));//true
console.log(myDiv.contains(myDiv));//true
</script>
```

::: tip
IE和safari不支持 `document.contains()` 方法，只支持元素节点的`contains()`方法
:::

```html
//IE和safari报错，其他浏览器返回true
console.log(document.contains(document.body));
```
#### 关系方法

**compareDocumentPosition()**

`compareDocumentPosition` 方法用于确定节点间的关系，返回一个表示该关系的位掩码

```
000000    0     两个节点相同
000001    1     两个节点不在同一个文档（即有一个节点不在当前文档）
000010    2     参数节点在当前节点的前面
000100    4     参数节点在当前节点的后面
001000    8     参数节点包含当前节点
010000    16    当前节点包含参数节点
100000    32    浏览器的私有用途
```

```html
<div id="myDiv">
    <ul id="myUl">
        <li id="myLi1"></li>
        <li id="myLi2"></li>
    </ul>
</div>
<script>
//20=16+4，因为myUl节点被myDiv节点包含，也位于myDiv节点的后面
console.log(myDiv.compareDocumentPosition(myUl));

//10=8+2，因为myDiv节点包含myUl节点，也位于myUl节点的前面
console.log(myUl.compareDocumentPosition(myDiv));

//0，两个节点相同
console.log(myDiv.compareDocumentPosition(myDiv));

//4，myLi2在myLi1节点的后面
console.log(myLi1.compareDocumentPosition(myLi2));

//2，myLi1在myLi2节点的前面
console.log(myLi2.compareDocumentPosition(myLi1));
</script>
```

**isSameNode()和isEqualNode()**

这两个方法都接受一个节点参数，并在传入节点与引用节点相同或相等时返回 `true`

所谓相同(`same`)，指的是两个节点引用的是同一个对象

所谓相等(`equal`)，指的是两个节点是相同的类型，具有相等的属性(`nodeName`、`nodeValue`等等)，而且它们的 `attributes` 和 `childNodes` 属性也相等(相同位置包含相同的值)

::: tip
firefox不支持 `isSameNode()`方法，而IE8-浏览器两个方法都不支持
:::

```html
<script>
var div1 = document.createElement('div');
div1.setAttribute("title","test");
var div2 = document.createElement('div');
div2.setAttribute("title","test");
console.log(div1.isSameNode(div1));//true
console.log(div1.isEqualNode(div2));//true
console.log(div1.isSameNode(div2));//false
</script>
```

## 节点操作

### 创建节点

**createElement()**

`document.createElement()` 方法可以创建新元素。这个方法接受一个参数，即要创建元素的标签名，这个标签名在 `HTML` 文档中不区分大小写

```js
var oDiv = document.createElement("div");
console.log(oDiv);//<div>
```

所有节点都有一个 `ownerDocument` 的属性，指向表示整个文档的文档节点 `document`；在使用 `createElement()` 方法创建新元素的同时，也为新元素设置了 `ownerDocument` 属性

```html
<div id="myDiv"></div>
<script>
console.log(myDiv.ownerDocument);//document
var newDiv = document.createElement('div');
console.log(newDiv.ownerDocument);//document
console.log(newDiv.ownerDocument === myDiv.ownerDocument);//true
</script>
```

### 插入节点

**appendChild()**

`appendChild()` 方法用于向 `childNodes` 列表的末尾添加一个节点，并返回新增节点。添加节点后，`childNodes` 中的新增节点、父节点和以前的最后一个子节点的关系指针都会相应地得到更新

```html
<div id="box"></div>
<script>
var oBox = document.getElementById('box');
var newNode = document.createElement('ul');
var returnedNode = oBox.appendChild(newNode);
console.log(returnedNode.nodeName);//UL
console.log(returnedNode == newNode);//true
console.log(returnedNode == oBox.lastChild);//true
</script>
```

如果插入的节点已经是文档的一部分了，那结果就是将该节点从原来的位置转移到新位置

```html
<body>
<div id="oldDiv">第一个div</div>
<div id="newDiv">第二个div</div>
<button id="btn">变换位置</button>

<script>
btn.onclick = function(){
    document.body.appendChild(newDiv);
}    
</script>
</body>
```

**insertBefore()**

`insertBefore()` 方法接收两个参数：要插入的节点和作为参照的节点。插入节点后，被插入的节点会变成参照节点的前一个兄弟节点( `previousSibling` )，同时被方法返回。如果参照节点是 `null`，则`insertBefore()` 与 `appendChild()` 方法执行相同的操作。同样地，如果插入的节点已经是文档的一部分了，那结果就是将该节点从原来的位置转移到新位置

```html
<!-- referenceNode.parentNode.insertBefore(newNode,referenceNode); -->
<ul id="myUl" style="border:1px solid black;">
    <li id="myLi">
        <div id='oldDiv'>oldDiv</div>
    </li>    
</ul>
<button id="btn1">插入oldDiv的前面</button>
<button id="btn2">插入myUl的前面</button>
<button id="btn3">插到oldDiv的里面</button>
<script>
var oDiv = document.createElement('div');
oDiv.innerHTML = 'newDiv';
btn1.onclick = function(){
    console.log(myLi.insertBefore(oDiv,oldDiv));//<div>newDiv</div>
}
btn2.onclick = function(){
    console.log(document.body.insertBefore(oDiv,myUl));//<div>newDiv</div>
}
btn3.onclick = function(){
    console.log(oldDiv.insertBefore(oDiv,null));//<div>newDiv</div>
}
</script>
```

**insertAfter()**

由于不存在 `insertAfter()` 方法，如果要插在当前节点的某个子节点后面，可以用 `insertBefore()` 和 `appendChild()` 封装方法

```html
<div id='oldDiv'>old</div>
<button id="btn">增加节点</button>
<script>
function insertAfter(newElement,targetElement){
    var parent = targetElement.parentNode;
    if(parent.lastChild == targetElement){
       return parent.appendChild(newElement);
    }else{
       return parent.insertBefore(newElement,targetElement.nextSibling)
    }
}    
var newDiv = document.createElement('div');
newDiv.innerHTML = 'new';
btn.onclick = function(){
    insertAfter(newDiv,oldDiv);
}
</script>
```


**insertAdjacentHTML()**

`insertAdjacentHTML()` 方法作为终级办法，相当于前面三个方法的综合。该方法接收两个参数：插入的位置和要插入的 `HTML` 文本

第一个参数必须是下列值之一，且这些值都必须是小写形式：

```js
　　"beforebegin"    　 在当前元素之前插入一个紧邻的同级元素
　　"afterbegin"    　　在当前元素之下插入一个新的子元素或在第一个子元素之前再插入新的子元素
　　"beforeend"        在当前元素之下插入一个新的子元素或在最后一个子元素之后再插入新的子元素
　　"afterend"         在当前元素之后插入一个紧邻的同级元素
```

第二个参数是一个 `HTML` 字符串，如果浏览器无法解析字符串，就会抛出错误

[注意]该方法无返回值

![insertAdjacentHTML](https://gitee.com/FIF/pic-beg/raw/master/images/javascript/JS_DOM_node_insertAdjacentHTML.jpg)

```html
<div id='target' style="border: 1px solid black;">This is the element content</div>
<button>beforebegin</button>
<button>afterbegin</button>
<button>beforeend</button>
<button>afterend</button>
<script>
var btns = document.getElementsByTagName('button');
for(var i = 0 ; i < 4; i++){
    btns[i].onclick = function(){
        var that = this;
        target.insertAdjacentHTML(that.innerHTML,'<span id="test">测试</span>')    
    }
}
</script>    
```

### 移除节点

**removeChild()**

`removeChild()` 方法接收一个参数，即要移除的节点，被移除的节点成为方法的返回值

```html
<div id="myDiv">等待移除的节点</div>
<button id="btn">移除节点</button>
<script>
btn.onclick = function(){
    document.body.removeChild(myDiv);
}
</script>
```


下面代码可以移除当前节点的所有子节点

```js
var element = document.getElementById("top");
while (element.firstChild) {
  element.removeChild(element.firstChild);
}
```

【小效果】

```html
<button id="btn">开始删除节点</button>
<ul class="list" id="list">
    <li class="in">1</li>
    <li class="in">2</li>
    <li class="in">3</li>
    <li class="in">4</li>
    <li class="in">5</li>
    <li class="in">6</li>        
</ul>
<script>
var oList = document.getElementById('list');
function incrementNumber(){
    //获取oList中子元素的个数
    var len = oList.getElementsByTagName('li').length;
    //如果长度不为0
    if(len){
        //删除最后一个子元素
        oList.removeChild(oList.getElementsByTagName('li')[len-1]);
        //再次调用计时器
        setTimeout(incrementNumber,1000);    
    }
}
btn.onclick = function(){
    //1s后执行函数incrementNumber
    setTimeout(incrementNumber,1000);    
}
</script>
```

**remove()**

相比于 `removeChild()`，`remove()` 方法不太常见，但是却非常简单。该方法不用调用其父节点，直接在当前节点使用 `remove()` 方法就可以删除该节点，无返回值

`remove()` 方法常用于删除元素节点和文本节点，不可用于特性节点

[注意]IE浏览器不支持该方法

```html
<div id="test" title='div'>123</div>
<script>
//文本节点
console.log(test.childNodes[0]);//'123'
test.childNodes[0].remove();
console.log(test.childNodes[0]);//undefined

//特性节点
console.log(test.attributes.title);//'div'
//报错，remove()方法无法用于删除特性节点
try{test.attributes[0].remove()}catch(e){
    console.log('error');
}
//元素节点
console.log(test);
test.remove();
</script>
```
### 替换节点

**replaceChild()**

`replaceChild()` 接收的两个参数是要插入的节点和要替换的节点，要替换的节点将由这个方法返回并从文档树中移除，同时由要插入的节点占据其位置

```html
<!-- oldChild.parentNode.replaceChild(newChild, oldChild); -->
<div id="div1">1</div>
<div id="div2">2</div>
<div id="div3">3</div>
<button id="btn1">新增节点替换(4替换2)</button>
<button id="btn2">原有节点替换(3替换1)</button>
<script>
btn2.onclick = function(){
    document.body.replaceChild(div3,div1);
}
btn1.onclick = function(){
    var div4 = document.createElement('div');
    div4.innerHTML = '4';
    document.body.replaceChild(div4,div2);
}
</script>
```


【小效果】

```html
<button id="btn">开始替换节点</button>
<ul class="list" id="list">
    <li class="in">1</li>
    <li class="in">2</li>
    <li class="in">3</li>
    <li class="in">4</li>
    <li class="in">5</li>
    <li class="in">6</li>        
</ul>
<script>
var oList = document.getElementById('list');
//新增一个li元素
var oAdd = document.createElement('li');
//设置新增元素的css样式
oAdd.className = "in";
oAdd.style.cssText = 'background-color:red;border-radius:50%';
btn.onclick = function(){
    //1s后oAdd替换第0个li
    setTimeout(function(){
        oList.replaceChild(oAdd,document.getElementsByTagName('li')[0]);
        //1s后执行incrementNumber函数
        setTimeout(incrementNumber,1000);    
    },1000);    
}

function incrementNumber(){
    //获取oList中第1个li
    var oLi1 = document.getElementsByTagName('li')[1];
    //若存在则进行替换处理
    if(oLi1){
         oList.replaceChild(oAdd,oLi1);
         setTimeout(incrementNumber,1000);        
    }
}
</script>
```
### 复制节点

**cloneNode()**

`cloneNode` 方法用于克隆一个节点。它接受一个布尔值作为参数，表示是否执行深复制。在参数为 `true` 时，执行深复制，也就是复制节点及整个子节点树。在参数为 `false` 的情况下，执行浅复制，即复制节点本身。复制后返回的节点副本属于文档所有，但并没有为它指定父节点。若参数为空，也相当于 `false`

[注意] `cloneNode()` 方法不会复制添加到 `DOM` 节点中的`javascript` 属性，例如事件处理程序等。这个方法只复制特性和子节点，其他一切都不会复制

```html
<ul id="list">
    <li>1</li>
    <li>2</li>
    <li>3</li>
    <li>4</li>
    <li>5</li>
    <li>6</li>        
</ul>
<script>
var oList = document.getElementById('list');
oList.index = 0;

var deepList = oList.cloneNode(true);
//成功复制了子节点
console.log(deepList.children.length);//6
//但并没有复制属性
console.log(deepList.index);//undefined
var shallowList = oList.cloneNode();
//浅复制不复制子节点
console.log(shallowList.children.length);//0
</scr
```

## 节点内容

### innerHTML

`innerHTML` 属性可读可写。在读模式下，返回与调用元素的所有子节点(包括元素、注释和文本节点)对应的 `HTML`标记；在写模式下，`innerHTML` 会根据指定的值创建新的 `DOM` 树，然后用这个 `DOM` 树完全替换调用元素原先的所有子节点

```html
<p id="test">This is a <i>simple</i> document</p>
<script>
console.log(test.innerHTML);//'This is a <i>simple</i> document'
test.innerHTML = 123;
console.log(test.innerHTML);//'123'    
</script>
```

### outerHTML

`outerHTML` 同样可读可写，与 `innerHTML` 相比，它包含被查询元素的开始和结束标签。在读模式下 `outerHTML` 返回调用它的元素及所有子节点的`HTML`标签；在写模式下，`outerHTML`会根据指定的`HTML`字符串创建新的`DOM`子树，然后用这个`DOM`子树完全替换调用元素 

```html
<p id="test">This is a <i>simple</i> document</p>
<script>
console.log(test.outerHTML);//<p id="test">This is a <i>simple</i> document</p>
test.outerHTML = '<div id="test"></div>';
console.log(test.outerHTML);//'<div id="test"></div>'
</script>
```

### innerText

`innerText` 属性可以操作元素中包含的所有文本内容，包括子文档树中的文本。在通过 `innerText` 读取值时，它会按照由浅入深地顺序，将子文档树中的所有文本拼接起来。在通过 `innerText` 写入值时，结果会删除元素的所有子节点，插入包含相应文本值的文本节点

```html
<p id="test">This is a <i>simple</i> document</p>
<script>
console.log(test.innerText);//'This is a simple document'
test.innerText = '<div id="test"></div>';
console.log(test.innerText);//'<div id="test"></div>'
//即使在innerText中设置元素节点，最终也只是作为字符串内部的文本显示
console.log(test.childNodes[0].nodeType);//3
</script>
```

设置 `innerText` 属性只会生成当前节点的一个子文本节点 `Text`。因此，可以利用将 `innerText` 设置为等于 `innerText` 来去掉所有 `HTML` 标签

```html
<p id="test">This is a <i>simple</i> document</p>
<script>
console.log(test.innerHTML);//'This is a <i>simple</i> document'
test.innerText = test.innerText;
console.log(test.innerHTML);//'This is a simple document'
</script>
```

### outerText

在读取文本值时，`outerText` 与 `innerText` 的结果完全一样，但在写模式下，`outerText` 不只是替换调用它的元素的子节点，而是会替换整个元素

```html
<p id="test">This is a <i>simple</i> document</p>
<script>
console.log(test.outerText);//'This is a simple document'
test.outerText = '123';
console.log(document.body.childNodes[0]);//'  123'
//报错，因为<p>元素已经被替换为'123'，不再存在了
console.log(test.outerText);
</script>
```

### textContent

`textContent` 属性与 `innerText` 属性类似，该属性可读写。在读模式下，返回当前节点和它的所有后代节点的文本内容；在写模式下，结果会删除元素的所有子节点，插入包含相应文本值的文本节点

```html
<p id="test">This is a <i>simple</i> document</p>
<script>
console.log(test.textContent);//'This is a simple document'
test.textContent = '<div id="test"></div>';
console.log(test.textContent);//'<div id="test"></div>'
//即使在textContent中设置元素节点，最终也只是作为字符串内部的文本显示
console.log(test.childNodes[0].nodeType);//3
</script>
```

与 `innerText` 不同的是，`textContent` 属性不仅属于元素节点`ElementNode`，而是属于所有节点`Node`

```html
<p id="test">This is a <i>simple</i> document</p>
<script>
var oText = test.childNodes[0];
console.log(oText.textContent);//'This is a '
console.log(oText.innerText);//undefined
</script>
```



## 节点遍历

`DOM` 遍历模块定义了用于辅助完成顺序遍历 `DOM` 结构的类型：`Nodeiterator` 和 `TreeWalker`，它们能够基于给定的起点对 `DOM` 结构执行深度优先(depth-first)的遍历操作。本文将详细介绍 `DOM` 遍历

### 定义

`DOM` 遍历是深度优先的 `DOM` 结构遍历，遍历以给定节点为根，不可能向上超出`DOM` 树的根节点。以下面的 `HTML` 页面为例

```html
<!DOCTYPE html>
<html>
    <head>
        <title>Example</title>
    </head>
    <body>
    <p><b>Hello</b> world!</p>
    </body>
</html>
```

下图展示了这个页面的DOM树

![domTree](https://gitee.com/FIF/pic-beg/raw/master/images/javascript/JS_DOM_node_domTree.png)

任何节点都可以作为遍历的根节点，如果假设`<body>`元素为根节点，那么遍历的第一步就是访问`<p>`元素，然后再访问同为`<body>`元素后代的两个文本节点。不过，这次遍历永远不会到达`<html>`、`<head>`元素，也不会到达不属于`<body>`元素子树的任何节点。而以`document`为根节点的遍历则可以访问到文档中的全部节点

下图展示了对以 `document` 为根节点的`DOM`树进行深度优先遍历的先后顺序

![domTree2](https://gitee.com/FIF/pic-beg/raw/master/images/javascript/JS_DOM_node_domTree2.png)

从`document`开始依序向前，访问的第一个节点是`document`，访问的最后一个节点是包含 `"world!"`的文本节点。从文档最后的文本节点开始，遍历可以反向移动到 `DOM` 树的顶端。此时，访问的第一个节点是包含 `Hello` 的文本节点，访问的最后一个节点是 `document` 节点。`Nodeiterator` 和 `TreeWalker`都以这种方式执行遍历

### NodeIterator

可以使用 `document.createNodeIterator()` 方法创建` NodeIterator` 类型的新实例。这个方法接受下列4个参数

```js
root：想要作为搜索起点的树中的节点
whatToShow：表示要访问哪些节点的数字代码
filter：是一个NodeFilter对象，或者一个表示应该接受还是拒绝某种特定节点的函数
entityReferenceExpansion：布尔值，表示是否要扩展实体引用。这个参数在HTML页面中没有用，因为其中的实体引用不能扩展
```

`whatToshow` 参数是一个位掩码，通过应用一或多个过滤器(filter)来确定要访问哪些节点。这个参数的值以常量形式在 `NodeFilter`类型中定义，如下所示

```js
NodeFilter.SHOW_ALL：显示所有类型的节点
NodeFilter.SHOW_ELEMENT：显示元素节点
NodeFilter.SHOW_ATTRIBUTE：显示特性节点。由于DOM结构原因，实际上不能使用这个值
NodeFilter.SHOW_TEXT：显示文本节点
NodeFilter.SHOW_CDATA_SECTION：显示CDATA节点。对HTML页面没有用
NodeFilter.SHOW_ENTITY_REFERENCE：显示实体引用节点。对HTML页面没有用
NodeFilter.SHOW_ENTITYE：显示实体节点。对HTML页面没有用
NodeFilter.SH0W_PROCESSING_INSTRUCTION：显示处理指令节点。对HTML页面没有用
NodeFi1ter.SHOW_COMMENT：显示注释节点
NodeFilter.SHOW_DOCUMENT：显示文档节点
NodeFilter.SHOW_DOCUMENT_TYPE：显示文档类型节点
NodeFilter.SHOW_DOCUMENT_FRAGMENT：显示文档片段节点。对HTML页面没有用
NodeFilter.SHOW_NOTATION：显示符号节点。对HTML页面没有用
```

除了 `NodeFilter.SHOW_ALL` 之外，可以使用按位或操作符来组合多个选项，如下所示：

```js
var whatToShow = NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_TEXT;
```

可以通过 `createNodeIterator()` 方法的 `filter` 参数来指定自定义的`NodeFilter`对象，或者指定一个功能类似节点过滤器(node filter)的函数。每个 `NodeFilter` 对象只有一个方法，即 `acceptNode()；`如果应该访问给定的节点，该方法返回 `NodeFilter.FILTER_ACCEPT`，如果不应该访问给定的节点，该方法返回 `NodeFilter.FILTER_SKIP`。由于`NodeFilter`是一个抽象的类型，因此不能直接创建它的实例。在必要时，只要创建一个包含`acceptNode()`方法的对象，然后将这个对象传入`createNodeIterator()`中即可

下列代码展示了如何创建一个只显示`<p>`元素的节点迭代器

```js
var filter = {
    acceptNode:function(node){
        return node.tagName.toLowerCase() == "p" ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
    }
}
var iterator = document.createNodeIterator(root, NodeFilter.SHOW_ELEMENT, filter, false);
```

第三个参数也可以是一个与 `acceptNode()`方法类似的函数，如下所示

```js
var filter = function(node){
        return node.tagName.toLowerCase() == "p" ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
}
var iterator = document.createNodeIterator(root, NodeFilter.SHOW_ELEMENT, filter, false);
```

一般来说，这就是在 `javascript` 中使用这个方法的形式，这种形式比较简单，而且也跟其他的 `javascript` 代码很相似。如果不指定过滤器，那么应该在第三个参数的位置上传入 `null`

　　下面的代码创建了一个能够访问所有类型节点的简单的 `NodeIterator`

```js
var iterator = document.createNodeIterator(document, NodeFilter.SHOW_ALL, null, false);
```

`NodeIterator` 类型的两个主要方法是 `nextNode()` 和 `previousNode()`。顾名思义，在深度优先的 `DOM` 子树遍历中，`nextNode()` 方法用于向前前进一步，而 `previousNode()` 用于向后后退一步

在刚刚创建的 `NodeIterator` 对象中，有一个内部指针指向根节点，因此第一次调用 `nextNode()` 会返回根节点。当遍历到 `DOM` 子树的最后一个节点时，`nextNode()`返回`null`。`previousNode()`方法的工作机制类似。当遍历到`DOM`子树的最后一个节点，且`previousNode()`返冋根节点之后，再次调用它就会返回`null`

以下面的HTML片段为例

```html
<div id="div1">
    <p><b>Hello</b> world!</p>
    <ul>
        <li>List item 1</li>
        <li>List item 2</li>
        <li>List item 3</li>
    </ul>
</div>
```

假设我们想要遍历 `<div>`元素中的所有元素，那么可以使用下列代码

```js
var div = document.getElementById("div1");
var iterator = document.createNodeIterator(div, NodeFilter.SHOW_ELEMENT, null, false);
var node = iterator.nextNode();
while(node !== null) {
    console.log(node.tagName);    //输出标签名
    node = iterator.nextNode();
}
```

在这个例子中，第一次调用 `nextNode()` 返回 `<p>` 元素。因为在到达`DOM`子树末端时`nextNode()`返回`null`，所以这里使用了`while`语句在每次循环时检查对`nextNode()`的调用是否返回了`null`

如果只想返回遍历中遇到的`<li>`元素。只要使用一个过滤器即可，如下所示

```js
var div = document.getElementById("div1");
var filter = function(node){
    return node.tagName.toLowerCaee() == "li" ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
};
var iterator = document.createNodeIterator(div, NodeFilter.SHOW_ELEMENT, filter, false);

var node = iterator.nextNode(); 
while(node !== null) {
    console.log(node.tagName);//输出标签名
    node = iterator.nextNode();
}
```

在上面这个例子中，迭代器只会返回 `<li>`元素

由于 `nextNode()`和`previousNode()`方法都基于`NodeIterator`在`DOM`结构中的内部指针工作，所以`DOM`结构的变化会反映在遍历的结果中

### TreeWalker

`TreeWalker` 是 `NodeIterator` 的一个更高级的版本。除了包括`nextNode()`和`previousNode()`在内的相同的功能之外，这个类型还提供了下列用于在不同方向上遍历`DOM`结构的方法

```js
parentNode()：遍历到当前节点的父节点
firstChild()：遍历到当前节点的第一个子节点
lastChild()：遍历到当前节点的最后一个子节点
nextSibling()：遍历到当前节点的下一个同辈节点
previousSibling()：遍历到当前节点的上一个同辈节点
```

创建 `TreeWalker` 对象要使用 `document.createTreeWalker()` 方法，这个方法接受的4个参数与 `document.createNodelterator()` 方法相同：作为遍历起点的根节点、要显示的节点类型、过滤器和一个表示是否扩展实体引用的布尔值。由于这两个创建方法很相似，所以很容易用 `TreeWalker` 来代替`NodeIterator`，如下所示

```js
var div = document.getElementById("div1");
var filter = function(node){
    return node.tagName.toLowerCase() == "li"? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
}
var walker = document.createTreeWalker(div,NodeFilter.SHOW_ELEMENT, filter, false);
var node = walker.nextNode();
while(node !== null) {
    console.log(node.tagName);//输出标签名
    node = walker.nextNode();
}
```

在这里，`filter` 可以返回的值有所不同。除了 `NodeFilter.FILTER_ACCEPT` 和 `NodeFilter.FILTER_SKIP` 之外，还可以使用`NodeFilter.FILTER_REJECT`。在使用 `NodeIterator` 对象时，`NodeFilter.FILTER_SKIP` 与 `NodeFilter.FILTER_REJECT` 的作用相同：跳过指定的节点。但在使用 `TreeWalker` 对象时，`NodeFilter.FILTER_SKIP` 会跳过相应节点继续前进到子树中的下一个节点，而 `NodeFilter.FILTER_REJECT` 则会跳过相应节点及该节点的整个子树。例如，将前面例子中的 `NodeFilter.FILTER_SKIP` 修改成 `NodeFilter.FILTER_REJECT`，结果就是不会访问任何节点。这是因为第一个返回的节点是`<div>`，它的标签名不是`"li"`，于是就会返回`NodeFilter.FILTER_REJECT`，这意味着遍历会跳过整个子树。在这个例子中，`<div>`元素是遍历的根节点，于是结果就会停止遍历

当然，`TreeWalker`真正强大的地方在于能够在DOM结构中沿任何方向移动。使用`TreeWalker`遍历`DOM`树，即使不定义过滤器，也可以取得所有`<li>`元素，如下所示

```js
var div = document.getElementById("div1");
var walker = document.createTreeWalker(div, NodeFilter.SHOW_ELEMENT, null, false);
walker.firstChild();//转到<p>
walker.nextSibling();//转到<ul>
var node = walker.firstChild();    //转到第一个<li>
while(node !== null){
    console.log(node.tagName);
    node = walker.nextSibling();
}
```

因为我们知道`<li>`元素在文挡结构中的位置，所以可以直接定位到那里，即使用`firstChild()`转到`<p>`元素，使用`nextSibling()`转到`<ul>`元素，然后再使用`firstchild`()转到第一个 `<li>`元素

::: tip
此处 `TreeWalker` 只返回元素(由传入到createTreeWalker()的第二个参数决定)。因此，可以放心地使用 `nextSibling()` 访问每一个 `<li>` 元素，直至这个方法最后返回 `null`
:::

`TreeWalker` 类型还有一个属性，名叫 `currentNode`，表示任何遍历方法在上一次遍历中返回的节点。通过设置这个属性也可以修改遍历继续进行的起点，如下所示

```js
var node = walker.nextNode();
console.log(node === walker.currentNode);//true
walker.currentNode = document.body;    //修改起点
```

与`NodeIterator`相比，`TreeWalker`类型在遍历`DOM`时拥有更大的灵活性。由于IE8-浏览器中没有对应的类型和方法，所以使用遍历的跨浏览器解决方案非常少见

