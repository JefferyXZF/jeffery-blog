---
title: JavaScript 运算符
date: 2020-12-27 18:27:01
permalink: /pages/aaee3errwdasweew
author: 
  name: jeffery
categories: 
  - javascript
tags: 
  - javascript
---

# JavaScript 运算符

## 概述

`javascript` 中的运算符大多由标点符号表示，少数由关键字表示, 运算符根据操作个数进行分类，有分为一元运算符、二元运算符、三元运算符

## 一元运算符

一元运算符用于一个单独的操作数，并产生一个新值。在 `javascript` 中，一元运算符具有很高的优先级，而且都是右结合

一元运算符主要包括以下几个
```js
++ -- - + ~ ! delete typeof void
```

**一元加(+)**

在对非数值应用一元加运算符时，会调用 `Number()` 转型函数对这个值进行转换

```js
var s1 = '01';
var s2 = '1.1';
var s3 = 'z';
var b = false;
var f = 1.1;
var o = {
    valueOf:function(){
        return -1;
    }
};

s1 = +s1;//1
s2 = +s2;//1.1
s3 = +s3;//NaN
b = +b;//0
f = +f;//1.1
o = +o;//-1
```

::: tip 注意
在 `new Date()` 前面使用一元加符号，可以把日期字符串，转换为日期毫秒数
:::

```js
console.log(new Date());// Sun Dec 06 2020 12:33:00 GMT+0800 (中国标准时间)
console.log(+new Date());//1607229180000
```

**一元减(-)**

当一元减运算符用于非数值时，会对该值使用 `Number()` 转型函数进行转换，再将得到的数值转换成负数

```js
var s1 = '01';
var s2 = '1.1';
var s3 = 'z';
var b = false;
var f = 1.1;
var o = {
    valueOf:function(){
        return -1;
    }
};

s1 = -s1;//-1
s2 = -s2;//-1.1
s3 = -s3;//NaN
b = -b;//0
f = -f;//-1.1
o = -o;//1
```

## 二元运算符

二元算术运算符包括加法 `(+)`、减法`(-)`、乘法`(*)`、除法`(/)`和求余`(%)`

### 加法(+)

加法运算不仅可以进行数值加法运算，也可以进行字符串连接

 加法运算遵循如下规则：

  【1】如果其中一个操作数是对象，则对象会转换为原始值：日期对象通过 `toString()` 方法执行转换，其他对象通过 `valueOf()` 方法执行转换。由于多数对象 `valueOf()` 方法无法返回一个原始值，于是会通过 `toString()` 方法来执行转换

  注意：除了单数值数组会转换为数字外，其他原生对象都会通过 `toString()` 方法转换为字符串形式

  【2】在进行了对象到原始值的转换后，如果其中一个操作数是字符串的话，另一个操作数也会转换成字符串，进行字符串连接

  【3】否则，两个操作数都将转换成数字或 `NaN`，进行加法操作


- 单数值数组和 `valueOf()` 返回值为数值的自定义对象转换为数值

```js

console.log(1 + []);//1
var o = {
    valueOf: function(){
        return -1;
    }
}
console.log(1 + o);//0
```

- 其他原生对象则转换为字符串

```js
console.log(1 + {});//'1[object Object]'
console.log(1 + [1,2]);//'11,2'
console.log(1 + new Date());//'1Thu Jun 16 2016 10:27:13 GMT+0800 (中国标准时间)'
console.log(1 + /0/);//'1/0/'
```

- 如果进行算术加法运算，`undefined` 转换为 `NaN`，`null`转换为`0`，`false`转换为`0`，`true`转换为`1`

```js
console.log(undefined + undefined);//NaN
console.log(null + null);//0
console.log(false + false);//0
console.log(true + true);//2
```

- 如果进行字符串连接，`undefined` 转换为 `'undefined'`，`null`转换为`'null'`，`false`转换为`'false'`，`true`转换为`'true'`

```js
console.log('' + undefined);//'undefined'
console.log('' + null);//'null'
console.log('' + false);//'false'
console.log('' + true);//'true'
```

- 在数字加法运算中，`Infinity` 和带符号的 0 的处理较为特殊

```js
Number.MAX_VALUE + Number.MAX_VALUE === Infinity;//true
Infinity + (-Infinity);//NaN
+0 + (-0) === +0;//true
```

### 减法(-)

相对于加法，减法就简单的多，只涉及到数字的减法运算。使用 `Number()` 将非数值类型转换为数值或 `NaN`

```js
console.log(1 - {});//NaN
console.log(1 - [1,2]);//NaN
console.log(1 - /0/);//NaN
console.log(1 - []);//1
```

### 乘法(*)

乘法操作符由一个星号(*)表示，用于计算两个数值的乘积，会通过 `Number()` 将非数值类型转换为数值或 `NaN`

```js
+ Infinity * 0;//NaN
- Infinity * 0;//NaN
Infinity * 非0数值;//Infinity或-Infinity
Infinity * Infinity;//Infinity
```

### 除法(/)

除法操作符由一个斜线(/)表示，执行第一个操作数除以第二个操作数的运算，也会通过 `Number()` 将非数值类型转换为数值或 `NaN`

```js
Infinity / Infinity;//NaN
0 / 0;//NaN
非0数值 / 0;//Infinity或-Infinity
Infinity / 0;//Infinity
Infinity / 非0数值;//Infinity
```

### 求模(%)

求模(余数)操作符是由一个百分号(%)表示，是第一个操作数除以第二个操作数的余数

## 三元运算符(ternary operator)

条件判断运算符 `?:`，它将三个表达式合并成一个表达式

```js
2>1 ? 2 : 1;
```

## 关系运算符


**== 相等运算符**
两个操作数类型不同时，相等运算符 `'=='` 会遵守如下规则：

 【1】如果一个值是对象类型，另一值是原始类型，则对象类型会先使用 `valueOf()` 转换成原始值，如果结果还不是原始值，则再使用 `toString()` 方法转换，再进行比较

  注意：日期类只允许使用 `toString()` 方法转换为字符串。

  【2】在对象转换为原始值之后，如果两个操作数都是字符串，则进行字符串的比较
```js
console.log(new Date() == 'Sat Jun 25 2016 11:07:20 GMT+0800 (中国标准时间)');//true
```

【3】在对象转换为原始值之后，如果至少有一个操作数不是字符串，则两个操作数都将通过 `Number()` 转型函数转换成数字进行数值比较
```js
console.log(true == 1);//true
console.log(true == 0);//false
console.log(false == '1');//false
console.log(false == '0');//true
console.log(true == 'true');//false，相当于1 == NaN

console.log([1] == 1);//true，相当于1 == 1
console.log([1] == '1');//true，相当于'1' == '1'
console.log([] == 0);//true，相当于0 == 0
console.log([] == '0');//false，相当于'' == '0'


console.log([] == true);//false，相当于0 == 1
console.log([1] == true);//true，相当于1 == 1

```

**大于或小于运算符**

只有数字和字符串才能真正执行比较操作，不是数字和字符串的操作数将进行类型转换，类型转换规则如下：

【1】如果操作数是对象，则这个对象将先使用 `valueOf()` 转换成原始值，如果结果还不是原始值，则再使用`toString()`方法转换

【2】在对象转换为原始值之后，如果两个操作数都是字符串，则按照字母表的顺序对两个字符串进行比较，这里提到的字母表顺序是指组成这个字符串的 `16位unicode` 字符的索引顺序

```js
console.log('b' > 'a');//true
console.log('B' > 'a');//false

console.log({} > '[a]');//true，相当于'[object Object]' > '[a]'
console.log({} > '[p]');//false，相当于'[object Object]' > '[p]'


console.log(['a'] > ['b']);//false，相当于'a' > 'b'
console.log([2] > [11]);//true，相当于'2' > '11'
```

注意：在字母表中大写字母在小写字母的前面，所以大写字母 < 小写字母；但字符串 `String` 对象有一个字符串比较的方法 `localeCompare()` 方法会考虑自然语言的排序情况，把 `'B'` 排在 `'a'` 的后面，如果字符串在字母表中排在其参数之前时，则该方法返回一个负数；字符串在字母表中排在其参数之后时，返回一个正数

```js
console.log('B'.localeCompare('a'));//1
console.log('B' > 'a');//false
console.log('b'.localeCompare('a'));//1
console.log('b' > 'a');//true
```

【3】在对象转换为原始值之后，如果至少有一个操作数不是字符串，则两个操作数都转换成数字进行比较

```js
console.log(new Date() > 100);//true，相当于1466826928667 > 100
console.log(true > [0]);//true，相当于 1 > 0

console.log(2 > 1);//true
console.log(11 > '2');//true，相当于11 > 2


console.log(NaN > 1);//false
console.log(1 > NaN);//false
console.log({} > true);//false，相当于 NaN > 1

```

::: warning
`null == 0` 的结果为 `false`，这是因为 `javascript` 将 `null == undefined` 的结果设为true。在大于运算中， `null` 和 `undefined` 进行 `Number()` 转型函数转换分别转换为 `0` 和 `NaN`
:::

```js
console.log(undefined > -1);//false，相当于NaN > -1
console.log(null > -1);//true，相当于0 > -1
console.log(undefined > 0);//false，相当于NaN > 0
console.log(null > 0);//false，相当于0 > 0  
```

## 位运算符

位运算符是非常底层的运算，由于其很不直观，所以并不常用。但是，其速度极快，且合理使用能达到很好的效果

`ECMAScript` 中的所有数值都以 `IEEE-754` 64位格式存储，但位操作符并不直接操作64位的值，而是以32位带符号的整数进行运算的，并且返回值也是一个32位带符号的整数

这种位数转换使得在对特殊的 `NaN` 和 `Infinity` 值应用位操作时，这两个值都会被当成 `0` 来处理

 如果对非数值应用位操作符，会先使用 `Number()` 将该值转换成数值再应用位操作，得到的结果是一个数值

```js
//'|'表示按位或，一个整数与0按位或运算可以得到它本身，一个小数与0按位或运算可以得到取整效果
console.log( 1.3 | 0);//1
console.log( 1.8 | 0);//1
console.log( Infinity | 0);//0
console.log( -Infinity | 0);//0
console.log( NaN | 0);//0
console.log('12px' | 0);//0
console.log('12' | 0);//12
```

有符号整数使用32位中的前31位表示整数数值，用第32位表示整数符号，0表示正数，1表示负数。表示符号的位叫做符号位，符号位的值决定了其他位数值的格式。其中，正数以纯二进制格式存储，31位中的每一位都表示2的幂。第一位(叫做位0)表示2的0次，第二位表示2的1次，以此类推。没有用到的位以0填充，即忽略不计

例如，数值18的二进制表示是00000000000000000000000000010010，或者更简洁的10010。这是5个有效位，这5位本身就决定了实际的值

```js
console.log((18).toString(2));//"10010"
console.log(0b00000000000000000000000000010010);//18
```

**左移**

左移操作符由两个小于号 `<<` 表示，这个操作符会将数值的所有位向左移动指定的位数

例如，如果将数值2(二进制码为10)向左移动5位，结果就是64(1000000)

```js
var oldValue = 2;
var newValue = oldValue<<5;
console.log(newValue);//64
```

左移不会影响操作数的符号位。换句话说，如果将-2向左移动5位，结果将是-64

```js
var oldValue = -2;
var newValue = oldValue<<5;
console.log(newValue);//-64
```

::: tip 
左移0位可以实现取整效果
:::

```js
console.log(3.1 << 0);//3
console.log(3.9 << 0);//3
```

**有符号右移**

有符号的右移操作符由两个大于号 `>>` 表示，这个操作符会将数值向右移动，但保留符号位(即正负号标记)。有符号的右移操作与左移操作正好相反，即如果将64向右移动5位，结果将变回2

```js
var oldValue = 64;
var newValue = oldValue>>5;
console.log(newValue);//2
```

 同样，在移位过程中，原数值中也会出现空位。只不过这次的空位出现在原数值的左侧、符号位的右侧。而此时 `ECMAScript` 会用符号位的值来填充所有空位，以便得到一个完整的值

 右移可以模拟2的整除运算

```js
console.log(5>>1);//2
console.log(15>>1);//7
```

**无符号右移**

无符号右移操作符由3个大于号 `>>>` 表示，这个操作符会将数值的所有32位都向右移动。对正数来说，无符号右移的结果与有符号右移相同。仍以前面有符号右移为便，如果将64无符号右移5位，结果仍然是2

```js
var oldValue = 64;
var newValue = oldValue>>>5;
console.log(newValue);//2
```

但是，对负数就不一样了。首先，无符号右移是以0来填充空位，而不是像有符号右移那样以符号位的值来填充空位。所以，对正数的无符号右移与有称号右移结果相同，但对负数的结果就不同了。其次，无符号右移操作符会把负数的二进制码当成正数的二进制码。而且，由于负数以其绝对值的二进制补码形式表示，因此就会导致无符号右移后的结果非常之大

```js
var oldValue = -64;
var newValue = oldValue>>>5;
console.log(newValue)//134217726
```

### 常见应用

【1】乘法运算

  利用左移(<<)来实现乘法运算
```js
console.log(2 << 1);//4
console.log(3 << 1);//6
console.log(4 << 1);//8
```

【2】除法运算

 利用有符号右移(>>)来模拟2的整除运算

```js
console.log(2 >> 1);//1
console.log(5 >> 1);//2
console.log(8 >> 1);//4
console.log(9 >> 1);//4
```

【3】值互换

 利用异或操作 `^` 可以实现值互换的效果
```js
var a=10,b=9;
a ^= b, b ^= a, a ^= b;
console.log(a,b);//9,10
```

【4】小数取整

  利用取两次按位非、与0按位或、与0按位异或、左移0位、右移0位都可以实现小数取整效果
```js
console.log(~~3.1);//3
console.log(3.1|0);//3
console.log(3.1^0);//3
console.log(3.1<<0);//3
console.log(3.1>>0);//3
```
## 运算符优先级

运算符优先级控制着执行顺序，优先级高的运算符的执行总是先于优先级运算符低的运算符

从高到低依次是：
```js
1  ++ -- - + ~ ! delete typeof void
2  * / %
3  + -
4  << >> >>>
5  < <= > >= instanceof in
6  == != === !==
7  &
8  ^
9  |
10 &&
11 ||
12 ?:
13 = *= /= %= += -= &= ^= |= <<= >>= >>>=
14 ,
```

由这14级的运算符优先级等级可以看出：

```js
一元运算符 > 算术运算符 > 比较运算符 > 逻辑运算符 > 三元运算符 > 赋值运算符 > 逗号运算符
```

例如
```js
!2<1&&4*3+1;
```

1、首先计算一元运算符!，!2;//false
```js
//于是表达式变为
false < 1 && 4*3 + 1;
```

2、计算算术运算符4*3+1;//13
```js
//于是表达式变为
false < 1 && 13;
```

3、计算比较运算符<，false<1;//true
```js
//于是表达式变为:
true && 13;//13
```

## 结合性

运算符具有两种结合性，一种是从左向右结合，记号为L，一种是从右向左结合，记号为R。结合性指定了在多个具有同样优先级的运算符表达式中的运算顺序

多数运算符都具有从左向右的结合性，只有一元运算符、条件运算符和赋值运算符具有从右向左的结合性

**运算符的优先级和结合性决定了它们在复杂表达式中的运算顺序，但子表达式相互有影响时，顺序会发生变**

例如
```js
a = 1;
b = a++ + a-- * a++;
```

先分析该表达式中，根据优先级的顺序，分别运算递增运算符、乘法运算符、加法运算符和赋值运算符

- 先计算第一个a++; 结果为1，a为2
```js
//表达式变成
b = 1 + a-- * a++;
```

- 计算a--; 结果为2，a为1
```js
//表达式变成
b = 1 + 2 * a++;
```

- 计算第二个a++; 结果为1，a为2
```js
//表达式变成
b = 1 + 2 * 1;
```

所以，最终a = 2; b = 3;

## 运算符规则表

```
运算符              操作                类型
++                增量                 lval->num
--                减量                 lval->num
-                 求反                 num->num
+                 转换为数字            num->num
~                 按位求反              int->int
!                 逻辑非                bool->bool
delete            删除属性              lval->bool
typeof            检测类型              any->str
void              返回undefined         any->undef
* \ %             乘、除、求余           num,num->num
+ -               加、减                num,num->num
+                 字符串连接             str,str->str
<<                左移位                int,int->int
>>                有符号右移位           int,int->int
>>>               无符号右移位           int,int->int
< <= > >=         比较数字顺序           num,num->bool
< <= > >=         比较字母表顺序         str,str->bool
instanceof        测试对象类            obj,func->bool
in                测试属性              str,obj->bool
==                判断相等              any,any->bool
!=                判断不等              any,any->bool
===               判断恒等              any,any->bool
!==               判断非恒等            any,any->bool
&                 按位与                int,int->int
^                 按位异或              int,int->int
|                 按位或                int,int->int
&&                逻辑与                any,any->any
||                逻辑或                any,any->any
?:                条件运算符             bool,any,any->any
=                  赋值                 lval,any->any
*= /= %=
+= -= &=          运算且赋值             lval,any->any
^= |= <<=
>>= >>>=
,                 忽略第一个操作数，       any,any->any
                  返回第二个操作数
```

