(window.webpackJsonp=window.webpackJsonp||[]).push([[186],{618:function(t,e,a){"use strict";a.r(e);var s=a(11),r=Object(s.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"vuex-进阶知识"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vuex-进阶知识"}},[t._v("#")]),t._v(" Vuex 进阶知识")]),t._v(" "),a("h3",{attrs:{id:"vuex是什么"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vuex是什么"}},[t._v("#")]),t._v(" Vuex是什么")]),t._v(" "),a("p",[t._v("Vuex 是一个专为 Vue.js应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。Vuex 也集成到 Vue 的官方调试工具 devtools extension，提供了诸如零配置的 time-travel 调试、状态快照导入导出等高级调试功能。")]),t._v(" "),a("h3",{attrs:{id:"vuex的有哪些属性？用处是什么？"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vuex的有哪些属性？用处是什么？"}},[t._v("#")]),t._v(" vuex的有哪些属性？用处是什么？")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9566927e955c4d0ba19df942534e5b53~tplv-k3u1fbpfcp-watermark.awebp",alt:"image.png"}})]),t._v(" "),a("ul",[a("li",[t._v("State：唯一数据源 ,Vue 实例中的 data 遵循相同的规则")]),t._v(" "),a("li",[t._v("Getter：可以认为是 store 的计算属性, 就像计算属性一样，getter 的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。Getter 会暴露为 store.getters 对象，你可以以属性的形式访问这些值.，mapGetters 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性。")]),t._v(" "),a("li",[t._v("Mutation：更改 Vuex 的 store 中状态的唯一方法是提交 mutation, 类似于事件,通过 "),a("code",[t._v("store.commit")]),t._v(" 方法触发且必须是同步函数。")]),t._v(" "),a("li",[t._v("Action：用于提交 mutation，而不是直接变更状态，可以包含任意异步操作。")]),t._v(" "),a("li",[t._v("Module：允许将单一的 Store 拆分为多个 store 且同时保存在单一的状态树中。")])]),t._v(" "),a("h3",{attrs:{id:"ajax请求代码应该写在组件的methods中还是vuex的actions中"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#ajax请求代码应该写在组件的methods中还是vuex的actions中"}},[t._v("#")]),t._v(" ajax请求代码应该写在组件的methods中还是vuex的actions中")]),t._v(" "),a("p",[t._v("如果请求来的数据是不是要被其他组件公用，仅仅在请求的组件内使用，就不需要放入vuex 的state里。")]),t._v(" "),a("p",[t._v("如果被其他地方复用，这个很大几率上是需要的，如果需要，请将请求放入action里，方便复用。")]),t._v(" "),a("h3",{attrs:{id:"vuex-页面刷新数据丢失怎么解决"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vuex-页面刷新数据丢失怎么解决"}},[t._v("#")]),t._v(" Vuex 页面刷新数据丢失怎么解决")]),t._v(" "),a("p",[t._v("需要做 vuex 数据持久化 一般使用本地存储的方案来保存数据 可以自己设计存储方案 也可以使用第三方插件")]),t._v(" "),a("p",[t._v("推荐使用 vuex-persist 插件，它就是为 Vuex 持久化存储而生的一个插件。不需要你手动存取 storage ，而是直接将状态保存至 cookie 或者 localStorage 中")]),t._v(" "),a("h3",{attrs:{id:"vuex-为什么要分模块并且加命名空间"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vuex-为什么要分模块并且加命名空间"}},[t._v("#")]),t._v(" Vuex 为什么要分模块并且加命名空间")]),t._v(" "),a("p",[a("strong",[t._v("模块")]),t._v(":由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store 对象就有可能变得相当臃肿。为了解决以上问题，Vuex 允许我们将 store 分割成模块（module）。每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块。")]),t._v(" "),a("p",[a("strong",[t._v("命名空间")]),t._v("：默认情况下，模块内部的 action、mutation 和 getter 是注册在全局命名空间的——这样使得多个模块能够对同一 mutation 或 action 作出响应。如果希望你的模块具有更高的封装度和复用性，你可以通过添加 namespaced: true 的方式使其成为带命名空间的模块。当模块被注册后，它的所有 getter、action 及 mutation 都会自动根据模块注册的路径调整命名。")])])}),[],!1,null,null,null);e.default=r.exports}}]);