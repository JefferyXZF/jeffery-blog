(window.webpackJsonp=window.webpackJsonp||[]).push([[222],{655:function(t,e,s){"use strict";s.r(e);var a=s(11),v=Object(a.a)({},(function(){var t=this,e=t.$createElement,s=t._self._c||e;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"栈数据结构"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#栈数据结构"}},[t._v("#")]),t._v(" 栈数据结构")]),t._v(" "),s("h2",{attrs:{id:"前言"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#前言"}},[t._v("#")]),t._v(" 前言")]),t._v(" "),s("p",[t._v("栈是一种遵从后进先出（LIFO）原则的有序集合。新添加或待删除的元素都保存在栈的同一端，称作栈顶，另一端就叫栈底。在栈里，新元素都靠近栈顶，旧元素都接近栈底。")]),t._v(" "),s("h2",{attrs:{id:"创建一个基于数组的栈"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#创建一个基于数组的栈"}},[t._v("#")]),t._v(" 创建一个基于数组的栈")]),t._v(" "),s("p",[t._v("栈操作方法")]),t._v(" "),s("ul",[s("li",[t._v("push(element(s))：添加一个（或几个）新元素到栈顶。")]),t._v(" "),s("li",[t._v("pop()：移除栈顶的元素，同时返回被移除的元素。")]),t._v(" "),s("li",[t._v("peek()：返回栈顶的元素，不对栈做任何修改（该方法不会移除栈顶的元素，仅仅返回它）。")]),t._v(" "),s("li",[t._v("isEmpty()：如果栈里没有任何元素就返回 "),s("code",[t._v("true")]),t._v("，否则返回 "),s("code",[t._v("false")])]),t._v(" "),s("li",[t._v("clear()：移除栈里的所有元素。")]),t._v(" "),s("li",[t._v("size()：返回栈里的元素个数。该方法和数组的 "),s("code",[t._v("length")]),t._v(" 属性很类似。")])])])}),[],!1,null,null,null);e.default=v.exports}}]);